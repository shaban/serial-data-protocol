package golang

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateDecoder generates a Decode function for each struct in the schema.
// For each struct type, it generates:
//   - Decode(dest *StructName, data []byte) error
//   - Entry point validation (128MB size limit)
//   - DecodeContext creation for tracking element limits
//   - Call to helper decode function
//
// Example output:
//
//	func DecodeDevice(dest *Device, data []byte) error {
//	    if len(data) > MaxSerializedSize {
//	        return ErrDataTooLarge
//	    }
//	    ctx := &DecodeContext{}
//	    offset := 0
//	    return decodeDevice(dest, data, &offset, ctx)
//	}
//
// The actual decoding logic is delegated to helper functions (decodeDevice)
// that will be generated by other generator functions.
func GenerateDecoder(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	if len(schema.Structs) == 0 {
		return "", fmt.Errorf("schema has no structs")
	}

	var buf strings.Builder

	for i, s := range schema.Structs {
		// Add blank line between functions (except before first)
		if i > 0 {
			buf.WriteString("\n")
		}

		structName := ToGoName(s.Name)
		funcName := "Decode" + structName
		helperName := "decode" + structName

		// Generate doc comment
		buf.WriteString("// ")
		buf.WriteString(funcName)
		buf.WriteString(" decodes a ")
		buf.WriteString(structName)
		buf.WriteString(" from wire format.\n")
		buf.WriteString("// It validates the data size and delegates to the decoder implementation.\n")

		// Generate function signature
		buf.WriteString("func ")
		buf.WriteString(funcName)
		buf.WriteString("(dest *")
		buf.WriteString(structName)
		buf.WriteString(", data []byte) error {\n")

		// Entry point validation
		buf.WriteString("\tif len(data) > MaxSerializedSize {\n")
		buf.WriteString("\t\treturn ErrDataTooLarge\n")
		buf.WriteString("\t}\n")

		// Create DecodeContext
		buf.WriteString("\tctx := &DecodeContext{}\n")
		buf.WriteString("\toffset := 0\n")

		// Call helper function
		buf.WriteString("\treturn ")
		buf.WriteString(helperName)
		buf.WriteString("(dest, data, &offset, ctx)\n")

		buf.WriteString("}\n")
	}

	return buf.String(), nil
}

// GenerateDecodeHelpers generates the helper decode functions for each struct.
// These functions implement the actual decoding logic for struct fields.
// For each struct, it generates a helper function like:
//
//	func decodeStructName(dest *StructName, data []byte, offset *int, ctx *DecodeContext) error {
//	    // Decode each field
//	    return nil
//	}
//
// This function currently handles primitive types. String, array, and nested
// struct decoding will be added in subsequent tasks.
func GenerateDecodeHelpers(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	if len(schema.Structs) == 0 {
		return "", fmt.Errorf("schema has no structs")
	}

	var buf strings.Builder

	for i, s := range schema.Structs {
		// Add blank line between functions (except before first)
		if i > 0 {
			buf.WriteString("\n")
		}

		structName := ToGoName(s.Name)
		helperName := "decode" + structName

		// Generate doc comment
		buf.WriteString("// ")
		buf.WriteString(helperName)
		buf.WriteString(" is the helper function that decodes ")
		buf.WriteString(structName)
		buf.WriteString(" fields.\n")

		// Generate function signature
		buf.WriteString("func ")
		buf.WriteString(helperName)
		buf.WriteString("(dest *")
		buf.WriteString(structName)
		buf.WriteString(", data []byte, offset *int, ctx *DecodeContext) error {\n")

		// Check if struct has optional fields
		hasOptional := false
		for _, field := range s.Fields {
			if field.Type.Optional {
				hasOptional = true
				break
			}
		}

		// Declare temporary variables used in decoding
		buf.WriteString("\tvar (\n")
		buf.WriteString("\t\tstrLen uint32  // For string length prefix\n")
		buf.WriteString("\t\tarrCount uint32  // For array count\n")
		if hasOptional {
			buf.WriteString("\t\tpresence byte  // For optional field presence flags\n")
		}
		buf.WriteString("\t\terr error  // For error handling\n")
		buf.WriteString("\t)\n")
		buf.WriteString("\t_ = strLen  // Avoid unused variable error\n")
		buf.WriteString("\t_ = arrCount  // Avoid unused variable error\n")
		if hasOptional {
			buf.WriteString("\t_ = presence  // Avoid unused variable error\n")
		}
		buf.WriteString("\t_ = err  // Avoid unused variable error\n")
		buf.WriteString("\n")

		// Generate field decoding
		for _, field := range s.Fields {
			if err := generateFieldDecode(&buf, &field); err != nil {
				return "", fmt.Errorf("struct %q, field %q: %w", s.Name, field.Name, err)
			}
		}

		buf.WriteString("\treturn nil\n")
		buf.WriteString("}\n")
	}

	return buf.String(), nil
}

// generateFieldDecode generates the decoding logic for a single field.
func generateFieldDecode(buf *strings.Builder, field *parser.Field) error {
	fieldName := ToGoName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		buf.WriteString("\t// Field: ")
		buf.WriteString(fieldName)
		buf.WriteString(" (optional)\n")

		// Read presence flag
		buf.WriteString("\tif *offset >= len(data) {\n")
		buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tpresence = data[*offset]\n")
		buf.WriteString("\t*offset += 1\n\n")

		// Check presence
		buf.WriteString("\tif presence == 0 {\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString(" = nil\n")
		buf.WriteString("\t} else if presence == 1 {\n")

		// Allocate and decode the value
		tempBuf := &strings.Builder{}
		var err error

		switch field.Type.Kind {
		case parser.TypeKindPrimitive:
			err = generatePrimitiveDecodeForOptional(tempBuf, field.Type.Name, fieldName)
		case parser.TypeKindNamed:
			err = generateNamedTypeDecodeForOptional(tempBuf, field.Type.Name, fieldName)
		case parser.TypeKindArray:
			err = generateArrayDecodeForOptional(tempBuf, &field.Type, fieldName)
		default:
			err = fmt.Errorf("unknown type kind: %v", field.Type.Kind)
		}

		if err != nil {
			return err
		}

		// Add extra indentation
		lines := strings.Split(tempBuf.String(), "\n")
		for _, line := range lines {
			if line != "" {
				buf.WriteString("\t")
				buf.WriteString(line)
				buf.WriteString("\n")
			}
		}

		// Handle invalid presence flag
		buf.WriteString("\t} else {\n")
		buf.WriteString("\t\treturn ErrInvalidData\n")
		buf.WriteString("\t}\n\n")

		return nil
	}

	// Non-optional fields - decode normally
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		return generatePrimitiveDecode(buf, field.Type.Name, fieldName)
	case parser.TypeKindNamed:
		return generateNamedTypeDecode(buf, field.Type.Name, fieldName)
	case parser.TypeKindArray:
		return generateArrayDecode(buf, &field.Type, fieldName)
	default:
		return fmt.Errorf("unknown type kind: %v", field.Type.Kind)
	}
}

// generatePrimitiveDecode generates decoding code for a primitive field.
func generatePrimitiveDecode(buf *strings.Builder, primitiveType, fieldName string) error {
	// Add field comment
	buf.WriteString("\t// Field: ")
	buf.WriteString(fieldName)
	buf.WriteString(" (")
	buf.WriteString(primitiveType)
	buf.WriteString(")\n")

	// Handle different primitive types
	switch primitiveType {
	case "u8":
		generateU8Decode(buf, fieldName)
	case "u16":
		generateU16Decode(buf, fieldName)
	case "u32":
		generateU32Decode(buf, fieldName)
	case "u64":
		generateU64Decode(buf, fieldName)
	case "i8":
		generateI8Decode(buf, fieldName)
	case "i16":
		generateI16Decode(buf, fieldName)
	case "i32":
		generateI32Decode(buf, fieldName)
	case "i64":
		generateI64Decode(buf, fieldName)
	case "f32":
		generateF32Decode(buf, fieldName)
	case "f64":
		generateF64Decode(buf, fieldName)
	case "bool":
		generateBoolDecode(buf, fieldName)
	case "str":
		generateStringDecode(buf, fieldName)
	default:
		return fmt.Errorf("unknown primitive type: %s", primitiveType)
	}

	return nil
}

// generateU8Decode generates decode code for u8 (uint8)
func generateU8Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 1 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = uint8(data[*offset])\n")
	buf.WriteString("\t*offset += 1\n")
	buf.WriteString("\n")
}

// generateU16Decode generates decode code for u16 (uint16)
func generateU16Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 2 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = binary.LittleEndian.Uint16(data[*offset:])\n")
	buf.WriteString("\t*offset += 2\n")
	buf.WriteString("\n")
}

// generateU32Decode generates decode code for u32 (uint32)
func generateU32Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 4 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = binary.LittleEndian.Uint32(data[*offset:])\n")
	buf.WriteString("\t*offset += 4\n")
	buf.WriteString("\n")
}

// generateU64Decode generates decode code for u64 (uint64)
func generateU64Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 8 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = binary.LittleEndian.Uint64(data[*offset:])\n")
	buf.WriteString("\t*offset += 8\n")
	buf.WriteString("\n")
}

// generateI8Decode generates decode code for i8 (int8)
func generateI8Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 1 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = int8(data[*offset])\n")
	buf.WriteString("\t*offset += 1\n")
	buf.WriteString("\n")
}

// generateI16Decode generates decode code for i16 (int16)
func generateI16Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 2 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = int16(binary.LittleEndian.Uint16(data[*offset:]))\n")
	buf.WriteString("\t*offset += 2\n")
	buf.WriteString("\n")
}

// generateI32Decode generates decode code for i32 (int32)
func generateI32Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 4 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = int32(binary.LittleEndian.Uint32(data[*offset:]))\n")
	buf.WriteString("\t*offset += 4\n")
	buf.WriteString("\n")
}

// generateI64Decode generates decode code for i64 (int64)
func generateI64Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 8 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = int64(binary.LittleEndian.Uint64(data[*offset:]))\n")
	buf.WriteString("\t*offset += 8\n")
	buf.WriteString("\n")
}

// generateF32Decode generates decode code for f32 (float32)
func generateF32Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 4 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = math.Float32frombits(binary.LittleEndian.Uint32(data[*offset:]))\n")
	buf.WriteString("\t*offset += 4\n")
	buf.WriteString("\n")
}

// generateF64Decode generates decode code for f64 (float64)
func generateF64Decode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 8 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = math.Float64frombits(binary.LittleEndian.Uint64(data[*offset:]))\n")
	buf.WriteString("\t*offset += 8\n")
	buf.WriteString("\n")
}

// generateBoolDecode generates decode code for bool
func generateBoolDecode(buf *strings.Builder, fieldName string) {
	buf.WriteString("\tif *offset + 1 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = data[*offset] != 0\n")
	buf.WriteString("\t*offset += 1\n")
	buf.WriteString("\n")
}

// generateStringDecode generates decode code for string (str)
func generateStringDecode(buf *strings.Builder, fieldName string) {
	// Read length prefix
	buf.WriteString("\tif *offset + 4 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tstrLen = binary.LittleEndian.Uint32(data[*offset:])\n")
	buf.WriteString("\t*offset += 4\n")
	buf.WriteString("\n")

	// Read string bytes
	buf.WriteString("\tif *offset + int(strLen) > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = string(data[*offset:*offset+int(strLen)])\n")
	buf.WriteString("\t*offset += int(strLen)\n")
	buf.WriteString("\n")
}

// generateNamedTypeDecode generates decode code for named type (nested struct) fields.
func generateNamedTypeDecode(buf *strings.Builder, typeName, fieldName string) error {
	// Add field comment
	buf.WriteString("\t// Field: ")
	buf.WriteString(fieldName)
	buf.WriteString(" (")
	buf.WriteString(typeName)
	buf.WriteString(")\n")

	// Call the helper decode function for the nested struct
	goTypeName := ToGoName(typeName)
	helperName := "decode" + goTypeName

	buf.WriteString("\terr = ")
	buf.WriteString(helperName)
	buf.WriteString("(&dest.")
	buf.WriteString(fieldName)
	buf.WriteString(", data, offset, ctx)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\n")

	return nil
}

// generateArrayDecode generates decode code for array fields.
func generateArrayDecode(buf *strings.Builder, arrayType *parser.TypeExpr, fieldName string) error {
	if arrayType.Elem == nil {
		return fmt.Errorf("array type has no element type")
	}

	// Add field comment
	buf.WriteString("\t// Field: ")
	buf.WriteString(fieldName)
	buf.WriteString(" ([]")

	// Get element type name for comment
	elemTypeName, err := getTypeNameForComment(arrayType.Elem)
	if err != nil {
		return err
	}
	buf.WriteString(elemTypeName)
	buf.WriteString(")\n")

	// Read array count
	buf.WriteString("\tif *offset + 4 > len(data) {\n")
	buf.WriteString("\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tarrCount = binary.LittleEndian.Uint32(data[*offset:])\n")
	buf.WriteString("\t*offset += 4\n")
	buf.WriteString("\n")

	// Check array size limit
	buf.WriteString("\terr = ctx.checkArraySize(arrCount)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\n")

	// Allocate array
	buf.WriteString("\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = make([]")

	// Get Go type for allocation
	goType, err := getGoTypeForArray(arrayType.Elem)
	if err != nil {
		return err
	}
	buf.WriteString(goType)
	buf.WriteString(", arrCount)\n")

	// Decode elements
	buf.WriteString("\tfor i := uint32(0); i < arrCount; i++ {\n")

	// Generate element decode based on type
	if err := generateArrayElementDecode(buf, arrayType.Elem, fieldName); err != nil {
		return err
	}

	buf.WriteString("\t}\n")
	buf.WriteString("\n")

	return nil
}

// getTypeNameForComment returns a simple type name for field comments.
func getTypeNameForComment(typeExpr *parser.TypeExpr) (string, error) {
	switch typeExpr.Kind {
	case parser.TypeKindPrimitive:
		return typeExpr.Name, nil
	case parser.TypeKindNamed:
		return typeExpr.Name, nil
	case parser.TypeKindArray:
		elemName, err := getTypeNameForComment(typeExpr.Elem)
		if err != nil {
			return "", err
		}
		return "[]" + elemName, nil
	default:
		return "", fmt.Errorf("unknown type kind: %v", typeExpr.Kind)
	}
}

// getGoTypeForArray returns the Go type string for array element allocation.
func getGoTypeForArray(elemType *parser.TypeExpr) (string, error) {
	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		goType, err := MapTypeToGo(elemType)
		if err != nil {
			return "", err
		}
		return goType, nil
	case parser.TypeKindNamed:
		return ToGoName(elemType.Name), nil
	case parser.TypeKindArray:
		// Nested array
		innerType, err := getGoTypeForArray(elemType.Elem)
		if err != nil {
			return "", err
		}
		return "[]" + innerType, nil
	default:
		return "", fmt.Errorf("unknown type kind: %v", elemType.Kind)
	}
}

// generateArrayElementDecode generates code to decode a single array element.
func generateArrayElementDecode(buf *strings.Builder, elemType *parser.TypeExpr, fieldName string) error {
	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		return generateArrayPrimitiveElementDecode(buf, elemType.Name, fieldName)
	case parser.TypeKindNamed:
		return generateArrayNamedTypeElementDecode(buf, elemType.Name, fieldName)
	case parser.TypeKindArray:
		// Nested arrays - not supported per design spec
		return fmt.Errorf("nested arrays not supported")
	default:
		return fmt.Errorf("unknown element type kind: %v", elemType.Kind)
	}
}

// generateArrayPrimitiveElementDecode generates decode code for primitive array elements.
func generateArrayPrimitiveElementDecode(buf *strings.Builder, primitiveType, fieldName string) error {
	switch primitiveType {
	case "u8":
		buf.WriteString("\t\tif *offset + 1 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = uint8(data[*offset])\n")
		buf.WriteString("\t\t*offset += 1\n")

	case "u16":
		buf.WriteString("\t\tif *offset + 2 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = binary.LittleEndian.Uint16(data[*offset:])\n")
		buf.WriteString("\t\t*offset += 2\n")

	case "u32":
		buf.WriteString("\t\tif *offset + 4 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = binary.LittleEndian.Uint32(data[*offset:])\n")
		buf.WriteString("\t\t*offset += 4\n")

	case "u64":
		buf.WriteString("\t\tif *offset + 8 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = binary.LittleEndian.Uint64(data[*offset:])\n")
		buf.WriteString("\t\t*offset += 8\n")

	case "i8":
		buf.WriteString("\t\tif *offset + 1 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = int8(data[*offset])\n")
		buf.WriteString("\t\t*offset += 1\n")

	case "i16":
		buf.WriteString("\t\tif *offset + 2 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = int16(binary.LittleEndian.Uint16(data[*offset:]))\n")
		buf.WriteString("\t\t*offset += 2\n")

	case "i32":
		buf.WriteString("\t\tif *offset + 4 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = int32(binary.LittleEndian.Uint32(data[*offset:]))\n")
		buf.WriteString("\t\t*offset += 4\n")

	case "i64":
		buf.WriteString("\t\tif *offset + 8 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = int64(binary.LittleEndian.Uint64(data[*offset:]))\n")
		buf.WriteString("\t\t*offset += 8\n")

	case "f32":
		buf.WriteString("\t\tif *offset + 4 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[*offset:]))\n")
		buf.WriteString("\t\t*offset += 4\n")

	case "f64":
		buf.WriteString("\t\tif *offset + 8 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[*offset:]))\n")
		buf.WriteString("\t\t*offset += 8\n")

	case "bool":
		buf.WriteString("\t\tif *offset + 1 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = data[*offset] != 0\n")
		buf.WriteString("\t\t*offset += 1\n")

	case "str":
		// String array element
		buf.WriteString("\t\tif *offset + 4 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tstrLen := binary.LittleEndian.Uint32(data[*offset:])\n")
		buf.WriteString("\t\t*offset += 4\n")
		buf.WriteString("\t\t\n")
		buf.WriteString("\t\tif *offset + int(strLen) > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tdest.")
		buf.WriteString(fieldName)
		buf.WriteString("[i] = string(data[*offset:*offset+int(strLen)])\n")
		buf.WriteString("\t\t*offset += int(strLen)\n")

	default:
		return fmt.Errorf("unknown primitive type: %s", primitiveType)
	}

	return nil
}

// generateArrayNamedTypeElementDecode generates decode code for named type array elements.
func generateArrayNamedTypeElementDecode(buf *strings.Builder, typeName, fieldName string) error {
	// Call the helper decode function for the nested struct
	goTypeName := ToGoName(typeName)
	helperName := "decode" + goTypeName

	buf.WriteString("\t\terr = ")
	buf.WriteString(helperName)
	buf.WriteString("(&dest.")
	buf.WriteString(fieldName)
	buf.WriteString("[i], data, offset, ctx)\n")
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString("\t\t\treturn err\n")
	buf.WriteString("\t\t}\n")

	return nil
}

// generatePrimitiveDecodeForOptional generates decode code for optional primitive fields.
// This allocates a new value and assigns it to the pointer.
func generatePrimitiveDecodeForOptional(buf *strings.Builder, primitiveType, fieldName string) error {
	goType, ok := primitiveTypeMap[primitiveType]
	if !ok {
		return fmt.Errorf("unknown primitive type: %s", primitiveType)
	}

	// Allocate new value
	buf.WriteString("\t\tvar val ")
	buf.WriteString(goType)
	buf.WriteString("\n")

	// Decode into temporary variable
	switch primitiveType {
	case "u8", "i8", "bool":
		size := 1
		buf.WriteString(fmt.Sprintf("\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")

		if primitiveType == "bool" {
			buf.WriteString("\t\tval = data[*offset] != 0\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t\tval = %s(data[*offset])\n", goType))
		}
		buf.WriteString(fmt.Sprintf("\t\t*offset += %d\n", size))

	case "u16", "i16":
		size := 2
		buf.WriteString(fmt.Sprintf("\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tval = %s(binary.LittleEndian.Uint16(data[*offset:]))\n", goType))
		buf.WriteString(fmt.Sprintf("\t\t*offset += %d\n", size))

	case "u32", "i32", "f32":
		size := 4
		buf.WriteString(fmt.Sprintf("\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		if primitiveType == "f32" {
			buf.WriteString("\t\tval = math.Float32frombits(binary.LittleEndian.Uint32(data[*offset:]))\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t\tval = %s(binary.LittleEndian.Uint32(data[*offset:]))\n", goType))
		}
		buf.WriteString(fmt.Sprintf("\t\t*offset += %d\n", size))

	case "u64", "i64", "f64":
		size := 8
		buf.WriteString(fmt.Sprintf("\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		if primitiveType == "f64" {
			buf.WriteString("\t\tval = math.Float64frombits(binary.LittleEndian.Uint64(data[*offset:]))\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t\tval = %s(binary.LittleEndian.Uint64(data[*offset:]))\n", goType))
		}
		buf.WriteString(fmt.Sprintf("\t\t*offset += %d\n", size))

	case "str":
		buf.WriteString("\t\tif *offset + 4 > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tstrLen := binary.LittleEndian.Uint32(data[*offset:])\n")
		buf.WriteString("\t\t*offset += 4\n\n")

		buf.WriteString("\t\tif *offset + int(strLen) > len(data) {\n")
		buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tval = string(data[*offset : *offset + int(strLen)])\n")
		buf.WriteString("\t\t*offset += int(strLen)\n")

	default:
		return fmt.Errorf("unsupported primitive type: %s", primitiveType)
	}

	// Assign to optional field (take address of value)
	buf.WriteString("\t\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = &val\n")

	return nil
}

// generateNamedTypeDecodeForOptional generates decode code for optional named type fields.
func generateNamedTypeDecodeForOptional(buf *strings.Builder, typeName, fieldName string) error {
	goTypeName := ToGoName(typeName)
	helperName := "decode" + goTypeName

	// Allocate the struct
	buf.WriteString("\t\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = &")
	buf.WriteString(goTypeName)
	buf.WriteString("{}\n")

	// Decode into the allocated struct
	buf.WriteString("\t\terr = ")
	buf.WriteString(helperName)
	buf.WriteString("(dest.")
	buf.WriteString(fieldName)
	buf.WriteString(", data, offset, ctx)\n")
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString("\t\t\treturn err\n")
	buf.WriteString("\t\t}\n")

	return nil
}

// generateArrayDecodeForOptional generates decode code for optional array fields.
func generateArrayDecodeForOptional(buf *strings.Builder, typeExpr *parser.TypeExpr, fieldName string) error {
	if typeExpr.Elem == nil {
		return fmt.Errorf("array type missing element")
	}

	// Read array count
	buf.WriteString("\t\tif *offset + 4 > len(data) {\n")
	buf.WriteString("\t\t\treturn ErrUnexpectedEOF\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tcount := binary.LittleEndian.Uint32(data[*offset:])\n")
	buf.WriteString("\t\t*offset += 4\n\n")

	// Allocate slice
	elemType, err := MapTypeToGo(typeExpr.Elem)
	if err != nil {
		return err
	}

	buf.WriteString("\t\tif count > 0 {\n")
	buf.WriteString("\t\t\tslice := make([]")
	buf.WriteString(elemType)
	buf.WriteString(", count)\n")

	// Decode each element
	buf.WriteString("\t\t\tfor i := uint32(0); i < count; i++ {\n")

	// Generate element decode code
	tempBuf := &strings.Builder{}
	switch typeExpr.Elem.Kind {
	case parser.TypeKindPrimitive:
		err = generateArrayPrimitiveElementDecodeForOptional(tempBuf, typeExpr.Elem.Name)
	case parser.TypeKindNamed:
		err = generateArrayNamedTypeElementDecodeForOptional(tempBuf, typeExpr.Elem.Name)
	default:
		err = fmt.Errorf("unsupported array element kind: %v", typeExpr.Elem.Kind)
	}

	if err != nil {
		return err
	}

	// Add element decode with proper indentation
	lines := strings.Split(tempBuf.String(), "\n")
	for _, line := range lines {
		if line != "" {
			buf.WriteString("\t")
			buf.WriteString(line)
			buf.WriteString("\n")
		}
	}

	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t\tdest.")
	buf.WriteString(fieldName)
	buf.WriteString(" = &slice\n")
	buf.WriteString("\t\t}\n")

	return nil
}

// Helper functions for array element decode in optional context
func generateArrayPrimitiveElementDecodeForOptional(buf *strings.Builder, primitiveType string) error {
	// Similar to non-optional but uses "slice[i]" instead of "dest.FieldName[i]"
	switch primitiveType {
	case "u8", "i8", "bool":
		size := 1
		buf.WriteString(fmt.Sprintf("\t\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t\t}\n")
		if primitiveType == "bool" {
			buf.WriteString("\t\t\tslice[i] = data[*offset] != 0\n")
		} else {
			goType := primitiveTypeMap[primitiveType]
			buf.WriteString(fmt.Sprintf("\t\t\tslice[i] = %s(data[*offset])\n", goType))
		}
		buf.WriteString(fmt.Sprintf("\t\t\t*offset += %d\n", size))

	case "u16", "i16":
		size := 2
		buf.WriteString(fmt.Sprintf("\t\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t\t}\n")
		goType := primitiveTypeMap[primitiveType]
		buf.WriteString(fmt.Sprintf("\t\t\tslice[i] = %s(binary.LittleEndian.Uint16(data[*offset:]))\n", goType))
		buf.WriteString(fmt.Sprintf("\t\t\t*offset += %d\n", size))

	case "u32", "i32", "f32":
		size := 4
		buf.WriteString(fmt.Sprintf("\t\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t\t}\n")
		if primitiveType == "f32" {
			buf.WriteString("\t\t\tslice[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[*offset:]))\n")
		} else {
			goType := primitiveTypeMap[primitiveType]
			buf.WriteString(fmt.Sprintf("\t\t\tslice[i] = %s(binary.LittleEndian.Uint32(data[*offset:]))\n", goType))
		}
		buf.WriteString(fmt.Sprintf("\t\t\t*offset += %d\n", size))

	case "u64", "i64", "f64":
		size := 8
		buf.WriteString(fmt.Sprintf("\t\t\tif *offset + %d > len(data) {\n", size))
		buf.WriteString("\t\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t\t}\n")
		if primitiveType == "f64" {
			buf.WriteString("\t\t\tslice[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[*offset:]))\n")
		} else {
			goType := primitiveTypeMap[primitiveType]
			buf.WriteString(fmt.Sprintf("\t\t\tslice[i] = %s(binary.LittleEndian.Uint64(data[*offset:]))\n", goType))
		}
		buf.WriteString(fmt.Sprintf("\t\t\t*offset += %d\n", size))

	case "str":
		buf.WriteString("\t\t\tif *offset + 4 > len(data) {\n")
		buf.WriteString("\t\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t\t}\n")
		buf.WriteString("\t\t\tstrLen := binary.LittleEndian.Uint32(data[*offset:])\n")
		buf.WriteString("\t\t\t*offset += 4\n\n")

		buf.WriteString("\t\t\tif *offset + int(strLen) > len(data) {\n")
		buf.WriteString("\t\t\t\treturn ErrUnexpectedEOF\n")
		buf.WriteString("\t\t\t}\n")
		buf.WriteString("\t\t\tslice[i] = string(data[*offset : *offset + int(strLen)])\n")
		buf.WriteString("\t\t\t*offset += int(strLen)\n")

	default:
		return fmt.Errorf("unsupported primitive type: %s", primitiveType)
	}

	return nil
}

func generateArrayNamedTypeElementDecodeForOptional(buf *strings.Builder, typeName string) error {
	goTypeName := ToGoName(typeName)
	helperName := "decode" + goTypeName

	buf.WriteString("\t\t\terr = ")
	buf.WriteString(helperName)
	buf.WriteString("(&slice[i], data, offset, ctx)\n")
	buf.WriteString("\t\t\tif err != nil {\n")
	buf.WriteString("\t\t\t\treturn err\n")
	buf.WriteString("\t\t\t}\n")

	return nil
}
