package cpp

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateDecodeHeader generates decode.hpp
func GenerateDecodeHeader(schema *parser.Schema, packageName string) string {
	var b strings.Builder

	guard := strings.ToUpper(toSnakeCase(packageName)) + "_DECODE_HPP"

	b.WriteString(fmt.Sprintf(`/* decode.hpp - Decoding functions for %s
 * Generated by sdp-gen - DO NOT EDIT
 */

#ifndef %s
#define %s

#include "types.hpp"
#include <cstdint>
#include <cstddef>
#include <stdexcept>

namespace sdp {

/* Decode error exception */
class DecodeError : public std::runtime_error {
public:
    explicit DecodeError(const char* msg) : std::runtime_error(msg) {}
};

`, packageName, guard, guard))

	// Generate function declarations
	for _, structDef := range schema.Structs {
		funcName := toSnakeCase(structDef.Name) + "_decode"
		structName := toPascalCase(structDef.Name)

		b.WriteString(fmt.Sprintf("/* Decode %s from buffer\n", structDef.Name))
		b.WriteString(" * Throws DecodeError on failure\n")
		b.WriteString(" */\n")
		b.WriteString(fmt.Sprintf("%s %s(const uint8_t* buf, size_t buf_len);\n\n", structName, funcName))
	}

	b.WriteString(fmt.Sprintf("}  // namespace sdp\n\n#endif  // %s\n", guard))

	return b.String()
}

// GenerateDecodeImpl generates decode.cpp
func GenerateDecodeImpl(schema *parser.Schema, packageName string) string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf(`/* decode.cpp - Decoding implementations for %s
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "decode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

`, packageName))

	// Check if schema has any arrays
	hasArrays := false
	for _, structDef := range schema.Structs {
		for _, field := range structDef.Fields {
			if field.Type.Kind == parser.TypeKindArray {
				hasArrays = true
				break
			}
		}
		if hasArrays {
			break
		}
	}

	// Only generate array limits if schema has arrays
	if hasArrays {
		b.WriteString("/* Array size limits */\n")
		b.WriteString("constexpr uint32_t MAX_ARRAY_ELEMENTS = 1000000;\n")
		b.WriteString("constexpr uint32_t MAX_TOTAL_ELEMENTS = 10000000;\n\n")
	}

	// Forward declarations for helper functions
	b.WriteString("/* Forward declarations for internal decode helpers */\n")
	for _, structDef := range schema.Structs {
		helperName := toSnakeCase(structDef.Name) + "_decode_impl"
		structName := toPascalCase(structDef.Name)
		b.WriteString(fmt.Sprintf("static %s %s(const uint8_t* buf, size_t buf_len, size_t& offset);\n", structName, helperName))
	}
	b.WriteString("\n")

	// Generate implementations (topologically sorted like types)
	ordered := topologicalSort(schema.Structs)
	for _, structDef := range ordered {
		b.WriteString(generateDecodeFunction(structDef))
		b.WriteString("\n")
	}

	b.WriteString("}  // namespace sdp\n")

	return b.String()
}

func generateDecodeFunction(structDef parser.Struct) string {
	var b strings.Builder

	funcName := toSnakeCase(structDef.Name) + "_decode"
	helperName := toSnakeCase(structDef.Name) + "_decode_impl"
	structName := toPascalCase(structDef.Name)

	// Check if struct has arrays for total_elements tracking
	hasArrays := false
	for _, field := range structDef.Fields {
		if field.Type.Kind == parser.TypeKindArray {
			hasArrays = true
			break
		}
	}

	// Generate helper function that tracks offset via parameter
	b.WriteString(fmt.Sprintf("static %s %s(const uint8_t* buf, size_t buf_len, size_t& offset) {\n", structName, helperName))
	b.WriteString(fmt.Sprintf("    %s result;\n", structName))
	if hasArrays {
		b.WriteString("    uint32_t total_elements = 0;\n")
	}
	b.WriteString("\n")

	// Decode each field
	for _, field := range structDef.Fields {
		b.WriteString(generateFieldDecode(field))
	}

	b.WriteString("    return result;\n")
	b.WriteString("}\n\n")

	// Generate public function that initializes offset
	b.WriteString(fmt.Sprintf("%s %s(const uint8_t* buf, size_t buf_len) {\n", structName, funcName))
	b.WriteString("    size_t offset = 0;\n")
	b.WriteString(fmt.Sprintf("    return %s(buf, buf_len, offset);\n", helperName))
	b.WriteString("}\n")

	return b.String()
}

func generateFieldDecode(field parser.Field) string {
	var b strings.Builder

	fieldName := "result." + toSnakeCase(field.Name)

	b.WriteString(fmt.Sprintf("    /* %s */\n", field.Name))

	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		if field.Type.Name == "str" {
			b.WriteString(generateStringDecode(field, fieldName))
		} else {
			b.WriteString(generatePrimitiveDecode(field, fieldName))
		}

	case parser.TypeKindArray:
		b.WriteString(generateArrayDecode(field, fieldName))

	case parser.TypeKindNamed:
		// Nested struct - use helper that tracks offset
		nestedHelper := toSnakeCase(field.Type.Name) + "_decode_impl"
		if field.Type.Optional {
			presentVar := toSnakeCase(field.Name) + "_present"
			b.WriteString("    if (offset >= buf_len) throw DecodeError(\"Buffer too small\");\n")
			b.WriteString(fmt.Sprintf("    uint8_t %s = buf[offset++];\n", presentVar))
			b.WriteString(fmt.Sprintf("    if (%s) {\n", presentVar))
			b.WriteString(fmt.Sprintf("        %s = %s(buf, buf_len, offset);\n", fieldName, nestedHelper))
			b.WriteString("    }\n")
		} else {
			b.WriteString(fmt.Sprintf("    %s = %s(buf, buf_len, offset);\n", fieldName, nestedHelper))
		}
	}

	b.WriteString("\n")

	return b.String()
}

func generateStringDecode(field parser.Field, fieldName string) string {
	var b strings.Builder

	if field.Type.Optional {
		presentVar := toSnakeCase(field.Name) + "_present"
		b.WriteString("    if (offset >= buf_len) throw DecodeError(\"Buffer too small\");\n")
		b.WriteString(fmt.Sprintf("    uint8_t %s = buf[offset++];\n", presentVar))
		b.WriteString(fmt.Sprintf("    if (%s) {\n", presentVar))
		b.WriteString("        if (offset + 4 > buf_len) throw DecodeError(\"Buffer too small\");\n")
		b.WriteString("        uint32_t len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));\n")
		b.WriteString("        offset += 4;\n")
		b.WriteString("        if (offset + len > buf_len) throw DecodeError(\"Buffer too small\");\n")
		b.WriteString(fmt.Sprintf("        %s = std::string(reinterpret_cast<const char*>(buf + offset), len);\n", fieldName))
		b.WriteString("        offset += len;\n")
		b.WriteString("    }\n")
	} else {
		b.WriteString("    if (offset + 4 > buf_len) throw DecodeError(\"Buffer too small\");\n")
		b.WriteString(fmt.Sprintf("    uint32_t %s_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));\n", toSnakeCase(field.Name)))
		b.WriteString("    offset += 4;\n")
		b.WriteString(fmt.Sprintf("    if (offset + %s_len > buf_len) throw DecodeError(\"Buffer too small\");\n", toSnakeCase(field.Name)))
		b.WriteString(fmt.Sprintf("    %s = std::string(reinterpret_cast<const char*>(buf + offset), %s_len);\n", fieldName, toSnakeCase(field.Name)))
		b.WriteString(fmt.Sprintf("    offset += %s_len;\n", toSnakeCase(field.Name)))
	}

	return b.String()
}

func generatePrimitiveDecode(field parser.Field, fieldName string) string {
	var b strings.Builder

	primitiveSize := getPrimitiveSize(field.Type.Name)

	if field.Type.Optional {
		presentVar := toSnakeCase(field.Name) + "_present"
		b.WriteString("    if (offset >= buf_len) throw DecodeError(\"Buffer too small\");\n")
		b.WriteString(fmt.Sprintf("    uint8_t %s = buf[offset++];\n", presentVar))
		b.WriteString(fmt.Sprintf("    if (%s) {\n", presentVar))
		b.WriteString(fmt.Sprintf("        if (offset + %d > buf_len) throw DecodeError(\"Buffer too small\");\n", primitiveSize))
		b.WriteString(generatePrimitiveDecodeInline(field.Type.Name, fieldName, "        "))
		b.WriteString("    }\n")
	} else {
		b.WriteString(fmt.Sprintf("    if (offset + %d > buf_len) throw DecodeError(\"Buffer too small\");\n", primitiveSize))
		b.WriteString(generatePrimitiveDecodeInline(field.Type.Name, fieldName, "    "))
	}

	return b.String()
}

func generatePrimitiveDecodeInline(typeName string, fieldName string, indent string) string {
	primitiveSize := getPrimitiveSize(typeName)

	switch typeName {
	case "u8":
		return fmt.Sprintf("%s%s = buf[offset++];\n", indent, fieldName)
	case "i8":
		return fmt.Sprintf("%s%s = (int8_t)buf[offset++];\n", indent, fieldName)
	case "bool":
		return fmt.Sprintf("%s%s = buf[offset++] != 0;\n", indent, fieldName)
	case "u16":
		return fmt.Sprintf("%s%s = SDP_LE16TOH(*(const uint16_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	case "u32":
		return fmt.Sprintf("%s%s = SDP_LE32TOH(*(const uint32_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	case "u64":
		return fmt.Sprintf("%s%s = SDP_LE64TOH(*(const uint64_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	case "i16":
		return fmt.Sprintf("%s%s = (int16_t)SDP_LE16TOH(*(const uint16_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	case "i32":
		return fmt.Sprintf("%s%s = (int32_t)SDP_LE32TOH(*(const uint32_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	case "i64":
		return fmt.Sprintf("%s%s = (int64_t)SDP_LE64TOH(*(const uint64_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	case "f32":
		return fmt.Sprintf("%s%s = sdp_le_to_f32(*(const uint32_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	case "f64":
		return fmt.Sprintf("%s%s = sdp_le_to_f64(*(const uint64_t*)(buf + offset));\n%soffset += %d;\n", indent, fieldName, indent, primitiveSize)
	default:
		return ""
	}
}

func generateArrayDecode(field parser.Field, fieldName string) string {
	var b strings.Builder

	b.WriteString("    if (offset + 4 > buf_len) throw DecodeError(\"Buffer too small\");\n")
	b.WriteString(fmt.Sprintf("    uint32_t %s_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));\n", toSnakeCase(field.Name)))
	b.WriteString("    offset += 4;\n")
	b.WriteString(fmt.Sprintf("    if (%s_count > MAX_ARRAY_ELEMENTS) throw DecodeError(\"Array too large\");\n", toSnakeCase(field.Name)))
	b.WriteString(fmt.Sprintf("    total_elements += %s_count;\n", toSnakeCase(field.Name)))
	b.WriteString("    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError(\"Total elements too large\");\n")
	b.WriteString(fmt.Sprintf("    %s.reserve(%s_count);\n", fieldName, toSnakeCase(field.Name)))

	if field.Type.Elem.Name == "str" {
		// String array
		b.WriteString(fmt.Sprintf("    for (uint32_t i = 0; i < %s_count; i++) {\n", toSnakeCase(field.Name)))
		b.WriteString("        if (offset + 4 > buf_len) throw DecodeError(\"Buffer too small\");\n")
		b.WriteString("        uint32_t len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));\n")
		b.WriteString("        offset += 4;\n")
		b.WriteString("        if (offset + len > buf_len) throw DecodeError(\"Buffer too small\");\n")
		b.WriteString(fmt.Sprintf("        %s.emplace_back(reinterpret_cast<const char*>(buf + offset), len);\n", fieldName))
		b.WriteString("        offset += len;\n")
		b.WriteString("    }\n")
	} else if field.Type.Elem.Kind == parser.TypeKindNamed {
		// Struct array - use helper that tracks offset
		nestedHelper := toSnakeCase(field.Type.Elem.Name) + "_decode_impl"
		b.WriteString(fmt.Sprintf("    for (uint32_t i = 0; i < %s_count; i++) {\n", toSnakeCase(field.Name)))
		b.WriteString(fmt.Sprintf("        %s.push_back(%s(buf, buf_len, offset));\n", fieldName, nestedHelper))
		b.WriteString("    }\n")
	} else {
		// Primitive array
		elemSize := getPrimitiveSize(field.Type.Elem.Name)
		if elemSize == 1 && field.Type.Elem.Name != "bool" {
			// Fast path: single-byte types (but not bool)
			b.WriteString(fmt.Sprintf("    if (offset + %s_count > buf_len) throw DecodeError(\"Buffer too small\");\n", toSnakeCase(field.Name)))
			b.WriteString(fmt.Sprintf("    %s.assign(buf + offset, buf + offset + %s_count);\n", fieldName, toSnakeCase(field.Name)))
			b.WriteString(fmt.Sprintf("    offset += %s_count;\n", toSnakeCase(field.Name)))
		} else {
			// Element-by-element (for endianness or bool)
			b.WriteString(fmt.Sprintf("    if (offset + %s_count * %d > buf_len) throw DecodeError(\"Buffer too small\");\n", toSnakeCase(field.Name), elemSize))
			b.WriteString(fmt.Sprintf("    for (uint32_t i = 0; i < %s_count; i++) {\n", toSnakeCase(field.Name)))
			elemType := getCppType(field.Type.Elem.Name)
			b.WriteString(fmt.Sprintf("        %s elem;\n", elemType))
			b.WriteString(generatePrimitiveDecodeInline(field.Type.Elem.Name, "elem", "        "))
			b.WriteString(fmt.Sprintf("        %s.push_back(elem);\n", fieldName))
			b.WriteString("    }\n")
		}
	}

	return b.String()
}
