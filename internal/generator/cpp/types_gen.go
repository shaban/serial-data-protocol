package cpp

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateTypes generates the types.hpp file with C++ struct definitions
func GenerateTypes(schema *parser.Schema, packageName string) string {
	var b strings.Builder

	// Header guard
	guard := strings.ToUpper(toSnakeCase(packageName)) + "_TYPES_HPP"

	b.WriteString(fmt.Sprintf(`/* types.hpp - Type definitions for %s
 * Generated by sdp-gen - DO NOT EDIT
 * 
 * C++17 type definitions using:
 * - std::string for strings (null-terminated, length tracked)
 * - std::vector<T> for arrays (size tracked automatically)
 * - std::optional<T> for optional fields (type-safe)
 * 
 * Zero runtime dependencies, RAII memory management.
 */

#ifndef %s
#define %s

#include <cstdint>
#include <string>
#include <vector>
#include <optional>

namespace sdp {

`, packageName, guard, guard))

	// Generate struct definitions in dependency order
	// (structs must be defined before they're used in std::optional<T>)
	ordered := topologicalSort(schema.Structs)
	for _, structDef := range ordered {
		b.WriteString(generateStruct(structDef))
		b.WriteString("\n")
	}

	b.WriteString(fmt.Sprintf("}  // namespace sdp\n\n#endif  // %s\n", guard))

	return b.String()
}

func generateStruct(structDef parser.Struct) string {
	var b strings.Builder

	structName := toPascalCase(structDef.Name)

	b.WriteString(fmt.Sprintf("/* %s */\n", structDef.Name))
	b.WriteString(fmt.Sprintf("struct %s {\n", structName))

	// Generate fields
	for _, field := range structDef.Fields {
		b.WriteString(generateField(field))
	}

	b.WriteString("};\n")

	return b.String()
}

func generateField(field parser.Field) string {
	var b strings.Builder

	fieldName := toSnakeCase(field.Name)

	// Comment
	b.WriteString(fmt.Sprintf("    // %s", field.Name))
	if field.Type.Optional {
		b.WriteString(" (optional)")
	}
	b.WriteString("\n")

	// Field type
	b.WriteString("    ")

	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		if field.Type.Name == "str" {
			// String
			if field.Type.Optional {
				b.WriteString(fmt.Sprintf("std::optional<std::string> %s;", fieldName))
			} else {
				b.WriteString(fmt.Sprintf("std::string %s;", fieldName))
			}
		} else {
			// Primitive
			cppType := getCppType(field.Type.Name)
			if field.Type.Optional {
				b.WriteString(fmt.Sprintf("std::optional<%s> %s;", cppType, fieldName))
			} else {
				b.WriteString(fmt.Sprintf("%s %s;", cppType, fieldName))
			}
		}

	case parser.TypeKindArray:
		// Array
		elemType := getArrayElementType(field.Type.Elem)
		b.WriteString(fmt.Sprintf("std::vector<%s> %s;", elemType, fieldName))

	case parser.TypeKindNamed:
		// Nested struct
		nestedType := toPascalCase(field.Type.Name)
		if field.Type.Optional {
			b.WriteString(fmt.Sprintf("std::optional<%s> %s;", nestedType, fieldName))
		} else {
			b.WriteString(fmt.Sprintf("%s %s;", nestedType, fieldName))
		}
	}

	b.WriteString("\n")

	return b.String()
}

func getArrayElementType(elemType *parser.TypeExpr) string {
	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		if elemType.Name == "str" {
			return "std::string"
		}
		return getCppType(elemType.Name)
	case parser.TypeKindNamed:
		return toPascalCase(elemType.Name)
	default:
		return "unknown"
	}
}

// topologicalSort orders structs so dependencies are defined before they're used
// This is required for std::optional<T> which needs complete type definitions
func topologicalSort(structs []parser.Struct) []parser.Struct {
	// Build map of structs by name
	structMap := make(map[string]parser.Struct)
	for _, s := range structs {
		structMap[s.Name] = s
	}

	// Build dependency map: for each struct, list what it depends on
	deps := make(map[string][]string)
	for _, s := range structs {
		name := s.Name
		deps[name] = []string{}
		for _, field := range s.Fields {
			if field.Type.Kind == parser.TypeKindNamed {
				deps[name] = append(deps[name], field.Type.Name)
			}
			if field.Type.Kind == parser.TypeKindArray && field.Type.Elem != nil && field.Type.Elem.Kind == parser.TypeKindNamed {
				deps[name] = append(deps[name], field.Type.Elem.Name)
			}
		}
	}

	// Calculate in-degree: number of dependencies each struct has
	inDegree := make(map[string]int)
	for _, s := range structs {
		inDegree[s.Name] = len(deps[s.Name])
	}

	// Kahn's algorithm: start with structs that have no dependencies
	var queue []string
	for _, s := range structs {
		if inDegree[s.Name] == 0 {
			queue = append(queue, s.Name)
		}
	}

	// Process queue
	var result []parser.Struct
	visited := make(map[string]bool)

	for len(queue) > 0 {
		name := queue[0]
		queue = queue[1:]

		if visited[name] {
			continue
		}
		visited[name] = true

		result = append(result, structMap[name])

		// For each struct, check if all its dependencies are now satisfied
		for _, s := range structs {
			if visited[s.Name] {
				continue
			}
			// Check if all dependencies of s are satisfied
			allSatisfied := true
			for _, dep := range deps[s.Name] {
				if !visited[dep] {
					allSatisfied = false
					break
				}
			}
			if allSatisfied {
				queue = append(queue, s.Name)
			}
		}
	}

	// If cycle detected or incomplete, return original order
	if len(result) != len(structs) {
		return structs
	}

	return result
}
