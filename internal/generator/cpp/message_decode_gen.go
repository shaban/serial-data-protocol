package cpp

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateMessageDecodeHeader generates the message mode decode header file.
func GenerateMessageDecodeHeader(schema *parser.Schema, packageName string) string {
	var buf strings.Builder

	buf.WriteString("// Auto-generated by sdp-gen. DO NOT EDIT.\n")
	buf.WriteString("// Message mode decoders - self-describing messages with type headers.\n\n")
	buf.WriteString("#pragma once\n\n")
	buf.WriteString("#include \"types.hpp\"\n")
	buf.WriteString("#include \"decode.hpp\"\n")
	buf.WriteString("#include <cstdint>\n")
	buf.WriteString("#include <vector>\n")
	buf.WriteString("#include <variant>\n")
	buf.WriteString("#include <stdexcept>\n\n")

	buf.WriteString("namespace sdp {\n\n")

	// Error types
	buf.WriteString("// Message mode error types\n")
	buf.WriteString("class MessageDecodeError : public std::runtime_error {\n")
	buf.WriteString("public:\n")
	buf.WriteString("    explicit MessageDecodeError(const std::string& msg) : std::runtime_error(msg) {}\n")
	buf.WriteString("};\n\n")

	// Generate decoder declarations for each struct
	for i, s := range schema.Structs {
		typeID := uint16(i + 1)
		structName := toPascalCase(s.Name)

		buf.WriteString("// Decode")
		buf.WriteString(structName)
		buf.WriteString("Message decodes ")
		buf.WriteString(structName)
		buf.WriteString(" from self-describing message format.\n")
		buf.WriteString("// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]\n")
		buf.WriteString("// Expected Type ID: ")
		buf.WriteString(fmt.Sprintf("%d\n", typeID))
		buf.WriteString("// Throws MessageDecodeError if header is invalid.\n")
		buf.WriteString(structName)
		buf.WriteString(" Decode")
		buf.WriteString(structName)
		buf.WriteString("Message(const std::vector<uint8_t>& data);\n\n")
	}

	// Generate variant type for dispatcher
	buf.WriteString("// MessageVariant holds any decoded message type\n")
	buf.WriteString("using MessageVariant = std::variant<\n")
	for i, s := range schema.Structs {
		structName := toPascalCase(s.Name)
		buf.WriteString("    ")
		buf.WriteString(structName)
		if i < len(schema.Structs)-1 {
			buf.WriteString(",\n")
		} else {
			buf.WriteString("\n")
		}
	}
	buf.WriteString(">;\n\n")

	// Dispatcher declaration
	buf.WriteString("// DecodeMessage decodes a message and returns the struct type based on type ID.\n")
	buf.WriteString("// This is the main entry point for decoding self-describing messages.\n")
	buf.WriteString("// Throws MessageDecodeError if header is invalid or type ID is unknown.\n")
	buf.WriteString("MessageVariant DecodeMessage(const std::vector<uint8_t>& data);\n\n")

	buf.WriteString("} // namespace sdp\n")

	return buf.String()
}

// GenerateMessageDecodeImpl generates the message mode decode implementation file.
func GenerateMessageDecodeImpl(schema *parser.Schema, packageName string) string {
	var buf strings.Builder

	buf.WriteString("// Auto-generated by sdp-gen. DO NOT EDIT.\n")
	buf.WriteString("// Message mode decoders - implementation.\n\n")
	buf.WriteString("#include \"message_decode.hpp\"\n")
	buf.WriteString("#include \"message_encode.hpp\"\n")
	buf.WriteString("#include \"endian.hpp\"\n")
	buf.WriteString("#include <cstring>\n\n")

	buf.WriteString("namespace sdp {\n\n")

	// Generate decoder implementations for each struct
	for i, s := range schema.Structs {
		typeID := uint16(i + 1)
		structName := toPascalCase(s.Name)
		snakeName := toSnakeCase(s.Name)

		buf.WriteString(structName)
		buf.WriteString(" Decode")
		buf.WriteString(structName)
		buf.WriteString("Message(const std::vector<uint8_t>& data) {\n")

		// Check minimum size
		buf.WriteString("    // Check minimum message size\n")
		buf.WriteString("    if (data.size() < MESSAGE_HEADER_SIZE) {\n")
		buf.WriteString("        throw MessageDecodeError(\"Message too short: expected at least \" + \n")
		buf.WriteString("            std::to_string(MESSAGE_HEADER_SIZE) + \" bytes, got \" + std::to_string(data.size()));\n")
		buf.WriteString("    }\n\n")

		// Validate magic bytes
		buf.WriteString("    // Validate magic bytes\n")
		buf.WriteString("    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {\n")
		buf.WriteString("        throw MessageDecodeError(\"Invalid magic bytes: expected 'SDP'\");\n")
		buf.WriteString("    }\n\n")

		// Validate version
		buf.WriteString("    // Validate protocol version\n")
		buf.WriteString("    if (data[3] != MESSAGE_VERSION) {\n")
		buf.WriteString("        throw MessageDecodeError(\"Invalid version: expected \" + \n")
		buf.WriteString("            std::to_string(MESSAGE_VERSION) + \", got \" + std::to_string(data[3]));\n")
		buf.WriteString("    }\n\n")

		// Validate type ID
		buf.WriteString("    // Validate type ID\n")
		buf.WriteString("    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));\n")
		buf.WriteString(fmt.Sprintf("    if (typeID != %d) {\n", typeID))
		buf.WriteString(fmt.Sprintf("        throw MessageDecodeError(\"Wrong type ID: expected %d (", typeID))
		buf.WriteString(structName)
		buf.WriteString("), got \" + std::to_string(typeID));\n")
		buf.WriteString("    }\n\n")

		// Extract payload length
		buf.WriteString("    // Extract payload length\n")
		buf.WriteString("    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));\n\n")

		// Validate total message size
		buf.WriteString("    // Validate total message size\n")
		buf.WriteString("    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;\n")
		buf.WriteString("    if (data.size() < expectedSize) {\n")
		buf.WriteString("        throw MessageDecodeError(\"Message too short: expected \" + \n")
		buf.WriteString("            std::to_string(expectedSize) + \" bytes, got \" + std::to_string(data.size()));\n")
		buf.WriteString("    }\n\n")

		// Decode payload
		buf.WriteString("    // Decode payload\n")
		buf.WriteString("    return ")
		buf.WriteString(snakeName)
		buf.WriteString("_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);\n")
		buf.WriteString("}\n\n")
	}

	// Generate dispatcher implementation
	buf.WriteString("MessageVariant DecodeMessage(const std::vector<uint8_t>& data) {\n")

	// Check minimum size
	buf.WriteString("    // Check minimum message size\n")
	buf.WriteString("    if (data.size() < MESSAGE_HEADER_SIZE) {\n")
	buf.WriteString("        throw MessageDecodeError(\"Message too short: expected at least \" + \n")
	buf.WriteString("            std::to_string(MESSAGE_HEADER_SIZE) + \" bytes, got \" + std::to_string(data.size()));\n")
	buf.WriteString("    }\n\n")

	// Validate magic bytes
	buf.WriteString("    // Validate magic bytes\n")
	buf.WriteString("    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {\n")
	buf.WriteString("        throw MessageDecodeError(\"Invalid magic bytes: expected 'SDP'\");\n")
	buf.WriteString("    }\n\n")

	// Validate version
	buf.WriteString("    // Validate protocol version\n")
	buf.WriteString("    if (data[3] != MESSAGE_VERSION) {\n")
	buf.WriteString("        throw MessageDecodeError(\"Invalid version: expected \" + \n")
	buf.WriteString("            std::to_string(MESSAGE_VERSION) + \", got \" + std::to_string(data[3]));\n")
	buf.WriteString("    }\n\n")

	// Extract type ID
	buf.WriteString("    // Extract type ID\n")
	buf.WriteString("    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));\n\n")

	// Switch on type ID
	buf.WriteString("    // Dispatch to specific decoder\n")
	buf.WriteString("    switch (typeID) {\n")

	for i, s := range schema.Structs {
		typeID := i + 1
		structName := toPascalCase(s.Name)

		buf.WriteString(fmt.Sprintf("    case %d:\n", typeID))
		buf.WriteString("        return Decode")
		buf.WriteString(structName)
		buf.WriteString("Message(data);\n")
	}

	// Default case for unknown type ID
	buf.WriteString("    default:\n")
	buf.WriteString("        throw MessageDecodeError(\"Unknown type ID: \" + std::to_string(typeID));\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	buf.WriteString("} // namespace sdp\n")

	return buf.String()
}
