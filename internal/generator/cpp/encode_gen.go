package cpp

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateEncodeHeader generates encode.hpp
func GenerateEncodeHeader(schema *parser.Schema, packageName string) string {
	var b strings.Builder

	guard := strings.ToUpper(toSnakeCase(packageName)) + "_ENCODE_HPP"

	b.WriteString(fmt.Sprintf(`/* encode.hpp - Encoding functions for %s
 * Generated by sdp-gen - DO NOT EDIT
 */

#ifndef %s
#define %s

#include "types.hpp"
#include <cstdint>
#include <cstddef>

namespace sdp {

`, packageName, guard, guard))

	// Generate function declarations
	for _, structDef := range schema.Structs {
		funcName := toSnakeCase(structDef.Name) + "_encode"
		structName := toPascalCase(structDef.Name)

		// Size calculation
		b.WriteString(fmt.Sprintf("/* Calculate encoded size of %s */\n", structDef.Name))
		b.WriteString(fmt.Sprintf("size_t %s_size(const %s& msg);\n\n", toSnakeCase(structDef.Name), structName))

		// Encoding
		b.WriteString(fmt.Sprintf("/* Encode %s to buffer\n", structDef.Name))
		b.WriteString(" * Returns: Number of bytes written\n")
		b.WriteString(fmt.Sprintf(" * Note: Buffer must be at least %s_size() bytes\n", toSnakeCase(structDef.Name)))
		b.WriteString(" */\n")
		b.WriteString(fmt.Sprintf("size_t %s(const %s& msg, uint8_t* buf);\n\n", funcName, structName))
	}

	b.WriteString(fmt.Sprintf("}  // namespace sdp\n\n#endif  // %s\n", guard))

	return b.String()
}

// Package-level schema for inline encoding generation
var currentSchema *parser.Schema

// GenerateEncodeImpl generates encode.cpp
func GenerateEncodeImpl(schema *parser.Schema, packageName string) string {
	// Store schema for use in inline encoding
	currentSchema = schema

	var b strings.Builder

	b.WriteString(fmt.Sprintf(`/* encode.cpp - Encoding implementations for %s
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "encode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

`, packageName))

	// Generate implementations
	for _, structDef := range schema.Structs {
		b.WriteString(generateSizeFunction(structDef))
		b.WriteString("\n")
		b.WriteString(generateEncodeFunction(structDef))
		b.WriteString("\n")
	}

	b.WriteString("}  // namespace sdp\n")

	return b.String()
}

func generateSizeFunction(structDef parser.Struct) string {
	var b strings.Builder

	funcName := toSnakeCase(structDef.Name) + "_size"
	structName := toPascalCase(structDef.Name)

	// Check if struct has only fixed-size fields (no arrays, strings, or nested structs)
	hasVariableSize := false
	for _, field := range structDef.Fields {
		if field.Type.Kind == parser.TypeKindArray || field.Type.Name == "str" || field.Type.Kind == parser.TypeKindNamed {
			hasVariableSize = true
			break
		}
	}

	b.WriteString(fmt.Sprintf("size_t %s(const %s& msg) {\n", funcName, structName))

	// If struct only has fixed-size primitives, suppress unused parameter warning
	if !hasVariableSize {
		b.WriteString("    (void)msg;  // Fixed-size struct, parameter unused\n")
	}

	b.WriteString("    size_t size = 0;\n")

	for _, field := range structDef.Fields {
		b.WriteString(generateFieldSize(field))
	}

	b.WriteString("    return size;\n")
	b.WriteString("}\n")

	return b.String()
}

func generateFieldSize(field parser.Field) string {
	var b strings.Builder

	fieldName := "msg." + toSnakeCase(field.Name)

	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		if field.Type.Name == "str" {
			// String: 4 bytes length + data
			if field.Type.Optional {
				b.WriteString(fmt.Sprintf("    size += 1;  // %s presence\n", field.Name))
				b.WriteString(fmt.Sprintf("    if (%s.has_value()) {\n", fieldName))
				b.WriteString(fmt.Sprintf("        size += 4 + %s->size();\n", fieldName))
				b.WriteString("    }\n")
			} else {
				b.WriteString(fmt.Sprintf("    size += 4 + %s.size();  // %s\n", fieldName, field.Name))
			}
		} else {
			// Primitive: fixed size
			primitiveSize := getPrimitiveSize(field.Type.Name)
			if field.Type.Optional {
				b.WriteString(fmt.Sprintf("    size += 1;  // %s presence\n", field.Name))
				b.WriteString(fmt.Sprintf("    if (%s.has_value()) {\n", fieldName))
				b.WriteString(fmt.Sprintf("        size += %d;\n", primitiveSize))
				b.WriteString("    }\n")
			} else {
				b.WriteString(fmt.Sprintf("    size += %d;  // %s\n", primitiveSize, field.Name))
			}
		}

	case parser.TypeKindArray:
		b.WriteString(fmt.Sprintf("    size += 4;  // %s count\n", field.Name))
		if field.Type.Elem.Name == "str" {
			// String array
			b.WriteString(fmt.Sprintf("    for (const auto& elem : %s) {\n", fieldName))
			b.WriteString("        size += 4 + elem.size();\n")
			b.WriteString("    }\n")
		} else if field.Type.Elem.Kind == parser.TypeKindNamed {
			// Struct array
			elemFunc := toSnakeCase(field.Type.Elem.Name) + "_size"
			b.WriteString(fmt.Sprintf("    for (const auto& elem : %s) {\n", fieldName))
			b.WriteString(fmt.Sprintf("        size += %s(elem);\n", elemFunc))
			b.WriteString("    }\n")
		} else {
			// Primitive array
			elemSize := getPrimitiveSize(field.Type.Elem.Name)
			b.WriteString(fmt.Sprintf("    size += %s.size() * %d;\n", fieldName, elemSize))
		}

	case parser.TypeKindNamed:
		// Nested struct
		nestedFunc := toSnakeCase(field.Type.Name) + "_size"
		if field.Type.Optional {
			b.WriteString(fmt.Sprintf("    size += 1;  // %s presence\n", field.Name))
			b.WriteString(fmt.Sprintf("    if (%s.has_value()) {\n", fieldName))
			b.WriteString(fmt.Sprintf("        size += %s(*%s);\n", nestedFunc, fieldName))
			b.WriteString("    }\n")
		} else {
			b.WriteString(fmt.Sprintf("    size += %s(%s);  // %s\n", nestedFunc, fieldName, field.Name))
		}
	}

	return b.String()
}

func generateEncodeFunction(structDef parser.Struct) string {
	var b strings.Builder

	funcName := toSnakeCase(structDef.Name) + "_encode"
	structName := toPascalCase(structDef.Name)

	b.WriteString(fmt.Sprintf("size_t %s(const %s& msg, uint8_t* buf) {\n", funcName, structName))
	b.WriteString("    size_t offset = 0;\n\n")

	for _, field := range structDef.Fields {
		b.WriteString(generateFieldEncode(field))
	}

	b.WriteString("    return offset;\n")
	b.WriteString("}\n")

	return b.String()
}

func generateFieldEncode(field parser.Field) string {
	var b strings.Builder

	fieldName := "msg." + toSnakeCase(field.Name)

	b.WriteString(fmt.Sprintf("    /* %s */\n", field.Name))

	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		if field.Type.Name == "str" {
			// String
			if field.Type.Optional {
				b.WriteString(fmt.Sprintf("    buf[offset++] = %s.has_value() ? 1 : 0;\n", fieldName))
				b.WriteString(fmt.Sprintf("    if (%s.has_value()) {\n", fieldName))
				b.WriteString(fmt.Sprintf("        uint32_t len = %s->size();\n", fieldName))
				b.WriteString("        *(uint32_t*)(buf + offset) = SDP_HTOLE32(len);\n")
				b.WriteString("        offset += 4;\n")
				b.WriteString(fmt.Sprintf("        std::memcpy(buf + offset, %s->data(), len);\n", fieldName))
				b.WriteString("        offset += len;\n")
				b.WriteString("    }\n")
			} else {
				b.WriteString(fmt.Sprintf("    uint32_t %s_len = %s.size();\n", toSnakeCase(field.Name), fieldName))
				b.WriteString(fmt.Sprintf("    *(uint32_t*)(buf + offset) = SDP_HTOLE32(%s_len);\n", toSnakeCase(field.Name)))
				b.WriteString("    offset += 4;\n")
				b.WriteString(fmt.Sprintf("    std::memcpy(buf + offset, %s.data(), %s_len);\n", fieldName, toSnakeCase(field.Name)))
				b.WriteString(fmt.Sprintf("    offset += %s_len;\n", toSnakeCase(field.Name)))
			}
		} else {
			// Primitive
			b.WriteString(generatePrimitiveEncode(field, fieldName))
		}

	case parser.TypeKindArray:
		b.WriteString(generateArrayEncode(field, fieldName))

	case parser.TypeKindNamed:
		// Nested struct
		nestedFunc := toSnakeCase(field.Type.Name) + "_encode"
		if field.Type.Optional {
			b.WriteString(fmt.Sprintf("    buf[offset++] = %s.has_value() ? 1 : 0;\n", fieldName))
			b.WriteString(fmt.Sprintf("    if (%s.has_value()) {\n", fieldName))
			b.WriteString(fmt.Sprintf("        offset += %s(*%s, buf + offset);\n", nestedFunc, fieldName))
			b.WriteString("    }\n")
		} else {
			b.WriteString(fmt.Sprintf("    offset += %s(%s, buf + offset);\n", nestedFunc, fieldName))
		}
	}

	b.WriteString("\n")

	return b.String()
}

func generatePrimitiveEncode(field parser.Field, fieldName string) string {
	var b strings.Builder

	primitiveSize := getPrimitiveSize(field.Type.Name)

	if field.Type.Optional {
		b.WriteString(fmt.Sprintf("    buf[offset++] = %s.has_value() ? 1 : 0;\n", fieldName))
		b.WriteString(fmt.Sprintf("    if (%s.has_value()) {\n", fieldName))
		fieldName = "*" + fieldName
	}

	switch field.Type.Name {
	case "u8", "i8", "bool":
		b.WriteString(fmt.Sprintf("        buf[offset++] = %s;\n", fieldName))
	case "u16":
		b.WriteString(fmt.Sprintf("        *(uint16_t*)(buf + offset) = SDP_HTOLE16(%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	case "u32":
		b.WriteString(fmt.Sprintf("        *(uint32_t*)(buf + offset) = SDP_HTOLE32(%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	case "u64":
		b.WriteString(fmt.Sprintf("        *(uint64_t*)(buf + offset) = SDP_HTOLE64(%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	case "i16":
		b.WriteString(fmt.Sprintf("        *(int16_t*)(buf + offset) = (int16_t)SDP_HTOLE16((uint16_t)%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	case "i32":
		b.WriteString(fmt.Sprintf("        *(int32_t*)(buf + offset) = (int32_t)SDP_HTOLE32((uint32_t)%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	case "i64":
		b.WriteString(fmt.Sprintf("        *(int64_t*)(buf + offset) = (int64_t)SDP_HTOLE64((uint64_t)%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	case "f32":
		b.WriteString(fmt.Sprintf("        *(uint32_t*)(buf + offset) = sdp_f32_to_le(%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	case "f64":
		b.WriteString(fmt.Sprintf("        *(uint64_t*)(buf + offset) = sdp_f64_to_le(%s);\n", fieldName))
		b.WriteString(fmt.Sprintf("        offset += %d;\n", primitiveSize))
	}

	if field.Type.Optional {
		b.WriteString("    }\n")
	}

	return b.String()
}

func generateArrayEncode(field parser.Field, fieldName string) string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("    uint32_t %s_count = %s.size();\n", toSnakeCase(field.Name), fieldName))
	b.WriteString(fmt.Sprintf("    *(uint32_t*)(buf + offset) = SDP_HTOLE32(%s_count);\n", toSnakeCase(field.Name)))
	b.WriteString("    offset += 4;\n")

	if field.Type.Elem.Name == "str" {
		// String array
		b.WriteString(fmt.Sprintf("    for (const auto& elem : %s) {\n", fieldName))
		b.WriteString("        uint32_t len = elem.size();\n")
		b.WriteString("        *(uint32_t*)(buf + offset) = SDP_HTOLE32(len);\n")
		b.WriteString("        offset += 4;\n")
		b.WriteString("        std::memcpy(buf + offset, elem.data(), len);\n")
		b.WriteString("        offset += len;\n")
		b.WriteString("    }\n")
	} else if field.Type.Elem.Kind == parser.TypeKindNamed {
		// Struct array - TRUE inline encoding (no function calls for performance)
		b.WriteString(fmt.Sprintf("    for (const auto& elem : %s) {\n", fieldName))
		b.WriteString(generateInlineStructEncode(*field.Type.Elem))
		b.WriteString("    }\n")
	} else {
		// Primitive array - bulk copy
		elemSize := getPrimitiveSize(field.Type.Elem.Name)
		if elemSize == 1 && field.Type.Elem.Name != "bool" {
			// Fast path: single-byte types (but not bool, which is special)
			b.WriteString(fmt.Sprintf("    std::memcpy(buf + offset, %s.data(), %s_count);\n", fieldName, toSnakeCase(field.Name)))
			b.WriteString(fmt.Sprintf("    offset += %s_count;\n", toSnakeCase(field.Name)))
		} else {
			// Need element-by-element (either for endianness or bool)
			b.WriteString(fmt.Sprintf("    for (const auto& elem : %s) {\n", fieldName))
			b.WriteString(generatePrimitiveEncodeInline(field.Type.Elem.Name, "elem"))
			b.WriteString("    }\n")
		}
	}

	return b.String()
}

func generatePrimitiveEncodeInline(typeName string, varName string) string {
	primitiveSize := getPrimitiveSize(typeName)

	switch typeName {
	case "u8", "i8", "bool":
		return fmt.Sprintf("        buf[offset++] = %s;\n", varName)
	case "u16":
		return fmt.Sprintf("        *(uint16_t*)(buf + offset) = SDP_HTOLE16(%s);\n        offset += %d;\n", varName, primitiveSize)
	case "u32":
		return fmt.Sprintf("        *(uint32_t*)(buf + offset) = SDP_HTOLE32(%s);\n        offset += %d;\n", varName, primitiveSize)
	case "u64":
		return fmt.Sprintf("        *(uint64_t*)(buf + offset) = SDP_HTOLE64(%s);\n        offset += %d;\n", varName, primitiveSize)
	case "i16":
		return fmt.Sprintf("        *(int16_t*)(buf + offset) = (int16_t)SDP_HTOLE16((uint16_t)%s);\n        offset += %d;\n", varName, primitiveSize)
	case "i32":
		return fmt.Sprintf("        *(int32_t*)(buf + offset) = (int32_t)SDP_HTOLE32((uint32_t)%s);\n        offset += %d;\n", varName, primitiveSize)
	case "i64":
		return fmt.Sprintf("        *(int64_t*)(buf + offset) = (int64_t)SDP_HTOLE64((uint64_t)%s);\n        offset += %d;\n", varName, primitiveSize)
	case "f32":
		return fmt.Sprintf("        *(uint32_t*)(buf + offset) = sdp_f32_to_le(%s);\n        offset += %d;\n", varName, primitiveSize)
	case "f64":
		return fmt.Sprintf("        *(uint64_t*)(buf + offset) = sdp_f64_to_le(%s);\n        offset += %d;\n", varName, primitiveSize)
	default:
		return ""
	}
}

// generateInlineStructEncode generates inline encoding code for a struct type
// This eliminates function call overhead by inlining all struct field encoding
func generateInlineStructEncode(elemType parser.TypeExpr) string {
	var b strings.Builder

	// Find the struct definition in the schema
	var structDef *parser.Struct
	for i := range currentSchema.Structs {
		if currentSchema.Structs[i].Name == elemType.Name {
			structDef = &currentSchema.Structs[i]
			break
		}
	}

	if structDef == nil {
		// Fallback to function call if struct not found
		funcName := toSnakeCase(elemType.Name) + "_encode"
		b.WriteString(fmt.Sprintf("        offset += %s(elem, buf + offset);\n", funcName))
		return b.String()
	}

	// Inline all field encoding for this struct
	for _, field := range structDef.Fields {
		fieldName := "elem." + toSnakeCase(field.Name)
		b.WriteString(generateInlineFieldEncode(field, fieldName))
	}

	return b.String()
}

// generateInlineFieldEncode generates inline encoding for a single field
// Uses 8-space indentation (inside array loop)
func generateInlineFieldEncode(field parser.Field, fieldName string) string {
	var b strings.Builder

	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		if field.Type.Name == "str" {
			// String
			if field.Type.Optional {
				b.WriteString(fmt.Sprintf("        buf[offset++] = %s.has_value() ? 1 : 0;\n", fieldName))
				b.WriteString(fmt.Sprintf("        if (%s.has_value()) {\n", fieldName))
				b.WriteString(fmt.Sprintf("            uint32_t len = %s->size();\n", fieldName))
				b.WriteString("            *(uint32_t*)(buf + offset) = SDP_HTOLE32(len);\n")
				b.WriteString("            offset += 4;\n")
				b.WriteString(fmt.Sprintf("            std::memcpy(buf + offset, %s->data(), len);\n", fieldName))
				b.WriteString("            offset += len;\n")
				b.WriteString("        }\n")
			} else {
				b.WriteString(fmt.Sprintf("        uint32_t %s_len = %s.size();\n", toSnakeCase(field.Name), fieldName))
				b.WriteString(fmt.Sprintf("        *(uint32_t*)(buf + offset) = SDP_HTOLE32(%s_len);\n", toSnakeCase(field.Name)))
				b.WriteString("        offset += 4;\n")
				b.WriteString(fmt.Sprintf("        std::memcpy(buf + offset, %s.data(), %s_len);\n", fieldName, toSnakeCase(field.Name)))
				b.WriteString(fmt.Sprintf("        offset += %s_len;\n", toSnakeCase(field.Name)))
			}
		} else {
			// Primitive
			primitiveSize := getPrimitiveSize(field.Type.Name)
			if field.Type.Optional {
				b.WriteString(fmt.Sprintf("        buf[offset++] = %s.has_value() ? 1 : 0;\n", fieldName))
				b.WriteString(fmt.Sprintf("        if (%s.has_value()) {\n", fieldName))
				fieldName = "*" + fieldName
			}

			switch field.Type.Name {
			case "u8", "i8", "bool":
				b.WriteString(fmt.Sprintf("            buf[offset++] = %s;\n", fieldName))
			case "u16":
				b.WriteString(fmt.Sprintf("            *(uint16_t*)(buf + offset) = SDP_HTOLE16(%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			case "u32":
				b.WriteString(fmt.Sprintf("            *(uint32_t*)(buf + offset) = SDP_HTOLE32(%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			case "u64":
				b.WriteString(fmt.Sprintf("            *(uint64_t*)(buf + offset) = SDP_HTOLE64(%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			case "i16":
				b.WriteString(fmt.Sprintf("            *(int16_t*)(buf + offset) = (int16_t)SDP_HTOLE16((uint16_t)%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			case "i32":
				b.WriteString(fmt.Sprintf("            *(int32_t*)(buf + offset) = (int32_t)SDP_HTOLE32((uint32_t)%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			case "i64":
				b.WriteString(fmt.Sprintf("            *(int64_t*)(buf + offset) = (int64_t)SDP_HTOLE64((uint64_t)%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			case "f32":
				b.WriteString(fmt.Sprintf("            *(uint32_t*)(buf + offset) = sdp_f32_to_le(%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			case "f64":
				b.WriteString(fmt.Sprintf("            *(uint64_t*)(buf + offset) = sdp_f64_to_le(%s);\n", fieldName))
				b.WriteString(fmt.Sprintf("            offset += %d;\n", primitiveSize))
			}

			if field.Type.Optional {
				b.WriteString("        }\n")
			}
		}

	case parser.TypeKindArray:
		// Nested array in inlined struct - generate inline array encoding
		b.WriteString(fmt.Sprintf("        uint32_t %s_count = %s.size();\n", toSnakeCase(field.Name), fieldName))
		b.WriteString(fmt.Sprintf("        *(uint32_t*)(buf + offset) = SDP_HTOLE32(%s_count);\n", toSnakeCase(field.Name)))
		b.WriteString("        offset += 4;\n")

		if field.Type.Elem.Name == "str" {
			// String array
			b.WriteString(fmt.Sprintf("        for (const auto& nested_elem : %s) {\n", fieldName))
			b.WriteString("            uint32_t len = nested_elem.size();\n")
			b.WriteString("            *(uint32_t*)(buf + offset) = SDP_HTOLE32(len);\n")
			b.WriteString("            offset += 4;\n")
			b.WriteString("            std::memcpy(buf + offset, nested_elem.data(), len);\n")
			b.WriteString("            offset += len;\n")
			b.WriteString("        }\n")
		} else if field.Type.Elem.Kind == parser.TypeKindNamed {
			// Nested struct array - use function call to avoid deep recursion
			funcName := toSnakeCase(field.Type.Elem.Name) + "_encode"
			b.WriteString(fmt.Sprintf("        for (const auto& nested_elem : %s) {\n", fieldName))
			b.WriteString(fmt.Sprintf("            offset += %s(nested_elem, buf + offset);\n", funcName))
			b.WriteString("        }\n")
		} else {
			// Primitive array
			elemSize := getPrimitiveSize(field.Type.Elem.Name)
			if elemSize == 1 && field.Type.Elem.Name != "bool" {
				b.WriteString(fmt.Sprintf("        std::memcpy(buf + offset, %s.data(), %s_count);\n", fieldName, toSnakeCase(field.Name)))
				b.WriteString(fmt.Sprintf("        offset += %s_count;\n", toSnakeCase(field.Name)))
			} else {
				b.WriteString(fmt.Sprintf("        for (const auto& nested_elem : %s) {\n", fieldName))
				// Generate inline primitive encoding with proper indentation (12 spaces)
				primitiveCode := generatePrimitiveEncodeInline(field.Type.Elem.Name, "nested_elem")
				// Add extra indentation
				lines := strings.Split(strings.TrimRight(primitiveCode, "\n"), "\n")
				for _, line := range lines {
					b.WriteString("    " + line + "\n")
				}
				b.WriteString("        }\n")
			}
		}

	case parser.TypeKindNamed:
		// Nested struct - for now use function call to avoid infinite recursion
		funcName := toSnakeCase(field.Type.Name) + "_encode"
		if field.Type.Optional {
			b.WriteString(fmt.Sprintf("        buf[offset++] = %s.has_value() ? 1 : 0;\n", fieldName))
			b.WriteString(fmt.Sprintf("        if (%s.has_value()) {\n", fieldName))
			b.WriteString(fmt.Sprintf("            offset += %s(*%s, buf + offset);\n", funcName, fieldName))
			b.WriteString("        }\n")
		} else {
			b.WriteString(fmt.Sprintf("        offset += %s(%s, buf + offset);\n", funcName, fieldName))
		}
	}

	return b.String()
}
