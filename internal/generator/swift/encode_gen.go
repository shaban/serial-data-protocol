package swift

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateEncode generates Swift encoding extensions for all structs
func GenerateEncode(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	buf.WriteString("// Code generated by sdp-gen. DO NOT EDIT.\n\n")
	buf.WriteString("import Foundation\n\n")

	// Generate encode extension for each struct
	for _, s := range schema.Structs {
		if err := generateStructEncode(&buf, s); err != nil {
			return "", fmt.Errorf("failed to generate encode for %s: %w", s.Name, err)
		}
	}

	return buf.String(), nil
}

// generateStructEncode generates the encoding extension for a struct
func generateStructEncode(buf *strings.Builder, s parser.Struct) error {
	structName := ToSwiftName(s.Name)

	buf.WriteString(fmt.Sprintf("extension %s {\n", structName))

	// Generate encodeToData() - high-level API
	buf.WriteString("    /// Encode to Data (IPC mode)\n")
	buf.WriteString("    public func encodeToData() throws -> Data {\n")
	buf.WriteString("        var data = Data(capacity: encodedSize())\n")
	buf.WriteString("        try encode(to: &data)\n")
	buf.WriteString("        return data\n")
	buf.WriteString("    }\n\n")

	// Generate encode(to:) - low-level API that mutates Data
	buf.WriteString("    /// Encode to a Data buffer\n")
	buf.WriteString("    public func encode(to data: inout Data) throws {\n")

	// Encode each field
	for _, field := range s.Fields {
		if err := generateFieldEncode(buf, field, "        "); err != nil {
			return err
		}
	}

	buf.WriteString("    }\n\n")

	// Generate encodedSize() helper
	if err := generateEncodedSize(buf, s); err != nil {
		return err
	}

	buf.WriteString("}\n\n")

	return nil
}

// generateFieldEncode generates encoding code for a single field
func generateFieldEncode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		return generateOptionalEncode(buf, field, indent)
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		return generateArrayEncode(buf, field, indent)
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		return encodePrimitive(buf, field.Type.Name, "self."+fieldName, indent)

	case parser.TypeKindNamed:
		// Nested struct
		buf.WriteString(fmt.Sprintf("%stry self.%s.encode(to: &data)\n", indent, fieldName))
	}

	return nil
}

// encodePrimitive generates code to encode a primitive type
// fieldRef should be the full reference (e.g., "self.id" or "elem" or "value")
func encodePrimitive(buf *strings.Builder, typeName, fieldRef, indent string) error {
	switch typeName {
	case "u8":
		buf.WriteString(fmt.Sprintf("%sdata.append(%s)\n", indent, fieldRef))

	case "i8":
		buf.WriteString(fmt.Sprintf("%sdata.append(UInt8(bitPattern: %s))\n", indent, fieldRef))

	case "u16":
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %s.littleEndian) { Data($0) })\n",
			indent, fieldRef))

	case "u32":
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %s.littleEndian) { Data($0) })\n",
			indent, fieldRef))

	case "u64":
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %s.littleEndian) { Data($0) })\n",
			indent, fieldRef))

	case "i16":
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %s.littleEndian) { Data($0) })\n",
			indent, fieldRef))

	case "i32":
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %s.littleEndian) { Data($0) })\n",
			indent, fieldRef))

	case "i64":
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %s.littleEndian) { Data($0) })\n",
			indent, fieldRef))

	case "f32":
		// Extract just the base name for the temp variable
		baseName := fieldRef
		if strings.HasPrefix(baseName, "self.") {
			baseName = strings.TrimPrefix(baseName, "self.")
		}
		buf.WriteString(fmt.Sprintf("%slet %sBits = %s.bitPattern.littleEndian\n",
			indent, baseName, fieldRef))
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %sBits) { Data($0) })\n",
			indent, baseName))

	case "f64":
		// Extract just the base name for the temp variable
		baseName := fieldRef
		if strings.HasPrefix(baseName, "self.") {
			baseName = strings.TrimPrefix(baseName, "self.")
		}
		buf.WriteString(fmt.Sprintf("%slet %sBits = %s.bitPattern.littleEndian\n",
			indent, baseName, fieldRef))
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %sBits) { Data($0) })\n",
			indent, baseName))

	case "bool":
		buf.WriteString(fmt.Sprintf("%sdata.append(%s ? 1 : 0)\n", indent, fieldRef))

	case "str":
		// String: u32 length + UTF-8 bytes
		// Extract just the base name for temp variables
		baseName := fieldRef
		if strings.HasPrefix(baseName, "self.") {
			baseName = strings.TrimPrefix(baseName, "self.")
		}
		buf.WriteString(fmt.Sprintf("%slet %sData = %s.data(using: .utf8)!\n",
			indent, baseName, fieldRef))
		buf.WriteString(fmt.Sprintf("%slet %sLen = UInt32(%sData.count).littleEndian\n",
			indent, baseName, baseName))
		buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %sLen) { Data($0) })\n",
			indent, baseName))
		buf.WriteString(fmt.Sprintf("%sdata.append(%sData)\n", indent, baseName))

	default:
		return fmt.Errorf("unknown primitive type: %s", typeName)
	}

	return nil
}

// generateArrayEncode generates code to encode an array field
func generateArrayEncode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Encode array length as u32
	buf.WriteString(fmt.Sprintf("%slet %sLen = UInt32(self.%s.count).littleEndian\n",
		indent, fieldName, fieldName))
	buf.WriteString(fmt.Sprintf("%sdata.append(contentsOf: withUnsafeBytes(of: %sLen) { Data($0) })\n",
		indent, fieldName))

	// Encode array elements
	buf.WriteString(fmt.Sprintf("%sfor elem in self.%s {\n", indent, fieldName))

	if field.Type.Elem == nil {
		return fmt.Errorf("array field %s has no element type", field.Name)
	}

	elemType := field.Type.Elem

	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		// Primitive array element
		if err := encodePrimitive(buf, elemType.Name, "elem", indent+"    "); err != nil {
			return err
		}

	case parser.TypeKindNamed:
		// Nested struct array element
		buf.WriteString(fmt.Sprintf("%s    try elem.encode(to: &data)\n", indent))

	default:
		return fmt.Errorf("unsupported array element type for field %s", field.Name)
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// generateOptionalEncode generates code to encode an optional field
func generateOptionalEncode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Encode presence flag
	buf.WriteString(fmt.Sprintf("%sif let value = self.%s {\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%s    data.append(1) // present\n", indent))

	// Create a temporary field with non-optional type for encoding
	innerType := &parser.TypeExpr{
		Kind:  field.Type.Kind,
		Name:  field.Type.Name,
		Elem:  field.Type.Elem,
		Boxed: field.Type.Boxed,
	}

	tempField := parser.Field{
		Name: "value",
		Type: *innerType,
	}

	// Encode the value
	switch innerType.Kind {
	case parser.TypeKindPrimitive:
		if err := encodePrimitive(buf, innerType.Name, "value", indent+"    "); err != nil {
			return err
		}

	case parser.TypeKindNamed:
		buf.WriteString(fmt.Sprintf("%s    try value.encode(to: &data)\n", indent))

	case parser.TypeKindArray:
		if err := generateArrayEncode(buf, tempField, indent+"    "); err != nil {
			return err
		}

	default:
		return fmt.Errorf("unsupported optional inner type for field %s", field.Name)
	}

	buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
	buf.WriteString(fmt.Sprintf("%s    data.append(0) // absent\n", indent))
	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// generateEncodedSize generates the encodedSize() helper method
func generateEncodedSize(buf *strings.Builder, s parser.Struct) error {
	buf.WriteString("    /// Calculate the encoded size in bytes\n")
	buf.WriteString("    public func encodedSize() -> Int {\n")
	buf.WriteString("        var size = 0\n")

	for _, field := range s.Fields {
		if err := generateFieldSize(buf, field, "        "); err != nil {
			return err
		}
	}

	buf.WriteString("        return size\n")
	buf.WriteString("    }\n")

	return nil
}

// generateFieldSize generates size calculation for a field
func generateFieldSize(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		buf.WriteString(fmt.Sprintf("%ssize += 1 // optional flag\n", indent))
		buf.WriteString(fmt.Sprintf("%sif let value = self.%s {\n", indent, fieldName))

		// Calculate size of inner value using the unwrapped "value"
		innerType := &parser.TypeExpr{
			Kind:  field.Type.Kind,
			Name:  field.Type.Name,
			Elem:  field.Type.Elem,
			Boxed: field.Type.Boxed,
		}

		if err := generateValueSize(buf, innerType, "value", indent+"    "); err != nil {
			return err
		}

		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		return nil
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		buf.WriteString(fmt.Sprintf("%ssize += 4 // array length\n", indent))

		if field.Type.Elem == nil {
			return fmt.Errorf("array field %s has no element type", field.Name)
		}

		elemType := field.Type.Elem

		if elemType.Kind == parser.TypeKindPrimitive {
			fixedSize := FixedSize(elemType)
			if fixedSize > 0 {
				// Fixed-size elements
				buf.WriteString(fmt.Sprintf("%ssize += self.%s.count * %d\n",
					indent, fieldName, fixedSize))
			} else {
				// Variable-size elements (strings)
				buf.WriteString(fmt.Sprintf("%sfor elem in self.%s {\n", indent, fieldName))
				if elemType.Name == "str" {
					buf.WriteString(fmt.Sprintf("%s    size += 4 + elem.utf8.count\n", indent))
				}
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			}
		} else if elemType.Kind == parser.TypeKindNamed {
			// Nested struct elements
			buf.WriteString(fmt.Sprintf("%sfor elem in self.%s {\n", indent, fieldName))
			buf.WriteString(fmt.Sprintf("%s    size += elem.encodedSize()\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		}

		return nil
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		fixedSize := FixedSize(&field.Type)
		if fixedSize > 0 {
			buf.WriteString(fmt.Sprintf("%ssize += %d\n", indent, fixedSize))
		} else if field.Type.Name == "str" {
			// String: 4 bytes length + UTF-8 bytes
			buf.WriteString(fmt.Sprintf("%ssize += 4 + self.%s.utf8.count\n", indent, fieldName))
		}

	case parser.TypeKindNamed:
		// Nested struct
		buf.WriteString(fmt.Sprintf("%ssize += self.%s.encodedSize()\n", indent, fieldName))
	}

	return nil
}

// generateValueSize generates size calculation for a value reference (not self.field)
func generateValueSize(buf *strings.Builder, t *parser.TypeExpr, valueRef, indent string) error {
	// Handle arrays
	if t.Kind == parser.TypeKindArray {
		buf.WriteString(fmt.Sprintf("%ssize += 4 // array length\n", indent))

		if t.Elem == nil {
			return fmt.Errorf("array type has no element type")
		}

		elemType := t.Elem

		if elemType.Kind == parser.TypeKindPrimitive {
			fixedSize := FixedSize(elemType)
			if fixedSize > 0 {
				// Fixed-size elements
				buf.WriteString(fmt.Sprintf("%ssize += %s.count * %d\n",
					indent, valueRef, fixedSize))
			} else {
				// Variable-size elements (strings)
				buf.WriteString(fmt.Sprintf("%sfor elem in %s {\n", indent, valueRef))
				if elemType.Name == "str" {
					buf.WriteString(fmt.Sprintf("%s    size += 4 + elem.utf8.count\n", indent))
				}
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			}
		} else if elemType.Kind == parser.TypeKindNamed {
			// Nested struct elements
			buf.WriteString(fmt.Sprintf("%sfor elem in %s {\n", indent, valueRef))
			buf.WriteString(fmt.Sprintf("%s    size += elem.encodedSize()\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		}

		return nil
	}

	// Handle primitives
	if t.Kind == parser.TypeKindPrimitive {
		fixedSize := FixedSize(t)
		if fixedSize > 0 {
			buf.WriteString(fmt.Sprintf("%ssize += %d\n", indent, fixedSize))
		} else if t.Name == "str" {
			// String: 4 bytes length + UTF-8 bytes
			buf.WriteString(fmt.Sprintf("%ssize += 4 + %s.utf8.count\n", indent, valueRef))
		}
		return nil
	}

	// Handle named types (nested structs)
	if t.Kind == parser.TypeKindNamed {
		buf.WriteString(fmt.Sprintf("%ssize += %s.encodedSize()\n", indent, valueRef))
		return nil
	}

	return nil
}
