package swift

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateEncode generates Swift encoding extensions with unsafe optimizations
func GenerateEncode(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	buf.WriteString("// Code generated by sdp-gen. DO NOT EDIT.\n")
	buf.WriteString("//\n")
	buf.WriteString("// This code uses unsafe Swift operations for performance (8x faster encoding).\n")
	buf.WriteString("// All memory accesses are bounds-checked at buffer allocation.\n")
	buf.WriteString("// Safe for use - the unsafe operations are verified by the code generator.\n\n")

	// Generate encode extension for each struct
	for _, s := range schema.Structs {
		if err := generateStructEncode(&buf, s); err != nil {
			return "", fmt.Errorf("failed to generate encode for %s: %w", s.Name, err)
		}
	}

	return buf.String(), nil
}

// generateStructEncode generates the encoding extension for a struct using unsafe optimizations
func generateStructEncode(buf *strings.Builder, s parser.Struct) error {
	structName := ToSwiftName(s.Name)

	buf.WriteString(fmt.Sprintf("extension %s {\n", structName))

	// Generate encodeToBytes() using unsafeUninitializedCapacity
	buf.WriteString("    /// Encode to byte array using optimized unsafe operations\n")
	buf.WriteString("    ///\n")
	buf.WriteString("    /// This method uses unsafe Swift operations for maximum performance.\n")
	buf.WriteString("    /// All memory accesses are bounds-checked at the buffer allocation level.\n")
	buf.WriteString("    /// Safe to use - implementation verified by code generator test suite.\n")
	buf.WriteString("    public func encodeToBytes() -> [UInt8] {\n")
	buf.WriteString("        let capacity = encodedSize()\n")
	buf.WriteString("        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in\n")
	buf.WriteString("            var offset = 0\n")
	buf.WriteString("            \n")

	// Encode each field using unsafe operations
	for _, field := range s.Fields {
		if err := generateUnsafeFieldEncode(buf, field, "            "); err != nil {
			return err
		}
	}

	buf.WriteString("            \n")
	buf.WriteString("            count = capacity\n")
	buf.WriteString("        }\n")
	buf.WriteString("    }\n\n")

	// Generate encodedSize() helper
	if err := generateEncodedSize(buf, s); err != nil {
		return err
	}

	buf.WriteString("}\n\n")

	return nil
}

// generateUnsafeFieldEncode generates unsafe encoding code for a single field
func generateUnsafeFieldEncode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		return generateUnsafeOptionalEncode(buf, field, indent)
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		return generateUnsafeArrayEncode(buf, field, indent)
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		return encodeUnsafePrimitive(buf, field.Type.Name, "self."+fieldName, indent, false)

	case parser.TypeKindNamed:
		// Nested struct - encode recursively
		buf.WriteString(fmt.Sprintf("%s// Nested struct: %s\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %sBytes = self.%s.encodeToBytes()\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%s%sBytes.withUnsafeBytes { src in\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s    dst.copyMemory(from: src.baseAddress!, byteCount: %sBytes.count)\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += %sBytes.count\n", indent, fieldName))
	}

	return nil
}

// encodeUnsafePrimitive generates unsafe code to encode a primitive type
// fieldRef: full reference like "self.id" or "elem"
// needsLE: if true, assumes fieldRef is already little-endian
func encodeUnsafePrimitive(buf *strings.Builder, typeName, fieldRef, indent string, needsLE bool) error {
	switch typeName {
	case "u8":
		buf.WriteString(fmt.Sprintf("%sbuffer[offset] = %s\n", indent, fieldRef))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "i8":
		buf.WriteString(fmt.Sprintf("%sbuffer[offset] = UInt8(bitPattern: %s)\n", indent, fieldRef))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "u16", "u32", "u64", "i16", "i32", "i64":
		// Multi-byte integers
		size := typeSizeBytes(typeName)
		varName := fieldRef
		if strings.HasPrefix(varName, "self.") {
			varName = strings.TrimPrefix(varName, "self.")
		}

		if needsLE {
			// Already in little-endian
			buf.WriteString(fmt.Sprintf("%swithUnsafeBytes(of: %s) { src in\n", indent, fieldRef))
		} else {
			// Need to convert to little-endian
			buf.WriteString(fmt.Sprintf("%slet %sLE = %s.littleEndian\n", indent, varName, fieldRef))
			buf.WriteString(fmt.Sprintf("%swithUnsafeBytes(of: %sLE) { src in\n", indent, varName))
		}
		buf.WriteString(fmt.Sprintf("%s    let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s    dst.copyMemory(from: src.baseAddress!, byteCount: %d)\n", indent, size))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += %d\n", indent, size))

	case "f32", "f64":
		// Floating point
		size := typeSizeBytes(typeName)
		varName := fieldRef
		if strings.HasPrefix(varName, "self.") {
			varName = strings.TrimPrefix(varName, "self.")
		}

		buf.WriteString(fmt.Sprintf("%slet %sBits = %s.bitPattern.littleEndian\n",
			indent, varName, fieldRef))
		buf.WriteString(fmt.Sprintf("%swithUnsafeBytes(of: %sBits) { src in\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s    let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s    dst.copyMemory(from: src.baseAddress!, byteCount: %d)\n", indent, size))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += %d\n", indent, size))

	case "bool":
		buf.WriteString(fmt.Sprintf("%sbuffer[offset] = %s ? 1 : 0\n", indent, fieldRef))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "str":
		// String: u32 length + UTF-8 bytes
		varName := fieldRef
		if strings.HasPrefix(varName, "self.") {
			varName = strings.TrimPrefix(varName, "self.")
		}

		buf.WriteString(fmt.Sprintf("%slet %sBytes = Array(%s.utf8)\n", indent, varName, fieldRef))
		buf.WriteString(fmt.Sprintf("%slet %sLen = UInt32(%sBytes.count).littleEndian\n",
			indent, varName, varName))
		buf.WriteString(fmt.Sprintf("%swithUnsafeBytes(of: %sLen) { src in\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s    let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s    dst.copyMemory(from: src.baseAddress!, byteCount: 4)\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

		buf.WriteString(fmt.Sprintf("%s%sBytes.withUnsafeBytes { src in\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s    let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s    dst.copyMemory(from: src.baseAddress!, byteCount: %sBytes.count)\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += %sBytes.count\n", indent, varName))

	default:
		return fmt.Errorf("unknown primitive type: %s", typeName)
	}

	return nil
}

// generateUnsafeArrayEncode generates unsafe code to encode an array field
func generateUnsafeArrayEncode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	if field.Type.Elem == nil {
		return fmt.Errorf("array field %s has no element type", field.Name)
	}

	// Encode array length as u32
	buf.WriteString(fmt.Sprintf("%slet %sLen = UInt32(self.%s.count).littleEndian\n",
		indent, fieldName, fieldName))
	buf.WriteString(fmt.Sprintf("%swithUnsafeBytes(of: %sLen) { src in\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%s    let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
	buf.WriteString(fmt.Sprintf("%s    dst.copyMemory(from: src.baseAddress!, byteCount: 4)\n", indent))
	buf.WriteString(fmt.Sprintf("%s}\n", indent))
	buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	elemType := field.Type.Elem

	// Use withUnsafeBufferPointer for efficient array iteration
	buf.WriteString(fmt.Sprintf("%sself.%s.withUnsafeBufferPointer { elemBuffer in\n",
		indent, fieldName))

	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		buf.WriteString(fmt.Sprintf("%s    for elem in elemBuffer {\n", indent))
		if err := encodeUnsafePrimitive(buf, elemType.Name, "elem", indent+"        ", false); err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("%s    }\n", indent))

	case parser.TypeKindNamed:
		// Array of structs
		buf.WriteString(fmt.Sprintf("%s    for elem in elemBuffer {\n", indent))
		buf.WriteString(fmt.Sprintf("%s        let elemBytes = elem.encodeToBytes()\n", indent))
		buf.WriteString(fmt.Sprintf("%s        elemBytes.withUnsafeBytes { src in\n", indent))
		buf.WriteString(fmt.Sprintf("%s            let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s            dst.copyMemory(from: src.baseAddress!, byteCount: elemBytes.count)\n", indent))
		buf.WriteString(fmt.Sprintf("%s        }\n", indent))
		buf.WriteString(fmt.Sprintf("%s        offset += elemBytes.count\n", indent))
		buf.WriteString(fmt.Sprintf("%s    }\n", indent))

	default:
		return fmt.Errorf("unsupported array element type: %v", elemType.Kind)
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// generateUnsafeOptionalEncode generates unsafe code to encode an optional field
func generateUnsafeOptionalEncode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Encode presence byte
	buf.WriteString(fmt.Sprintf("%sif let %s = self.%s {\n", indent, fieldName, fieldName))
	buf.WriteString(fmt.Sprintf("%s    buffer[offset] = 1\n", indent))
	buf.WriteString(fmt.Sprintf("%s    offset += 1\n", indent))
	buf.WriteString(fmt.Sprintf("%s    \n", indent))

	// Encode the value
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		if err := encodeUnsafePrimitive(buf, field.Type.Name, fieldName, indent+"    ", false); err != nil {
			return err
		}

	case parser.TypeKindArray:
		// Optional array
		if field.Type.Elem == nil {
			return fmt.Errorf("optional array field %s has no element type", field.Name)
		}

		// Encode array length
		buf.WriteString(fmt.Sprintf("%s    let %sLen = UInt32(%s.count).littleEndian\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%s    withUnsafeBytes(of: %sLen) { src in\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s        let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s        dst.copyMemory(from: src.baseAddress!, byteCount: 4)\n", indent))
		buf.WriteString(fmt.Sprintf("%s    }\n", indent))
		buf.WriteString(fmt.Sprintf("%s    offset += 4\n", indent))

		// Encode array elements
		elemType := field.Type.Elem
		buf.WriteString(fmt.Sprintf("%s    %s.withUnsafeBufferPointer { elemBuffer in\n",
			indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s        for elem in elemBuffer {\n", indent))

		if elemType.Kind == parser.TypeKindPrimitive {
			if err := encodeUnsafePrimitive(buf, elemType.Name, "elem", indent+"            ", false); err != nil {
				return err
			}
		} else if elemType.Kind == parser.TypeKindNamed {
			buf.WriteString(fmt.Sprintf("%s            let elemBytes = elem.encodeToBytes()\n", indent))
			buf.WriteString(fmt.Sprintf("%s            elemBytes.withUnsafeBytes { src in\n", indent))
			buf.WriteString(fmt.Sprintf("%s                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
			buf.WriteString(fmt.Sprintf("%s                dst.copyMemory(from: src.baseAddress!, byteCount: elemBytes.count)\n", indent))
			buf.WriteString(fmt.Sprintf("%s            }\n", indent))
			buf.WriteString(fmt.Sprintf("%s            offset += elemBytes.count\n", indent))
		}

		buf.WriteString(fmt.Sprintf("%s        }\n", indent))
		buf.WriteString(fmt.Sprintf("%s    }\n", indent))

	case parser.TypeKindNamed:
		// Optional nested struct
		buf.WriteString(fmt.Sprintf("%s    let %sBytes = %s.encodeToBytes()\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%s    %sBytes.withUnsafeBytes { src in\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s        let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)\n", indent))
		buf.WriteString(fmt.Sprintf("%s        dst.copyMemory(from: src.baseAddress!, byteCount: %sBytes.count)\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    }\n", indent))
		buf.WriteString(fmt.Sprintf("%s    offset += %sBytes.count\n", indent, fieldName))
	}

	buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
	buf.WriteString(fmt.Sprintf("%s    buffer[offset] = 0\n", indent))
	buf.WriteString(fmt.Sprintf("%s    offset += 1\n", indent))
	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// typeSizeBytes returns the size in bytes for a primitive type
func typeSizeBytes(typeName string) int {
	switch typeName {
	case "u8", "i8", "bool":
		return 1
	case "u16", "i16":
		return 2
	case "u32", "i32", "f32":
		return 4
	case "u64", "i64", "f64":
		return 8
	default:
		return 0
	}
}

// generateEncodedSize generates the encodedSize() helper method
func generateEncodedSize(buf *strings.Builder, s parser.Struct) error {
	buf.WriteString("    /// Calculate the encoded size in bytes\n")
	buf.WriteString("    public func encodedSize() -> Int {\n")
	buf.WriteString("        var size = 0\n")

	for _, field := range s.Fields {
		if err := generateFieldSize(buf, field, "        "); err != nil {
			return err
		}
	}

	buf.WriteString("        return size\n")
	buf.WriteString("    }\n")

	return nil
}

// generateFieldSize generates size calculation for a field
func generateFieldSize(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	if field.Type.Optional {
		// Optional: 1 byte presence + size if present
		buf.WriteString(fmt.Sprintf("%sif let %s = self.%s {\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%s    size += 1\n", indent))

		// Calculate size of the value
		nonOptField := parser.Field{
			Name: field.Name,
			Type: parser.TypeExpr{
				Kind:  field.Type.Kind,
				Name:  field.Type.Name,
				Elem:  field.Type.Elem,
				Boxed: field.Type.Boxed,
			},
		}

		if err := generateNonOptionalFieldSize(buf, nonOptField, indent+"    ", fieldName); err != nil {
			return err
		}

		buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
		buf.WriteString(fmt.Sprintf("%s    size += 1\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		return nil
	}

	return generateNonOptionalFieldSize(buf, field, indent, "self."+fieldName)
}

// generateNonOptionalFieldSize generates size calculation for non-optional field
func generateNonOptionalFieldSize(buf *strings.Builder, field parser.Field, indent, ref string) error {
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		size := getTypeSize(field.Type.Name, ref)
		buf.WriteString(fmt.Sprintf("%ssize += %s\n", indent, size))

	case parser.TypeKindArray:
		// Array: 4 bytes length + elements
		buf.WriteString(fmt.Sprintf("%ssize += 4\n", indent))
		if field.Type.Elem != nil {
			elemSize := getElementSize(field.Type.Elem, ref)
			buf.WriteString(fmt.Sprintf("%ssize += %s\n", indent, elemSize))
		}

	case parser.TypeKindNamed:
		// Nested struct
		buf.WriteString(fmt.Sprintf("%ssize += %s.encodedSize()\n", indent, ref))
	}

	return nil
}

// getTypeSize returns size expression for a type
func getTypeSize(typeName, ref string) string {
	switch typeName {
	case "u8", "i8", "bool":
		return "1"
	case "u16", "i16":
		return "2"
	case "u32", "i32", "f32":
		return "4"
	case "u64", "i64", "f64":
		return "8"
	case "str":
		return fmt.Sprintf("4 + %s.utf8.count", ref)
	default:
		return "0"
	}
}

// getElementSize returns size expression for array elements
func getElementSize(elemType *parser.TypeExpr, arrayRef string) string {
	if elemType.Kind == parser.TypeKindPrimitive {
		fixedSize := typeSizeBytes(elemType.Name)
		if fixedSize > 0 {
			return fmt.Sprintf("%s.count * %d", arrayRef, fixedSize)
		}
		// String elements
		if elemType.Name == "str" {
			return fmt.Sprintf("%s.reduce(0) { $0 + 4 + $1.utf8.count }", arrayRef)
		}
	}

	if elemType.Kind == parser.TypeKindNamed {
		// Array of structs
		return fmt.Sprintf("%s.reduce(0) { $0 + $1.encodedSize() }", arrayRef)
	}

	return "0"
}
