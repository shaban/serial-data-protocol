package swift

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/shaban/serial-data-protocol/internal/generator/cpp"
	"github.com/shaban/serial-data-protocol/internal/parser"
)

// Generate generates Swift package with C++ backend from a schema
// This generates C++ implementation files plus Swift package wrappers (Package.swift + module.modulemap)
func Generate(schema *parser.Schema, outputDir string, benchMode bool, verbose bool) error {
	if schema == nil {
		return fmt.Errorf("schema is nil")
	}

	if outputDir == "" {
		return fmt.Errorf("output directory is empty")
	}

	// Create output directory structure
	sourcesDir := filepath.Join(outputDir, "Sources")
	if err := os.MkdirAll(sourcesDir, 0755); err != nil {
		return fmt.Errorf("failed to create Sources directory: %w", err)
	}

	// Get package name from the last component of outputDir
	packageName := filepath.Base(outputDir)
	if packageName == "." || packageName == "/" {
		packageName = "SDP"
	}

	packageDir := filepath.Join(sourcesDir, packageName)
	if err := os.MkdirAll(packageDir, 0755); err != nil {
		return fmt.Errorf("failed to create package directory: %w", err)
	}

	// Create include directory for headers (required by SPM)
	includeDir := filepath.Join(packageDir, "include")
	if err := os.MkdirAll(includeDir, 0755); err != nil {
		return fmt.Errorf("failed to create include directory: %w", err)
	}

	if verbose {
		fmt.Printf("Generating Swift package with C++ backend in %s\n", outputDir)
	}

	// Step 1: Generate C++ implementation files to package directory first
	// Then we'll move headers to include/
	if verbose {
		fmt.Println("  - Generating C++ implementation files...")
	}

	// Generate C++ files to package directory (so it uses correct package name)
	if err := cpp.Generate(schema, packageDir, benchMode, verbose); err != nil {
		return fmt.Errorf("failed to generate C++ code: %w", err)
	}

	// Move header files to include/ subdirectory
	headerFiles := []string{"types.hpp", "encode.hpp", "decode.hpp", "endian.hpp"}
	for _, header := range headerFiles {
		srcPath := filepath.Join(packageDir, header)
		dstPath := filepath.Join(includeDir, header)
		if _, err := os.Stat(srcPath); err == nil {
			if err := os.Rename(srcPath, dstPath); err != nil {
				return fmt.Errorf("failed to move %s: %w", header, err)
			}
			if verbose {
				fmt.Printf("  Moved %s to include/\n", header)
			}
		}
	}

	// Remove CMakeLists.txt (not needed for SPM)
	os.Remove(filepath.Join(packageDir, "CMakeLists.txt"))

	// Step 2: Generate module.modulemap in include directory
	if err := generateModuleMap(includeDir, packageName, verbose); err != nil {
		return fmt.Errorf("failed to generate module.modulemap: %w", err)
	}

	// Step 3: Generate Package.swift with C++ interop settings
	if err := generatePackageSwift(outputDir, packageName, verbose); err != nil {
		return fmt.Errorf("failed to generate Package.swift: %w", err)
	}

	// Step 4: Generate examples/crossplatform_helper (only in bench mode)
	if benchMode {
		if err := generateExampleHelper(schema, outputDir, packageName, benchMode, verbose); err != nil {
			return fmt.Errorf("failed to generate example: %w", err)
		}
	}

	if verbose {
		fmt.Println("Swift package generation completed successfully")
		fmt.Printf("  Package uses C++ backend with Swift interop via module.modulemap\n")
		fmt.Printf("  To use: swift build -c release\n")
	}

	return nil
}

// generateModuleMap generates module.modulemap to expose C++ headers to Swift
func generateModuleMap(packageDir, packageName string, verbose bool) error {
	content := fmt.Sprintf(`// Code generated by sdp-gen. DO NOT EDIT.
// This module map exposes C++ headers to Swift via Swift/C++ interop
module %s {
    header "types.hpp"
    header "encode.hpp"
    header "decode.hpp"
    requires cplusplus
    export *
}
`, packageName)

	path := filepath.Join(packageDir, "module.modulemap")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write module.modulemap: %w", err)
	}

	if verbose {
		fmt.Printf("  Generated %s\n", path)
	}

	return nil
}

// generatePackageSwift generates the Package.swift manifest with C++ interop support
func generatePackageSwift(outputDir, packageName string, verbose bool) error {
	content := fmt.Sprintf(`// swift-tools-version:5.9
// Code generated by sdp-gen. DO NOT EDIT.
import PackageDescription

let package = Package(
    name: "%s",
    platforms: [
        .macOS(.v10_15),
        .iOS(.v13),
        .watchOS(.v6),
        .tvOS(.v13)
    ],
    products: [
        .library(
            name: "%s",
            targets: ["%s"]),
    ],
    targets: [
        .target(
            name: "%s",
            dependencies: [],
            cxxSettings: [
                .unsafeFlags(["-std=c++17"]),
            ],
            swiftSettings: [
                // Enable C++ interop (Swift 5.9+)
                .interoperabilityMode(.Cxx),
                // Optimization flags
                .unsafeFlags(["-O", "-whole-module-optimization"]),
            ]),
    ]
)
`, packageName, packageName, packageName, packageName)

	path := filepath.Join(outputDir, "Package.swift")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Package.swift: %w", err)
	}

	if verbose {
		fmt.Printf("  Generated %s\n", path)
	}

	return nil
}

// generateExampleHelper creates the benchmark server executable
func generateExampleHelper(schema *parser.Schema, outputDir, packageName string, benchMode bool, verbose bool) error {
	// Server name based on package name (e.g., "primitives-server")
	serverName := packageName + "-server"

	// Create server directory for Package.swift to recognize it
	serverDir := filepath.Join(outputDir, "Sources", serverName)
	if err := os.MkdirAll(serverDir, 0755); err != nil {
		return fmt.Errorf("failed to create server directory: %w", err)
	}

	// Generate server content
	content := GenerateExample(schema, packageName, benchMode)

	// Write main.swift file
	mainPath := filepath.Join(serverDir, "main.swift")
	if err := os.WriteFile(mainPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write main.swift: %w", err)
	}

	if verbose {
		fmt.Printf("  Generated Sources/%s/main.swift\n", serverName)
	}

	// Update Package.swift to include the executable
	if err := updatePackageSwiftWithExecutable(outputDir, packageName, serverName, verbose); err != nil {
		return fmt.Errorf("failed to update Package.swift: %w", err)
	}

	return nil
}

// updatePackageSwiftWithExecutable updates Package.swift to include the executable target
func updatePackageSwiftWithExecutable(outputDir, packageName, serverName string, verbose bool) error {
	content := fmt.Sprintf(`// swift-tools-version:5.9
// Code generated by sdp-gen. DO NOT EDIT.
import PackageDescription

let package = Package(
    name: "%s",
    platforms: [
        .macOS(.v10_15),
        .iOS(.v13),
        .watchOS(.v6),
        .tvOS(.v13)
    ],
    products: [
        .library(
            name: "%s",
            targets: ["%s"]),
        .executable(
            name: "%s",
            targets: ["%s"]),
    ],
    targets: [
        .target(
            name: "%s",
            dependencies: [],
            cxxSettings: [
                .unsafeFlags(["-std=c++17"]),
            ],
            swiftSettings: [
                // Enable C++ interop (Swift 5.9+)
                .interoperabilityMode(.Cxx),
                // Optimization flags
                .unsafeFlags(["-O", "-whole-module-optimization"]),
            ]),
        .executableTarget(
            name: "%s",
            dependencies: ["%s"],
            swiftSettings: [
                .interoperabilityMode(.Cxx),
                .unsafeFlags(["-O", "-whole-module-optimization"]),
            ]),
    ]
)
`, packageName, packageName, packageName, serverName, serverName, packageName, serverName, packageName)

	path := filepath.Join(outputDir, "Package.swift")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Package.swift: %w", err)
	}

	if verbose {
		fmt.Printf("  Updated %s with executable target\n", path)
	}

	return nil
}
