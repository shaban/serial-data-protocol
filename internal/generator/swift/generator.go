package swift

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// Generate generates Swift code from a schema
func Generate(schema *parser.Schema, outputDir string, verbose bool) error {
	if schema == nil {
		return fmt.Errorf("schema is nil")
	}

	if outputDir == "" {
		return fmt.Errorf("output directory is empty")
	}

	// Create output directory structure
	sourcesDir := filepath.Join(outputDir, "Sources")
	if err := os.MkdirAll(sourcesDir, 0755); err != nil {
		return fmt.Errorf("failed to create Sources directory: %w", err)
	}

	// Get package name from the last component of outputDir
	packageName := filepath.Base(outputDir)
	if packageName == "." || packageName == "/" {
		packageName = "SDP"
	}

	packageDir := filepath.Join(sourcesDir, packageName)
	if err := os.MkdirAll(packageDir, 0755); err != nil {
		return fmt.Errorf("failed to create package directory: %w", err)
	}

	if verbose {
		fmt.Printf("Generating Swift code in %s\n", outputDir)
	}

	// Generate Package.swift
	if err := generatePackageSwift(outputDir, packageName, verbose); err != nil {
		return fmt.Errorf("failed to generate Package.swift: %w", err)
	}

	// Generate Types.swift
	if err := generateTypes(schema, packageDir, verbose); err != nil {
		return fmt.Errorf("failed to generate Types.swift: %w", err)
	}

	// Generate Encode.swift
	if err := generateEncode(schema, packageDir, verbose); err != nil {
		return fmt.Errorf("failed to generate Encode.swift: %w", err)
	}

	// Generate Decode.swift
	if err := generateDecode(schema, packageDir, verbose); err != nil {
		return fmt.Errorf("failed to generate Decode.swift: %w", err)
	}

	// Generate examples/crossplatform_helper
	if err := generateExampleHelper(schema, outputDir, packageName, verbose); err != nil {
		return fmt.Errorf("failed to generate example: %w", err)
	}

	if verbose {
		fmt.Println("Swift code generation completed successfully")
	}

	return nil
}

// generatePackageSwift generates the Package.swift manifest with aggressive optimizations
func generatePackageSwift(outputDir, packageName string, verbose bool) error {
	content := fmt.Sprintf(`// swift-tools-version:5.9
// Code generated by sdp-gen. DO NOT EDIT.
import PackageDescription

let package = Package(
    name: "%s",
    platforms: [
        .macOS(.v10_15),
        .iOS(.v13),
        .watchOS(.v6),
        .tvOS(.v13)
    ],
    products: [
        .library(
            name: "%s",
            targets: ["%s"]),
    ],
    targets: [
        .target(
            name: "%s",
            dependencies: [],
            swiftSettings: [
                // Maximum optimization for generated code
                .unsafeFlags(["-O", "-whole-module-optimization"]),
                // Enable all performance features
                .unsafeFlags(["-enforce-exclusivity=unchecked"]),
                // Disable runtime safety checks in release (generated code is pre-verified)
                .unsafeFlags(["-remove-runtime-asserts"]),
            ]),
    ]
)
`, packageName, packageName, packageName, packageName)

	path := filepath.Join(outputDir, "Package.swift")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Package.swift: %w", err)
	}

	if verbose {
		fmt.Printf("Generated %s\n", path)
	}

	return nil
}

// generateTypes generates Types.swift with struct definitions
func generateTypes(schema *parser.Schema, packageDir string, verbose bool) error {
	content, err := GenerateStructs(schema)
	if err != nil {
		return err
	}

	path := filepath.Join(packageDir, "Types.swift")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Types.swift: %w", err)
	}

	if verbose {
		fmt.Printf("Generated %s\n", path)
	}

	return nil
}

// generateEncode generates Encode.swift with encoding methods
func generateEncode(schema *parser.Schema, packageDir string, verbose bool) error {
	content, err := GenerateEncode(schema)
	if err != nil {
		return err
	}

	path := filepath.Join(packageDir, "Encode.swift")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Encode.swift: %w", err)
	}

	if verbose {
		fmt.Printf("Generated %s\n", path)
	}

	return nil
}

// generateDecode generates Decode.swift with decoding methods
func generateDecode(schema *parser.Schema, packageDir string, verbose bool) error {
	content, err := GenerateDecode(schema)
	if err != nil {
		return err
	}

	path := filepath.Join(packageDir, "Decode.swift")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Decode.swift: %w", err)
	}

	if verbose {
		fmt.Printf("Generated %s\n", path)
	}

	return nil
}

// generateExampleHelper creates the crossplatform_helper executable
func generateExampleHelper(schema *parser.Schema, outputDir, packageName string, verbose bool) error {
	// Create examples directory for Package.swift to recognize it
	examplesDir := filepath.Join(outputDir, "Sources", "crossplatform_helper")
	if err := os.MkdirAll(examplesDir, 0755); err != nil {
		return fmt.Errorf("failed to create examples directory: %w", err)
	}

	// Generate example content
	content := GenerateExample(schema, packageName)

	// Write main.swift file
	mainPath := filepath.Join(examplesDir, "main.swift")
	if err := os.WriteFile(mainPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write main.swift: %w", err)
	}

	if verbose {
		fmt.Printf("  Generated Sources/crossplatform_helper/main.swift\n")
	}

	// Update Package.swift to include the executable
	if err := updatePackageSwiftWithExecutable(outputDir, packageName, verbose); err != nil {
		return fmt.Errorf("failed to update Package.swift: %w", err)
	}

	return nil
}

// updatePackageSwiftWithExecutable updates Package.swift to include the executable target
func updatePackageSwiftWithExecutable(outputDir, packageName string, verbose bool) error {
	content := fmt.Sprintf(`// swift-tools-version:5.9
// Code generated by sdp-gen. DO NOT EDIT.
import PackageDescription

let package = Package(
    name: "%s",
    platforms: [
        .macOS(.v10_15),
        .iOS(.v13),
        .watchOS(.v6),
        .tvOS(.v13)
    ],
    products: [
        .library(
            name: "%s",
            targets: ["%s"]),
        .executable(
            name: "crossplatform_helper",
            targets: ["crossplatform_helper"]),
    ],
    targets: [
        .target(
            name: "%s",
            dependencies: [],
            swiftSettings: [
                // Maximum optimization for generated code
                .unsafeFlags(["-O", "-whole-module-optimization"]),
                // Enable all performance features
                .unsafeFlags(["-enforce-exclusivity=unchecked"]),
                // Disable runtime safety checks in release (generated code is pre-verified)
                .unsafeFlags(["-remove-runtime-asserts"]),
            ]),
        .executableTarget(
            name: "crossplatform_helper",
            dependencies: ["%s"],
            swiftSettings: [
                .unsafeFlags(["-O", "-whole-module-optimization"]),
            ]),
    ]
)
`, packageName, packageName, packageName, packageName, packageName)

	path := filepath.Join(outputDir, "Package.swift")

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Package.swift: %w", err)
	}

	if verbose {
		fmt.Printf("  Updated %s with executable target\n", path)
	}

	return nil
}
