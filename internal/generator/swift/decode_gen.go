package swift

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateDecode generates Swift decoding extensions for all structs
func GenerateDecode(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	buf.WriteString("// Code generated by sdp-gen. DO NOT EDIT.\n\n")
	buf.WriteString("import Foundation\n\n")

	// Error type for decoding
	buf.WriteString("public enum SDPDecodeError: Error {\n")
	buf.WriteString("    case insufficientData\n")
	buf.WriteString("    case invalidUTF8\n")
	buf.WriteString("    case invalidBoolValue\n")
	buf.WriteString("}\n\n")

	// Generate decode extension for each struct
	for _, s := range schema.Structs {
		if err := generateStructDecode(&buf, s); err != nil {
			return "", fmt.Errorf("failed to generate decode for %s: %w", s.Name, err)
		}
	}

	return buf.String(), nil
}

// generateStructDecode generates the decoding extension for a struct
func generateStructDecode(buf *strings.Builder, s parser.Struct) error {
	structName := ToSwiftName(s.Name)

	buf.WriteString(fmt.Sprintf("extension %s {\n", structName))

	// Generate static decode method
	buf.WriteString("    /// Decode from Data\n")
	buf.WriteString("    public static func decode(from data: Data) throws -> Self {\n")
	buf.WriteString("        var offset = 0\n\n")

	// Decode each field
	for _, field := range s.Fields {
		if err := generateFieldDecode(buf, field, "        "); err != nil {
			return err
		}
	}

	// Build the struct
	buf.WriteString("\n        return Self(\n")
	for i, field := range s.Fields {
		fieldName := toSwiftFieldName(field.Name)
		if i < len(s.Fields)-1 {
			buf.WriteString(fmt.Sprintf("            %s: %s,\n", fieldName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf("            %s: %s\n", fieldName, fieldName))
		}
	}
	buf.WriteString("        )\n")

	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateFieldDecode generates decoding code for a single field
func generateFieldDecode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		return generateOptionalDecode(buf, field, indent)
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		return generateArrayDecode(buf, field, indent)
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		return decodePrimitive(buf, field.Type.Name, fieldName, indent)

	case parser.TypeKindNamed:
		// Nested struct
		typeName := ToSwiftName(field.Type.Name)
		buf.WriteString(fmt.Sprintf("%slet %s = try %s.decode(from: data[offset...])\n",
			indent, fieldName, typeName))
		buf.WriteString(fmt.Sprintf("%soffset += %s.encodedSize()\n", indent, fieldName))
	}

	return nil
}

// decodePrimitive generates code to decode a primitive type
func decodePrimitive(buf *strings.Builder, typeName, fieldName, indent string) error {
	switch typeName {
	case "u8":
		buf.WriteString(fmt.Sprintf("%sguard offset < data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = data[offset]\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "i8":
		buf.WriteString(fmt.Sprintf("%sguard offset < data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = Int8(bitPattern: data[offset])\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "u16":
		buf.WriteString(fmt.Sprintf("%sguard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = data[offset..<offset+2].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: UInt16.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 2\n", indent))

	case "u32":
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = data[offset..<offset+4].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: UInt32.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	case "u64":
		buf.WriteString(fmt.Sprintf("%sguard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = data[offset..<offset+8].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: UInt64.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 8\n", indent))

	case "i16":
		buf.WriteString(fmt.Sprintf("%sguard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = data[offset..<offset+2].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: Int16.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 2\n", indent))

	case "i32":
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = data[offset..<offset+4].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: Int32.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	case "i64":
		buf.WriteString(fmt.Sprintf("%sguard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = data[offset..<offset+8].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: Int64.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 8\n", indent))

	case "f32":
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sBits = data[offset..<offset+4].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: UInt32.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = Float(bitPattern: %sBits)\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	case "f64":
		buf.WriteString(fmt.Sprintf("%sguard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sBits = data[offset..<offset+8].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: UInt64.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = Double(bitPattern: %sBits)\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 8\n", indent))

	case "bool":
		buf.WriteString(fmt.Sprintf("%sguard offset < data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sByte = data[offset]\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%sguard %sByte == 0 || %sByte == 1 else { throw SDPDecodeError.invalidBoolValue }\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = %sByte == 1\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "str":
		// String: u32 length + UTF-8 bytes
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sLen = data[offset..<offset+4].withUnsafeBytes {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    $0.load(as: UInt32.self).littleEndian\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))
		buf.WriteString(fmt.Sprintf("%sguard offset + Int(%sLen) <= data.count else { throw SDPDecodeError.insufficientData }\n",
			indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %sData = data[offset..<offset+Int(%sLen)]\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%sguard let %s = String(data: %sData, encoding: .utf8) else {\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%s    throw SDPDecodeError.invalidUTF8\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += Int(%sLen)\n", indent, fieldName))

	default:
		return fmt.Errorf("unknown primitive type: %s", typeName)
	}

	return nil
}

// generateArrayDecode generates code to decode an array field
func generateArrayDecode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Decode array length
	buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }\n", indent))
	buf.WriteString(fmt.Sprintf("%slet %sLen = data[offset..<offset+4].withUnsafeBytes {\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%s    $0.load(as: UInt32.self).littleEndian\n", indent))
	buf.WriteString(fmt.Sprintf("%s}\n", indent))
	buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	if field.Type.Elem == nil {
		return fmt.Errorf("array field %s has no element type", field.Name)
	}

	elemType := field.Type.Elem
	elemTypeName := MapTypeToSwift(elemType)

	// Decode array elements
	buf.WriteString(fmt.Sprintf("%svar %s: [%s] = []\n", indent, fieldName, elemTypeName))
	buf.WriteString(fmt.Sprintf("%s%s.reserveCapacity(Int(%sLen))\n", indent, fieldName, fieldName))
	buf.WriteString(fmt.Sprintf("%sfor _ in 0..<Int(%sLen) {\n", indent, fieldName))

	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		// Decode primitive element
		if err := decodePrimitive(buf, elemType.Name, "elem", indent+"    "); err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("%s    %s.append(elem)\n", indent, fieldName))

	case parser.TypeKindNamed:
		// Decode nested struct element
		elemStructName := ToSwiftName(elemType.Name)
		buf.WriteString(fmt.Sprintf("%s    let elem = try %s.decode(from: data[offset...])\n",
			indent, elemStructName))
		buf.WriteString(fmt.Sprintf("%s    offset += elem.encodedSize()\n", indent))
		buf.WriteString(fmt.Sprintf("%s    %s.append(elem)\n", indent, fieldName))

	default:
		return fmt.Errorf("unsupported array element type for field %s", field.Name)
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// generateOptionalDecode generates code to decode an optional field
func generateOptionalDecode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Decode presence flag
	buf.WriteString(fmt.Sprintf("%sguard offset < data.count else { throw SDPDecodeError.insufficientData }\n", indent))
	buf.WriteString(fmt.Sprintf("%slet %sPresent = data[offset]\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	// Decode value if present
	buf.WriteString(fmt.Sprintf("%slet %s: %s\n", indent, fieldName, mapFieldType(&field.Type)))
	buf.WriteString(fmt.Sprintf("%sif %sPresent == 1 {\n", indent, fieldName))

	// Create a temporary field with non-optional type for decoding
	innerType := &parser.TypeExpr{
		Kind:  field.Type.Kind,
		Name:  field.Type.Name,
		Elem:  field.Type.Elem,
		Boxed: field.Type.Boxed,
	}

	tempField := parser.Field{
		Name: "value",
		Type: *innerType,
	}

	// Decode the value
	switch innerType.Kind {
	case parser.TypeKindPrimitive:
		if err := decodePrimitive(buf, innerType.Name, "value", indent+"    "); err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("%s    %s = value\n", indent, fieldName))

	case parser.TypeKindNamed:
		typeName := ToSwiftName(innerType.Name)
		buf.WriteString(fmt.Sprintf("%s    let value = try %s.decode(from: data[offset...])\n",
			indent, typeName))
		buf.WriteString(fmt.Sprintf("%s    offset += value.encodedSize()\n", indent))
		buf.WriteString(fmt.Sprintf("%s    %s = value\n", indent, fieldName))

	case parser.TypeKindArray:
		if err := generateArrayDecode(buf, tempField, indent+"    "); err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("%s    %s = value\n", indent, fieldName))

	default:
		return fmt.Errorf("unsupported optional inner type for field %s", field.Name)
	}

	buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
	buf.WriteString(fmt.Sprintf("%s    %s = nil\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}
