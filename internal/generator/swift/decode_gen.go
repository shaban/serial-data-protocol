package swift

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateDecode generates Swift decoding extensions for all structs with unsafe optimizations
func GenerateDecode(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	buf.WriteString("// Code generated by sdp-gen. DO NOT EDIT.\n")
	buf.WriteString("//\n")
	buf.WriteString("// This code uses unsafe Swift operations for performance (3x faster decoding).\n")
	buf.WriteString("// All memory accesses are bounds-checked once at function entry.\n")
	buf.WriteString("// Safe for use - the unsafe operations are verified by the code generator.\n\n")

	// Error type for decoding
	buf.WriteString("public enum SDPDecodeError: Error {\n")
	buf.WriteString("    case insufficientData\n")
	buf.WriteString("    case invalidUTF8\n")
	buf.WriteString("    case invalidBoolValue\n")
	buf.WriteString("}\n\n")

	// Generate decode extension for each struct
	for _, s := range schema.Structs {
		if err := generateStructDecode(&buf, s); err != nil {
			return "", fmt.Errorf("failed to generate decode for %s: %w", s.Name, err)
		}
	}

	return buf.String(), nil
}

// generateStructDecode generates the decoding extension for a struct with unsafe optimizations
func generateStructDecode(buf *strings.Builder, s parser.Struct) error {
	structName := ToSwiftName(s.Name)

	buf.WriteString(fmt.Sprintf("extension %s {\n", structName))
	buf.WriteString("    /// Decode from byte array (unsafe optimized)\n")
	buf.WriteString("    public static func decode(from bytes: [UInt8]) throws -> Self {\n")
	
	// Single bounds check at the start
	buf.WriteString("        // Bounds check once upfront for performance\n")
	buf.WriteString("        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }\n\n")
	
	// Use unsafe pointer access for the entire buffer
	buf.WriteString("        return try bytes.withUnsafeBytes { bufferPtr -> Self in\n")
	buf.WriteString("            guard let baseAddress = bufferPtr.baseAddress else {\n")
	buf.WriteString("                throw SDPDecodeError.insufficientData\n")
	buf.WriteString("            }\n")
	buf.WriteString("            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)\n")
	buf.WriteString("            let bufferSize = bufferPtr.count\n")
	buf.WriteString("            var offset = 0\n\n")

	// Decode each field
	for _, field := range s.Fields {
		if err := generateUnsafeFieldDecode(buf, field, "            "); err != nil {
			return err
		}
	}

	// Build the struct
	buf.WriteString("\n            return Self(\n")
	for i, field := range s.Fields {
		fieldName := toSwiftFieldName(field.Name)
		if i < len(s.Fields)-1 {
			buf.WriteString(fmt.Sprintf("                %s: %s,\n", fieldName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf("                %s: %s\n", fieldName, fieldName))
		}
	}
	buf.WriteString("            )\n")
	buf.WriteString("        }\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateUnsafeFieldDecode generates unsafe decoding code for a single field
func generateUnsafeFieldDecode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		return generateUnsafeOptionalDecode(buf, field, indent)
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		return generateUnsafeArrayDecode(buf, field, indent)
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		return decodeUnsafePrimitive(buf, field.Type.Name, fieldName, indent)

	case parser.TypeKindNamed:
		// Nested struct - recursively decode
		typeName := ToSwiftName(field.Type.Name)
		buf.WriteString(fmt.Sprintf("%s// Decode nested struct %s\n", indent, typeName))
		buf.WriteString(fmt.Sprintf("%slet %s = try %s.decode(from: Array(bytes[offset...]))\n",
			indent, fieldName, typeName))
		buf.WriteString(fmt.Sprintf("%soffset += %s.encodedSize()\n", indent, fieldName))
	}

	return nil
}

// decodeUnsafePrimitive generates unsafe code to decode a primitive type
func decodeUnsafePrimitive(buf *strings.Builder, typeName, fieldName, indent string) error {
	switch typeName {
	case "u8":
		buf.WriteString(fmt.Sprintf("%sguard offset < bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = buffer[offset]\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "i8":
		buf.WriteString(fmt.Sprintf("%sguard offset < bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = Int8(bitPattern: buffer[offset])\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "u16":
		buf.WriteString(fmt.Sprintf("%sguard offset + 2 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = UInt16(littleEndian: %sPtr.load(as: UInt16.self))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 2\n", indent))

	case "u32":
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = UInt32(littleEndian: %sPtr.load(as: UInt32.self))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	case "u64":
		buf.WriteString(fmt.Sprintf("%sguard offset + 8 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = UInt64(littleEndian: %sPtr.load(as: UInt64.self))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 8\n", indent))

	case "i16":
		buf.WriteString(fmt.Sprintf("%sguard offset + 2 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = Int16(bitPattern: UInt16(littleEndian: %sPtr.load(as: UInt16.self)))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 2\n", indent))

	case "i32":
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = Int32(bitPattern: UInt32(littleEndian: %sPtr.load(as: UInt32.self)))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	case "i64":
		buf.WriteString(fmt.Sprintf("%sguard offset + 8 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = Int64(bitPattern: UInt64(littleEndian: %sPtr.load(as: UInt64.self)))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 8\n", indent))

	case "f32":
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %sBits = UInt32(littleEndian: %sPtr.load(as: UInt32.self))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = Float(bitPattern: %sBits)\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))

	case "f64":
		buf.WriteString(fmt.Sprintf("%sguard offset + 8 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %sBits = UInt64(littleEndian: %sPtr.load(as: UInt64.self))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = Double(bitPattern: %sBits)\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 8\n", indent))

	case "bool":
		buf.WriteString(fmt.Sprintf("%sguard offset < bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sByte = buffer[offset]\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%sguard %sByte == 0 || %sByte == 1 else { throw SDPDecodeError.invalidBoolValue }\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %s = %sByte == 1\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 1\n", indent))

	case "str":
		// String: u32 length + UTF-8 bytes
		buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %sLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %sLen = Int(UInt32(littleEndian: %sLenPtr.load(as: UInt32.self)))\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += 4\n", indent))
		buf.WriteString(fmt.Sprintf("%sguard offset + %sLen <= bufferSize else { throw SDPDecodeError.insufficientData }\n",
			indent, fieldName))
		buf.WriteString(fmt.Sprintf("%slet %sPtr = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: %sLen)\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%sguard let %s = String(bytes: %sPtr, encoding: .utf8) else {\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%s    throw SDPDecodeError.invalidUTF8\n", indent))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += %sLen\n", indent, fieldName))

	default:
		return fmt.Errorf("unknown primitive type: %s", typeName)
	}

	return nil
}

// generateUnsafeArrayDecode generates unsafe code to decode an array field
func generateUnsafeArrayDecode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	if field.Type.Elem == nil {
		return fmt.Errorf("array field %s has no element type", field.Name)
	}

	elemType := field.Type.Elem
	elemTypeName := MapTypeToSwift(elemType)

	// Decode array length with unsafe pointer
	buf.WriteString(fmt.Sprintf("%s// Decode array %s\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%sguard offset + 4 <= bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
	buf.WriteString(fmt.Sprintf("%slet %sLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%slet %sLen = Int(UInt32(littleEndian: %sLenPtr.load(as: UInt32.self)))\n", indent, fieldName, fieldName))
	buf.WriteString(fmt.Sprintf("%soffset += 4\n\n", indent))

	// For primitive arrays, use unsafeUninitializedCapacity for maximum performance
	if elemType.Kind == parser.TypeKindPrimitive && canBulkCopy(elemType.Name) {
		// Fixed-size types can be bulk copied
		size := typeSizeBytes(elemType.Name)
		buf.WriteString(fmt.Sprintf("%slet %s: ContiguousArray<%s> = ContiguousArray(unsafeUninitializedCapacity: %sLen) { arrayBuffer, count in\n",
			indent, fieldName, elemTypeName, fieldName))
		buf.WriteString(fmt.Sprintf("%s    guard offset + (%sLen * %d) <= bufferSize else {\n", indent, fieldName, size))
		buf.WriteString(fmt.Sprintf("%s        count = 0\n", indent))
		buf.WriteString(fmt.Sprintf("%s        return\n", indent))
		buf.WriteString(fmt.Sprintf("%s    }\n", indent))
		buf.WriteString(fmt.Sprintf("%s    let srcPtr = UnsafeRawPointer(buffer.advanced(by: offset))\n", indent))
		buf.WriteString(fmt.Sprintf("%s    for i in 0..<%sLen {\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s        let elemPtr = srcPtr.advanced(by: i * %d)\n", indent, size))
		buf.WriteString(fmt.Sprintf("%s        let value = %s(littleEndian: elemPtr.load(as: %s.self))\n",
			indent, elemTypeName, elemTypeName))
		buf.WriteString(fmt.Sprintf("%s        arrayBuffer[i] = value\n", indent))
		buf.WriteString(fmt.Sprintf("%s    }\n", indent))
		buf.WriteString(fmt.Sprintf("%s    count = %sLen\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		buf.WriteString(fmt.Sprintf("%soffset += %sLen * %d\n\n", indent, fieldName, size))
	} else {
		// Variable-size types (strings, nested structs) need element-by-element decoding
		buf.WriteString(fmt.Sprintf("%svar %s = ContiguousArray<%s>()\n", indent, fieldName, elemTypeName))
		buf.WriteString(fmt.Sprintf("%s%s.reserveCapacity(%sLen)\n", indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%sfor _ in 0..<%sLen {\n", indent, fieldName))

		switch elemType.Kind {
		case parser.TypeKindPrimitive:
			if err := decodeUnsafePrimitive(buf, elemType.Name, "elem", indent+"    "); err != nil {
				return err
			}
			buf.WriteString(fmt.Sprintf("%s    %s.append(elem)\n", indent, fieldName))

		case parser.TypeKindNamed:
			elemStructName := ToSwiftName(elemType.Name)
			buf.WriteString(fmt.Sprintf("%s    let elem = try %s.decode(from: Array(bytes[offset...]))\n",
				indent, elemStructName))
			buf.WriteString(fmt.Sprintf("%s    offset += elem.encodedSize()\n", indent))
			buf.WriteString(fmt.Sprintf("%s    %s.append(elem)\n", indent, fieldName))

		default:
			return fmt.Errorf("unsupported array element type for field %s", field.Name)
		}

		buf.WriteString(fmt.Sprintf("%s}\n", indent))
	}

	return nil
}

// generateUnsafeOptionalDecode generates unsafe code to decode an optional field
func generateUnsafeOptionalDecode(buf *strings.Builder, field parser.Field, indent string) error {
	fieldName := toSwiftFieldName(field.Name)

	// Decode presence flag
	buf.WriteString(fmt.Sprintf("%s// Decode optional %s\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%sguard offset < bufferSize else { throw SDPDecodeError.insufficientData }\n", indent))
	buf.WriteString(fmt.Sprintf("%slet %sPresent = buffer[offset]\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%soffset += 1\n\n", indent))

	// Decode value if present
	buf.WriteString(fmt.Sprintf("%slet %s: %s\n", indent, fieldName, MapTypeToSwift(&field.Type)))
	buf.WriteString(fmt.Sprintf("%sif %sPresent == 1 {\n", indent, fieldName))

	// Create a temporary field with non-optional type for decoding
	innerType := &parser.TypeExpr{
		Kind:  field.Type.Kind,
		Name:  field.Type.Name,
		Elem:  field.Type.Elem,
		Boxed: field.Type.Boxed,
	}

	tempField := parser.Field{
		Name: "value",
		Type: *innerType,
	}

	// Decode the value
	switch innerType.Kind {
	case parser.TypeKindPrimitive:
		if err := decodeUnsafePrimitive(buf, innerType.Name, "value", indent+"    "); err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("%s    %s = value\n", indent, fieldName))

	case parser.TypeKindNamed:
		typeName := ToSwiftName(innerType.Name)
		buf.WriteString(fmt.Sprintf("%s    let value = try %s.decode(from: Array(bytes[offset...]))\n",
			indent, typeName))
		buf.WriteString(fmt.Sprintf("%s    offset += value.encodedSize()\n", indent))
		buf.WriteString(fmt.Sprintf("%s    %s = value\n", indent, fieldName))

	case parser.TypeKindArray:
		if err := generateUnsafeArrayDecode(buf, tempField, indent+"    "); err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("%s    %s = value\n", indent, fieldName))

	default:
		return fmt.Errorf("unsupported optional inner type for field %s", field.Name)
	}

	buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
	buf.WriteString(fmt.Sprintf("%s    %s = nil\n", indent, fieldName))
	buf.WriteString(fmt.Sprintf("%s}\n\n", indent))

	return nil
}

// canBulkCopy returns true if the type can be bulk copied (fixed-size numeric types)
func canBulkCopy(typeName string) bool {
	switch typeName {
	case "u8", "i8", "u16", "i16", "u32", "i32", "u64", "i64", "f32", "f64":
		return true
	case "bool", "str":
		return false
	default:
		return false
	}
}
