package swift

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateStructs generates Swift struct definitions for all types in the schema
func GenerateStructs(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	if len(schema.Structs) == 0 {
		return "", fmt.Errorf("schema has no structs")
	}

	var out strings.Builder

	out.WriteString("// Generated by sdp-gen - DO NOT EDIT\n\n")
	// No imports needed - using native Swift types only

	// Generate each struct
	for i, structDef := range schema.Structs {
		// Add blank line between structs (except before first)
		if i > 0 {
			out.WriteString("\n")
		}

		if err := generateStruct(&out, structDef); err != nil {
			return "", err
		}
	}

	return out.String(), nil
}

// generateStruct generates a single Swift struct definition
func generateStruct(out *strings.Builder, s parser.Struct) error {
	structName := ToSwiftName(s.Name)

	// Generate struct documentation if available
	if s.Comment != "" {
		out.WriteString(fmt.Sprintf("/// %s %s\n", structName, s.Comment))
	}

	// Struct definition
	out.WriteString(fmt.Sprintf("public struct %s {\n", structName))

	// Generate fields
	for _, field := range s.Fields {
		if err := generateField(out, field); err != nil {
			return fmt.Errorf("struct %q, field %q: %w", s.Name, field.Name, err)
		}
	}

	out.WriteString("}\n")
	return nil
}

// generateField generates a single field in a Swift struct
func generateField(out *strings.Builder, field parser.Field) error {
	fieldName := toSwiftFieldName(field.Name)
	fieldType := mapFieldType(&field.Type)

	// Field documentation
	if field.Comment != "" {
		out.WriteString(fmt.Sprintf("    /// %s %s\n", fieldName, field.Comment))
	}

	// Public var declaration
	out.WriteString(fmt.Sprintf("    public var %s: %s\n", fieldName, fieldType))
	return nil
}

// mapFieldType converts a parser.TypeExpr to a Swift type string
func mapFieldType(t *parser.TypeExpr) string {
	// Handle optional types
	if t.Optional {
		inner := &parser.TypeExpr{
			Kind:  t.Kind,
			Name:  t.Name,
			Elem:  t.Elem,
			Boxed: t.Boxed,
		}
		return fmt.Sprintf("%s?", mapFieldType(inner))
	}

	// Handle array types
	if t.Kind == parser.TypeKindArray && t.Elem != nil {
		elemType := mapFieldType(t.Elem)
		return fmt.Sprintf("[%s]", elemType)
	}

	// Handle primitive types
	if t.Kind == parser.TypeKindPrimitive {
		return mapPrimitiveToSwift(t.Name)
	}

	// Handle named types (user-defined structs)
	if t.Kind == parser.TypeKindNamed {
		return ToSwiftName(t.Name)
	}

	return "UnknownType"
}
