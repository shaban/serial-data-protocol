package rustexp

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateEncode generates encode.rs with slice-based encoding.
// This is the fast path for IPC/byte mode - uses wire_slice module
// for maximum performance (4x faster than trait API).
func GenerateEncode(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	buf.WriteString("// Code generated by sdp-gen. DO NOT EDIT.\n\n")
	buf.WriteString("use super::types::*;\n")
	buf.WriteString("use super::wire_slice::{self, SliceResult as Result};\n\n")

	// Generate encode implementation for each struct
	for _, s := range schema.Structs {
		if err := generateStructEncode(&buf, &s); err != nil {
			return "", fmt.Errorf("failed to generate encode for %s: %w", s.Name, err)
		}
	}

	return buf.String(), nil
}

// generateStructEncode generates the encode_to_slice method for a struct
func generateStructEncode(buf *strings.Builder, s *parser.Struct) error {
	buf.WriteString(fmt.Sprintf("impl %s {\n", s.Name))

	// Generate encode_to_slice (slice API - fast path for IPC)
	buf.WriteString("    /// Encode to a byte slice (IPC mode - fast path)\n")
	buf.WriteString("    /// Returns the number of bytes written\n")
	buf.WriteString("    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {\n")
	buf.WriteString("        let mut offset = 0;\n\n")

	// Encode each field
	for _, field := range s.Fields {
		if err := generateFieldEncode(buf, &field, "        "); err != nil {
			return err
		}
	}

	buf.WriteString("\n        Ok(offset)\n")
	buf.WriteString("    }\n")

	// Generate encoded_size helper
	buf.WriteString("\n")
	if err := generateEncodedSize(buf, s); err != nil {
		return err
	}

	buf.WriteString("}\n\n")

	return nil
}

// generateFieldEncode generates encoding code for a single field
func generateFieldEncode(buf *strings.Builder, field *parser.Field, indent string) error {
	fieldName := ToRustName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		return generateOptionalEncode(buf, field, indent)
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		return generateArrayEncode(buf, field, indent)
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		wireType := WireTypeToRust(field.Type.Name)
		if wireType == "" {
			return fmt.Errorf("unknown primitive type: %s", field.Type.Name)
		}

		fixedSize := FixedSize(field.Type.Name)
		if fixedSize > 0 {
			// Fixed-size primitive
			buf.WriteString(fmt.Sprintf("%swire_slice::encode_%s(buf, offset, self.%s)?;\n",
				indent, wireType, fieldName))
			buf.WriteString(fmt.Sprintf("%soffset += %d;\n", indent, fixedSize))
		} else {
			// Variable-size (string, bytes)
			buf.WriteString(fmt.Sprintf("%slet written = wire_slice::encode_%s(buf, offset, &self.%s)?;\n",
				indent, wireType, fieldName))
			buf.WriteString(fmt.Sprintf("%soffset += written;\n", indent))
		}
	case parser.TypeKindNamed:
		// Nested struct
		buf.WriteString(fmt.Sprintf("%slet written = self.%s.encode_to_slice(&mut buf[offset..])?;\n",
			indent, fieldName))
		buf.WriteString(fmt.Sprintf("%soffset += written;\n", indent))
	}

	return nil
}

// generateArrayEncode generates encoding code for array fields
func generateArrayEncode(buf *strings.Builder, field *parser.Field, indent string) error {
	fieldName := ToRustName(field.Name)
	elemType := field.Type.Elem

	if elemType == nil {
		return fmt.Errorf("array field %s has no element type", field.Name)
	}

	// Encode array length
	buf.WriteString(fmt.Sprintf("%swire_slice::encode_u32(buf, offset, self.%s.len() as u32)?;\n",
		indent, fieldName))
	buf.WriteString(fmt.Sprintf("%soffset += 4;\n", indent))

	// Check if we can use bulk copy optimization for primitive integer arrays
	if elemType.Kind == parser.TypeKindPrimitive && CanUseBulkCopy(elemType.Name) {
		generateBulkArrayEncode(buf, elemType.Name, fieldName, indent)
		return nil
	}

	// Fall back to element-by-element encoding for complex types
	buf.WriteString(fmt.Sprintf("%sfor item in &self.%s {\n", indent, fieldName))

	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		wireType := WireTypeToRust(elemType.Name)
		fixedSize := FixedSize(elemType.Name)

		if fixedSize > 0 {
			// Fixed-size element
			buf.WriteString(fmt.Sprintf("%s    wire_slice::encode_%s(buf, offset, *item)?;\n",
				indent, wireType))
			buf.WriteString(fmt.Sprintf("%s    offset += %d;\n", indent, fixedSize))
		} else {
			// Variable-size element (string, bytes)
			buf.WriteString(fmt.Sprintf("%s    let written = wire_slice::encode_%s(buf, offset, item)?;\n",
				indent, wireType))
			buf.WriteString(fmt.Sprintf("%s    offset += written;\n", indent))
		}
	case parser.TypeKindNamed:
		// Array of structs
		buf.WriteString(fmt.Sprintf("%s    let written = item.encode_to_slice(&mut buf[offset..])?;\n", indent))
		buf.WriteString(fmt.Sprintf("%s    offset += written;\n", indent))
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// generateBulkArrayEncode generates optimized bulk copy code for primitive integer arrays
func generateBulkArrayEncode(buf *strings.Builder, elemType, fieldName, indent string) {
	buf.WriteString(fmt.Sprintf("%s// Bulk encode optimization for primitive arrays\n", indent))
	buf.WriteString(fmt.Sprintf("%sif !self.%s.is_empty() {\n", indent, fieldName))

	if elemType == "u8" || elemType == "i8" {
		// Single-byte types: direct slice copy
		buf.WriteString(fmt.Sprintf("%s    let src = if std::mem::size_of::<i8>() == 1 {\n", indent))
		buf.WriteString(fmt.Sprintf("%s        unsafe { std::slice::from_raw_parts(self.%s.as_ptr() as *const u8, self.%s.len()) }\n",
			indent, fieldName, fieldName))
		buf.WriteString(fmt.Sprintf("%s    } else { unreachable!() };\n", indent))
		buf.WriteString(fmt.Sprintf("%s    wire_slice::check_bounds(buf, offset, src.len())?;\n", indent))
		buf.WriteString(fmt.Sprintf("%s    buf[offset..offset + src.len()].copy_from_slice(src);\n", indent))
		buf.WriteString(fmt.Sprintf("%s    offset += src.len();\n", indent))
	} else {
		// Multi-byte types: use bytemuck for zero-copy byte view
		buf.WriteString(fmt.Sprintf("%s    let bytes = bytemuck::cast_slice(&self.%s);\n", indent, fieldName))
		buf.WriteString(fmt.Sprintf("%s    wire_slice::check_bounds(buf, offset, bytes.len())?;\n", indent))
		buf.WriteString(fmt.Sprintf("%s    buf[offset..offset + bytes.len()].copy_from_slice(bytes);\n", indent))
		buf.WriteString(fmt.Sprintf("%s    offset += bytes.len();\n", indent))
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))
}

// generateOptionalEncode generates encoding code for optional fields
func generateOptionalEncode(buf *strings.Builder, field *parser.Field, indent string) error {
	fieldName := ToRustName(field.Name)

	// Encode presence flag
	buf.WriteString(fmt.Sprintf("%swire_slice::encode_bool(buf, offset, self.%s.is_some())?;\n",
		indent, fieldName))
	buf.WriteString(fmt.Sprintf("%soffset += 1;\n", indent))

	// Encode value if present
	buf.WriteString(fmt.Sprintf("%sif let Some(ref value) = self.%s {\n", indent, fieldName))

	// Create a temporary field for the inner value
	innerField := *field
	innerField.Type.Optional = false

	// Generate encoding for the inner type
	innerIndent := indent + "    "

	if innerField.Type.Kind == parser.TypeKindArray {
		return fmt.Errorf("optional arrays not supported (field %s)", field.Name)
	}

	switch innerField.Type.Kind {
	case parser.TypeKindPrimitive:
		wireType := WireTypeToRust(innerField.Type.Name)
		fixedSize := FixedSize(innerField.Type.Name)

		if fixedSize > 0 {
			buf.WriteString(fmt.Sprintf("%swire_slice::encode_%s(buf, offset, *value)?;\n",
				innerIndent, wireType))
			buf.WriteString(fmt.Sprintf("%soffset += %d;\n", innerIndent, fixedSize))
		} else {
			buf.WriteString(fmt.Sprintf("%slet written = wire_slice::encode_%s(buf, offset, value)?;\n",
				innerIndent, wireType))
			buf.WriteString(fmt.Sprintf("%soffset += written;\n", innerIndent))
		}
	case parser.TypeKindNamed:
		buf.WriteString(fmt.Sprintf("%slet written = value.encode_to_slice(&mut buf[offset..])?;\n", innerIndent))
		buf.WriteString(fmt.Sprintf("%soffset += written;\n", innerIndent))
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// generateEncodedSize generates the encoded_size helper method
func generateEncodedSize(buf *strings.Builder, s *parser.Struct) error {
	buf.WriteString("    /// Calculate the exact size needed for encoding\n")
	buf.WriteString("    pub fn encoded_size(&self) -> usize {\n")
	buf.WriteString("        let mut size = 0;\n\n")

	for _, field := range s.Fields {
		if err := generateFieldSize(buf, &field, "        "); err != nil {
			return err
		}
	}

	buf.WriteString("\n        size\n")
	buf.WriteString("    }\n")

	return nil
}

// generateFieldSize generates size calculation for a field
func generateFieldSize(buf *strings.Builder, field *parser.Field, indent string) error {
	fieldName := ToRustName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		buf.WriteString(fmt.Sprintf("%ssize += 1; // presence flag\n", indent))
		buf.WriteString(fmt.Sprintf("%sif let Some(ref value) = self.%s {\n", indent, fieldName))

		// Calculate inner size based on type
		innerIndent := indent + "    "
		innerType := field.Type
		innerType.Optional = false

		switch innerType.Kind {
		case parser.TypeKindPrimitive:
			fixedSize := FixedSize(innerType.Name)
			if fixedSize > 0 {
				buf.WriteString(fmt.Sprintf("%ssize += %d;\n", innerIndent, fixedSize))
			} else if innerType.Name == "str" {
				buf.WriteString(fmt.Sprintf("%ssize += 4 + value.len();\n", innerIndent))
			} else if innerType.Name == "bytes" {
				buf.WriteString(fmt.Sprintf("%ssize += 4 + value.len();\n", innerIndent))
			}
		case parser.TypeKindNamed:
			// For nested structs in optional
			buf.WriteString(fmt.Sprintf("%ssize += value.encoded_size();\n", innerIndent))
		}

		buf.WriteString(fmt.Sprintf("%s}\n", indent))
		return nil
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		buf.WriteString(fmt.Sprintf("%ssize += 4; // array length\n", indent))

		elemType := field.Type.Elem
		if elemType == nil {
			return fmt.Errorf("array field %s has no element type", field.Name)
		}

		switch elemType.Kind {
		case parser.TypeKindPrimitive:
			fixedSize := FixedSize(elemType.Name)
			if fixedSize > 0 {
				buf.WriteString(fmt.Sprintf("%ssize += self.%s.len() * %d;\n", indent, fieldName, fixedSize))
			} else if elemType.Name == "str" {
				buf.WriteString(fmt.Sprintf("%sfor item in &self.%s {\n", indent, fieldName))
				buf.WriteString(fmt.Sprintf("%s    size += 4 + item.len(); // length + bytes\n", indent))
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			} else if elemType.Name == "bytes" {
				buf.WriteString(fmt.Sprintf("%sfor item in &self.%s {\n", indent, fieldName))
				buf.WriteString(fmt.Sprintf("%s    size += 4 + item.len(); // length + bytes\n", indent))
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			}
		case parser.TypeKindNamed:
			buf.WriteString(fmt.Sprintf("%sfor item in &self.%s {\n", indent, fieldName))
			buf.WriteString(fmt.Sprintf("%s    size += item.encoded_size();\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		}

		return nil
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		fixedSize := FixedSize(field.Type.Name)
		if fixedSize > 0 {
			buf.WriteString(fmt.Sprintf("%ssize += %d; // %s\n", indent, fixedSize, field.Type.Name))
		} else if field.Type.Name == "str" {
			buf.WriteString(fmt.Sprintf("%ssize += 4 + self.%s.len(); // length + bytes\n", indent, fieldName))
		} else if field.Type.Name == "bytes" {
			buf.WriteString(fmt.Sprintf("%ssize += 4 + self.%s.len(); // length + bytes\n", indent, fieldName))
		}
	case parser.TypeKindNamed:
		// Nested struct
		buf.WriteString(fmt.Sprintf("%ssize += self.%s.encoded_size();\n", indent, fieldName))
	}

	return nil
}
