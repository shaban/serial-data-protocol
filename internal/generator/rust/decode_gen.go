package rust

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateDecode generates decode.rs with slice-based decoding.
// This is the fast path for IPC/byte mode - uses wire_slice module.
func GenerateDecode(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	buf.WriteString("// Code generated by sdp-gen. DO NOT EDIT.\n\n")
	buf.WriteString("use super::types::*;\n")
	buf.WriteString("use sdp::wire_slice::{self, Result};\n\n")

	// Generate decode implementation for each struct
	for _, s := range schema.Structs {
		if err := generateStructDecode(&buf, &s); err != nil {
			return "", fmt.Errorf("failed to generate decode for %s: %w", s.Name, err)
		}
	}

	return buf.String(), nil
}

// generateStructDecode generates the decode_from_slice method for a struct
func generateStructDecode(buf *strings.Builder, s *parser.Struct) error {
	buf.WriteString(fmt.Sprintf("impl %s {\n", s.Name))

	// Generate decode_from_slice (slice API - fast path for IPC)
	buf.WriteString("    /// Decode from a byte slice (IPC mode - fast path)\n")
	buf.WriteString("    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {\n")
	buf.WriteString("        let mut offset = 0;\n\n")

	// Decode each field
	for _, field := range s.Fields {
		if err := generateFieldDecode(buf, &field, "        "); err != nil {
			return err
		}
	}

	// Construct and return the struct
	buf.WriteString("\n        Ok(Self {\n")
	for _, field := range s.Fields {
		fieldName := ToRustName(field.Name)
		buf.WriteString(fmt.Sprintf("            %s,\n", fieldName))
	}
	buf.WriteString("        })\n")
	buf.WriteString("    }\n")

	buf.WriteString("}\n\n")

	return nil
}

// generateFieldDecode generates decoding code for a single field
func generateFieldDecode(buf *strings.Builder, field *parser.Field, indent string) error {
	fieldName := ToRustName(field.Name)

	// Handle optional fields
	if field.Type.Optional {
		return generateOptionalDecode(buf, field, indent)
	}

	// Handle arrays
	if field.Type.Kind == parser.TypeKindArray {
		return generateArrayDecode(buf, field, indent)
	}

	// Handle primitives and named types
	switch field.Type.Kind {
	case parser.TypeKindPrimitive:
		wireType := WireTypeToRust(field.Type.Name)
		if wireType == "" {
			return fmt.Errorf("unknown primitive type: %s", field.Type.Name)
		}

		fixedSize := FixedSize(field.Type.Name)
		if fixedSize > 0 {
			// Fixed-size primitive
			buf.WriteString(fmt.Sprintf("%slet %s = wire_slice::decode_%s(buf, offset)?;\n",
				indent, fieldName, wireType))
			buf.WriteString(fmt.Sprintf("%soffset += %d;\n", indent, fixedSize))
		} else {
			// Variable-size (string, bytes)
			buf.WriteString(fmt.Sprintf("%slet (%s, consumed) = wire_slice::decode_%s(buf, offset)?;\n",
				indent, fieldName, wireType))
			buf.WriteString(fmt.Sprintf("%soffset += consumed;\n", indent))
		}
	case parser.TypeKindNamed:
		// Nested struct
		buf.WriteString(fmt.Sprintf("%slet %s = %s::decode_from_slice(&buf[offset..])?;\n",
			indent, fieldName, field.Type.Name))
		buf.WriteString(fmt.Sprintf("%soffset += %s.encoded_size();\n", indent, fieldName))
	}

	return nil
}

// generateArrayDecode generates decoding code for array fields
func generateArrayDecode(buf *strings.Builder, field *parser.Field, indent string) error {
	fieldName := ToRustName(field.Name)
	elemType := field.Type.Elem

	if elemType == nil {
		return fmt.Errorf("array field %s has no element type", field.Name)
	}

	// Decode array length
	buf.WriteString(fmt.Sprintf("%slet array_len = wire_slice::decode_u32(buf, offset)? as usize;\n", indent))
	buf.WriteString(fmt.Sprintf("%soffset += 4;\n", indent))

	// Create vector with capacity
	buf.WriteString(fmt.Sprintf("%slet mut %s = Vec::with_capacity(array_len);\n", indent, fieldName))

	// Decode array elements
	buf.WriteString(fmt.Sprintf("%sfor _ in 0..array_len {\n", indent))

	switch elemType.Kind {
	case parser.TypeKindPrimitive:
		wireType := WireTypeToRust(elemType.Name)
		fixedSize := FixedSize(elemType.Name)

		if fixedSize > 0 {
			// Fixed-size element
			buf.WriteString(fmt.Sprintf("%s    let item = wire_slice::decode_%s(buf, offset)?;\n",
				indent, wireType))
			buf.WriteString(fmt.Sprintf("%s    offset += %d;\n", indent, fixedSize))
		} else {
			// Variable-size element (string, bytes)
			buf.WriteString(fmt.Sprintf("%s    let (item, consumed) = wire_slice::decode_%s(buf, offset)?;\n",
				indent, wireType))
			buf.WriteString(fmt.Sprintf("%s    offset += consumed;\n", indent))
		}

		buf.WriteString(fmt.Sprintf("%s    %s.push(item);\n", indent, fieldName))
	case parser.TypeKindNamed:
		// Array of structs
		buf.WriteString(fmt.Sprintf("%s    let item = %s::decode_from_slice(&buf[offset..])?;\n",
			indent, elemType.Name))
		buf.WriteString(fmt.Sprintf("%s    offset += item.encoded_size();\n", indent))
		buf.WriteString(fmt.Sprintf("%s    %s.push(item);\n", indent, fieldName))
	}

	buf.WriteString(fmt.Sprintf("%s}\n", indent))

	return nil
}

// generateOptionalDecode generates decoding code for optional fields
func generateOptionalDecode(buf *strings.Builder, field *parser.Field, indent string) error {
	fieldName := ToRustName(field.Name)

	// Decode presence flag
	buf.WriteString(fmt.Sprintf("%slet present = wire_slice::decode_bool(buf, offset)?;\n", indent))
	buf.WriteString(fmt.Sprintf("%soffset += 1;\n", indent))

	// Decode value if present
	buf.WriteString(fmt.Sprintf("%slet %s = if present {\n", indent, fieldName))

	// Create a temporary field for the inner value
	innerField := *field
	innerField.Type.Optional = false

	// Generate decoding for the inner type
	innerIndent := indent + "    "

	if innerField.Type.Kind == parser.TypeKindArray {
		return fmt.Errorf("optional arrays not supported (field %s)", field.Name)
	}

	switch innerField.Type.Kind {
	case parser.TypeKindPrimitive:
		wireType := WireTypeToRust(innerField.Type.Name)
		fixedSize := FixedSize(innerField.Type.Name)

		if fixedSize > 0 {
			buf.WriteString(fmt.Sprintf("%slet value = wire_slice::decode_%s(buf, offset)?;\n",
				innerIndent, wireType))
			buf.WriteString(fmt.Sprintf("%soffset += %d;\n", innerIndent, fixedSize))
		} else {
			buf.WriteString(fmt.Sprintf("%slet (value, consumed) = wire_slice::decode_%s(buf, offset)?;\n",
				innerIndent, wireType))
			buf.WriteString(fmt.Sprintf("%soffset += consumed;\n", innerIndent))
		}

		buf.WriteString(fmt.Sprintf("%sSome(value)\n", innerIndent))
	case parser.TypeKindNamed:
		buf.WriteString(fmt.Sprintf("%slet value = %s::decode_from_slice(&buf[offset..])?;\n",
			innerIndent, innerField.Type.Name))
		buf.WriteString(fmt.Sprintf("%soffset += value.encoded_size();\n", innerIndent))
		buf.WriteString(fmt.Sprintf("%sSome(value)\n", innerIndent))
	}

	buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
	buf.WriteString(fmt.Sprintf("%s    None\n", indent))
	buf.WriteString(fmt.Sprintf("%s};\n", indent))

	return nil
}
