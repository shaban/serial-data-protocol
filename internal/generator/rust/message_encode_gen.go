package rust

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateMessageEncoders generates message mode encoder functions for Rust.
// Each function adds a 10-byte header: [magic:3][version:1][type_id:2][length:4][payload:N]
func GenerateMessageEncoders(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	// File header
	buf.WriteString("// Auto-generated by sdp-gen. DO NOT EDIT.\n")
	buf.WriteString("// Message mode encoders - self-describing messages with type headers.\n\n")

	buf.WriteString("use byteorder::{ByteOrder, LittleEndian};\n")
	buf.WriteString("use crate::types::*;\n")
	buf.WriteString("use crate::encode::*;\n\n")

	// Message constants
	buf.WriteString("/// Message mode constants\n")
	buf.WriteString("pub const MESSAGE_HEADER_SIZE: usize = 10;\n")
	buf.WriteString("pub const MESSAGE_MAGIC: &[u8; 3] = b\"SDP\";\n")
	buf.WriteString("pub const MESSAGE_VERSION: u8 = b'2';  // ASCII '2' for v0.2.0\n\n")

	// Generate encoder for each struct
	for i, s := range schema.Structs {
		typeID := uint16(i + 1) // Type IDs start at 1

		if err := generateMessageEncoder(&buf, &s, typeID); err != nil {
			return "", fmt.Errorf("struct %q: %w", s.Name, err)
		}

		buf.WriteString("\n")
	}

	return buf.String(), nil
}

// generateMessageEncoder generates an encode_X_message function for a single struct.
func generateMessageEncoder(buf *strings.Builder, s *parser.Struct, typeID uint16) error {
	structName := s.Name // Keep PascalCase for type names
	funcName := fmt.Sprintf("encode_%s_message", toSnakeCase(s.Name))

	// Doc comment
	buf.WriteString("/// Encodes a ")
	buf.WriteString(structName)
	buf.WriteString(" to self-describing message format.\n")
	buf.WriteString("///\n")
	buf.WriteString("/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]\n")
	buf.WriteString("/// - Type ID: ")
	buf.WriteString(fmt.Sprintf("%d\n", typeID))
	buf.WriteString("/// - Header: 10 bytes\n")
	buf.WriteString("/// - Total size: 10 + payload_size bytes\n")
	buf.WriteString("///\n")
	buf.WriteString("/// This format is suitable for:\n")
	buf.WriteString("/// - Persistence (databases, files)\n")
	buf.WriteString("/// - Network transmission (RPC, queues)\n")
	buf.WriteString("/// - Cross-service communication\n")
	buf.WriteString("pub fn ")
	buf.WriteString(funcName)
	buf.WriteString("(src: &")
	buf.WriteString(structName)
	buf.WriteString(") -> Vec<u8> {\n")

	// Encode payload (without header) using struct method
	buf.WriteString("    // Encode payload using byte mode encoder\n")
	buf.WriteString("    let payload_size = src.encoded_size();\n")
	buf.WriteString("    let mut payload = vec![0u8; payload_size];\n")
	buf.WriteString("    src.encode_to_slice(&mut payload).expect(\"encoding failed\");\n\n")

	// Allocate message buffer
	buf.WriteString("    // Allocate message buffer (header + payload)\n")
	buf.WriteString("    let message_size = MESSAGE_HEADER_SIZE + payload.len();\n")
	buf.WriteString("    let mut message = vec![0u8; message_size];\n\n")

	// Write header
	buf.WriteString("    // Write header\n")
	buf.WriteString("    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'\n")
	buf.WriteString("    message[3] = MESSAGE_VERSION;                  // Protocol version '2'\n")
	buf.WriteString(fmt.Sprintf("    LittleEndian::write_u16(&mut message[4..6], %d);  // Type ID\n", typeID))
	buf.WriteString("    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length\n\n")

	// Copy payload
	buf.WriteString("    // Copy payload\n")
	buf.WriteString("    message[10..].copy_from_slice(&payload);\n\n")

	buf.WriteString("    message\n")
	buf.WriteString("}\n")

	return nil
}
