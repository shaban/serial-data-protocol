package rust

import (
	"fmt"
	"strings"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// GenerateMessageDecoders generates message mode decoder functions and enum dispatcher for Rust.
func GenerateMessageDecoders(schema *parser.Schema) (string, error) {
	if schema == nil {
		return "", fmt.Errorf("schema is nil")
	}

	var buf strings.Builder

	// File header
	buf.WriteString("// Auto-generated by sdp-gen. DO NOT EDIT.\n")
	buf.WriteString("// Message mode decoders - self-describing messages with type headers.\n\n")

	buf.WriteString("use byteorder::{ByteOrder, LittleEndian};\n")
	buf.WriteString("use crate::types::*;\n")
	buf.WriteString("use crate::decode::*;\n")
	buf.WriteString("use crate::message_encode::{MESSAGE_HEADER_SIZE, MESSAGE_MAGIC, MESSAGE_VERSION};\n\n")

	// Error types
	generateMessageErrors(&buf)
	buf.WriteString("\n")

	// Message enum
	if err := generateMessageEnum(&buf, schema); err != nil {
		return "", fmt.Errorf("enum generation: %w", err)
	}
	buf.WriteString("\n")

	// Individual decoders
	for i, s := range schema.Structs {
		typeID := uint16(i + 1)

		if err := generateMessageDecoder(&buf, &s, typeID); err != nil {
			return "", fmt.Errorf("struct %q: %w", s.Name, err)
		}

		buf.WriteString("\n")
	}

	// Dispatcher
	if err := generateMessageDispatcher(&buf, schema); err != nil {
		return "", fmt.Errorf("dispatcher generation: %w", err)
	}

	return buf.String(), nil
}

// generateMessageErrors generates error types for message mode decoding.
func generateMessageErrors(buf *strings.Builder) {
	buf.WriteString("/// Message mode errors\n")
	buf.WriteString("#[derive(Debug, Clone, PartialEq, Eq)]\n")
	buf.WriteString("pub enum MessageError {\n")
	buf.WriteString("    /// Message is too short (minimum 10 bytes required)\n")
	buf.WriteString("    MessageTooShort,\n")
	buf.WriteString("    /// Invalid magic bytes (expected 'SDP')\n")
	buf.WriteString("    InvalidMagic,\n")
	buf.WriteString("    /// Invalid protocol version (expected '2')\n")
	buf.WriteString("    InvalidVersion,\n")
	buf.WriteString("    /// Unknown message type ID\n")
	buf.WriteString("    UnknownMessageType(u16),\n")
	buf.WriteString("    /// Payload size mismatch\n")
	buf.WriteString("    PayloadSizeMismatch,\n")
	buf.WriteString("    /// Decode error (payload is invalid)\n")
	buf.WriteString("    DecodeError(String),\n")
	buf.WriteString("}\n\n")

	buf.WriteString("impl std::fmt::Display for MessageError {\n")
	buf.WriteString("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n")
	buf.WriteString("        match self {\n")
	buf.WriteString("            MessageError::MessageTooShort => write!(f, \"Message too short\"),\n")
	buf.WriteString("            MessageError::InvalidMagic => write!(f, \"Invalid magic bytes\"),\n")
	buf.WriteString("            MessageError::InvalidVersion => write!(f, \"Invalid protocol version\"),\n")
	buf.WriteString("            MessageError::UnknownMessageType(id) => write!(f, \"Unknown message type: {}\", id),\n")
	buf.WriteString("            MessageError::PayloadSizeMismatch => write!(f, \"Payload size mismatch\"),\n")
	buf.WriteString("            MessageError::DecodeError(msg) => write!(f, \"Decode error: {}\", msg),\n")
	buf.WriteString("        }\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	buf.WriteString("impl std::error::Error for MessageError {}\n")
}

// generateMessageEnum generates a Rust enum representing all message types.
func generateMessageEnum(buf *strings.Builder, schema *parser.Schema) error {
	buf.WriteString("/// Message enum representing all possible message types.\n")
	buf.WriteString("/// Use pattern matching to handle different message types.\n")
	buf.WriteString("#[derive(Debug, Clone)]\n")
	buf.WriteString("pub enum Message {\n")

	for _, s := range schema.Structs {
		structName := s.Name
		buf.WriteString("    ")
		buf.WriteString(structName)
		buf.WriteString("(")
		buf.WriteString(structName)
		buf.WriteString("),\n")
	}

	buf.WriteString("}\n")

	return nil
}

// generateMessageDecoder generates a decode_X_message function for a single struct.
func generateMessageDecoder(buf *strings.Builder, s *parser.Struct, typeID uint16) error {
	structName := s.Name
	funcName := fmt.Sprintf("decode_%s_message", toSnakeCase(s.Name))

	// Doc comment
	buf.WriteString("/// Decodes a ")
	buf.WriteString(structName)
	buf.WriteString(" from self-describing message format.\n")
	buf.WriteString("///\n")
	buf.WriteString("/// Validates the 10-byte header:\n")
	buf.WriteString("/// - Magic bytes must be 'SDP'\n")
	buf.WriteString("/// - Version must be '2'\n")
	buf.WriteString("/// - Type ID must be ")
	buf.WriteString(fmt.Sprintf("%d\n", typeID))
	buf.WriteString("/// - Payload length must match actual data\n")
	buf.WriteString("///\n")
	buf.WriteString("/// Returns an error if validation fails or payload is invalid.\n")
	buf.WriteString("pub fn ")
	buf.WriteString(funcName)
	buf.WriteString("(data: &[u8]) -> Result<")
	buf.WriteString(structName)
	buf.WriteString(", MessageError> {\n")

	// Check minimum size
	buf.WriteString("    // Check minimum message size\n")
	buf.WriteString("    if data.len() < MESSAGE_HEADER_SIZE {\n")
	buf.WriteString("        return Err(MessageError::MessageTooShort);\n")
	buf.WriteString("    }\n\n")

	// Validate magic bytes
	buf.WriteString("    // Validate magic bytes\n")
	buf.WriteString("    if &data[0..3] != MESSAGE_MAGIC {\n")
	buf.WriteString("        return Err(MessageError::InvalidMagic);\n")
	buf.WriteString("    }\n\n")

	// Validate version
	buf.WriteString("    // Validate protocol version\n")
	buf.WriteString("    if data[3] != MESSAGE_VERSION {\n")
	buf.WriteString("        return Err(MessageError::InvalidVersion);\n")
	buf.WriteString("    }\n\n")

	// Validate type ID
	buf.WriteString("    // Validate type ID\n")
	buf.WriteString("    let type_id = LittleEndian::read_u16(&data[4..6]);\n")
	buf.WriteString(fmt.Sprintf("    if type_id != %d {\n", typeID))
	buf.WriteString("        return Err(MessageError::UnknownMessageType(type_id));\n")
	buf.WriteString("    }\n\n")

	// Extract payload length
	buf.WriteString("    // Extract payload length\n")
	buf.WriteString("    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;\n\n")

	// Validate total message size
	buf.WriteString("    // Validate total message size\n")
	buf.WriteString("    let expected_size = MESSAGE_HEADER_SIZE + payload_length;\n")
	buf.WriteString("    if data.len() < expected_size {\n")
	buf.WriteString("        return Err(MessageError::PayloadSizeMismatch);\n")
	buf.WriteString("    }\n\n")

	// Extract payload
	buf.WriteString("    // Extract payload\n")
	buf.WriteString("    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];\n\n")

	// Decode payload using struct method
	buf.WriteString("    // Decode payload using byte mode decoder\n")
	buf.WriteString("    ")
	buf.WriteString(structName)
	buf.WriteString("::decode_from_slice(payload)\n")
	buf.WriteString("        .map_err(|e| MessageError::DecodeError(e.to_string()))\n")
	buf.WriteString("}\n")

	return nil
}

// generateMessageDispatcher generates a decode_message function that returns the Message enum.
func generateMessageDispatcher(buf *strings.Builder, schema *parser.Schema) error {
	buf.WriteString("/// Decodes a message and returns the appropriate Message enum variant.\n")
	buf.WriteString("///\n")
	buf.WriteString("/// This is the main entry point for decoding self-describing messages.\n")
	buf.WriteString("/// Use pattern matching on the returned Message enum to handle different types.\n")
	buf.WriteString("///\n")
	buf.WriteString("/// # Example\n")
	buf.WriteString("/// ```ignore\n")
	buf.WriteString("/// match decode_message(data)? {\n")

	// Add example for first struct
	if len(schema.Structs) > 0 {
		firstStruct := schema.Structs[0]
		buf.WriteString(fmt.Sprintf("///     Message::%s(val) => { /* handle %s */ },\n", firstStruct.Name, firstStruct.Name))
		if len(schema.Structs) > 1 {
			buf.WriteString("///     // ... other variants\n")
		}
	}

	buf.WriteString("/// }\n")
	buf.WriteString("/// ```\n")
	buf.WriteString("pub fn decode_message(data: &[u8]) -> Result<Message, MessageError> {\n")

	// Check minimum size
	buf.WriteString("    // Check minimum message size\n")
	buf.WriteString("    if data.len() < MESSAGE_HEADER_SIZE {\n")
	buf.WriteString("        return Err(MessageError::MessageTooShort);\n")
	buf.WriteString("    }\n\n")

	// Validate magic bytes
	buf.WriteString("    // Validate magic bytes\n")
	buf.WriteString("    if &data[0..3] != MESSAGE_MAGIC {\n")
	buf.WriteString("        return Err(MessageError::InvalidMagic);\n")
	buf.WriteString("    }\n\n")

	// Validate version
	buf.WriteString("    // Validate protocol version\n")
	buf.WriteString("    if data[3] != MESSAGE_VERSION {\n")
	buf.WriteString("        return Err(MessageError::InvalidVersion);\n")
	buf.WriteString("    }\n\n")

	// Extract type ID
	buf.WriteString("    // Extract type ID and dispatch to appropriate decoder\n")
	buf.WriteString("    let type_id = LittleEndian::read_u16(&data[4..6]);\n\n")

	// Match on type ID
	buf.WriteString("    match type_id {\n")

	for i, s := range schema.Structs {
		typeID := i + 1
		structName := s.Name
		decoderFunc := fmt.Sprintf("decode_%s_message", toSnakeCase(s.Name))

		buf.WriteString(fmt.Sprintf("        %d => {\n", typeID))
		buf.WriteString("            ")
		buf.WriteString(decoderFunc)
		buf.WriteString("(data).map(Message::")
		buf.WriteString(structName)
		buf.WriteString(")\n")
		buf.WriteString("        }\n")
	}

	// Default case
	buf.WriteString("        _ => Err(MessageError::UnknownMessageType(type_id)),\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n")

	return nil
}
