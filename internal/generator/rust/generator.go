// Package rust generates Rust code from SDP schemas.
// It produces high-performance, idiomatic Rust with both slice-based
// and trait-based APIs for maximum flexibility.
package rust

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/shaban/serial-data-protocol/internal/parser"
)

// Generate creates Rust code files from a parsed schema.
// It generates:
//   - lib.rs: Module declarations and re-exports
//   - types.rs: Struct definitions with derive macros
//   - encode.rs: Slice-based encoding (fast path for IPC)
//   - decode.rs: Slice-based decoding
//
// The generated code uses the sdp crate's wire_slice module for
// maximum performance (4x faster than trait-based encoding).
func Generate(schema *parser.Schema, outputDir string, verbose bool) error {
	if schema == nil {
		return fmt.Errorf("schema is nil")
	}

	if outputDir == "" {
		return fmt.Errorf("output directory is empty")
	}

	// Create output directory if needed
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	if verbose {
		fmt.Printf("Generating Rust code in %s\n", outputDir)
	}

	// Generate lib.rs
	if err := generateLib(schema, outputDir, verbose); err != nil {
		return fmt.Errorf("failed to generate lib.rs: %w", err)
	}

	// Generate types.rs
	if err := generateTypes(schema, outputDir, verbose); err != nil {
		return fmt.Errorf("failed to generate types.rs: %w", err)
	}

	// Generate encode.rs (slice API)
	if err := generateEncode(schema, outputDir, verbose); err != nil {
		return fmt.Errorf("failed to generate encode.rs: %w", err)
	}

	// Generate decode.rs (slice API)
	if err := generateDecode(schema, outputDir, verbose); err != nil {
		return fmt.Errorf("failed to generate decode.rs: %w", err)
	}

	if verbose {
		fmt.Println("Rust code generation complete")
	}

	return nil
}

// generateLib creates lib.rs with module declarations and re-exports
func generateLib(_ *parser.Schema, outputDir string, verbose bool) error {
	filepath := filepath.Join(outputDir, "lib.rs")

	var content string
	content += "// Code generated by sdp-gen. DO NOT EDIT.\n"
	content += "// https://github.com/shaban/serial-data-protocol\n\n"
	content += "mod types;\n"
	content += "mod encode;\n"
	content += "mod decode;\n\n"
	content += "pub use types::*;\n"
	content += "pub use encode::*;\n"
	content += "pub use decode::*;\n\n"
	content += "// Re-export sdp for generated code\n"
	content += "pub use sdp::wire_slice::{Error, Result};\n"

	if err := os.WriteFile(filepath, []byte(content), 0644); err != nil {
		return err
	}

	if verbose {
		fmt.Printf("  Generated lib.rs\n")
	}

	return nil
}

// generateTypes creates types.rs with struct definitions
func generateTypes(schema *parser.Schema, outputDir string, verbose bool) error {
	filepath := filepath.Join(outputDir, "types.rs")

	var content string
	content += "// Code generated by sdp-gen. DO NOT EDIT.\n\n"

	// Generate all struct definitions
	structs, err := GenerateStructs(schema)
	if err != nil {
		return err
	}

	content += structs

	if err := os.WriteFile(filepath, []byte(content), 0644); err != nil {
		return err
	}

	if verbose {
		fmt.Printf("  Generated types.rs (%d structs)\n", len(schema.Structs))
	}

	return nil
}

// generateEncode creates encode.rs with slice-based encoding
func generateEncode(schema *parser.Schema, outputDir string, verbose bool) error {
	filepath := filepath.Join(outputDir, "encode.rs")

	content, err := GenerateEncode(schema)
	if err != nil {
		return fmt.Errorf("failed to generate encode: %w", err)
	}

	if err := os.WriteFile(filepath, []byte(content), 0644); err != nil {
		return err
	}

	if verbose {
		fmt.Printf("  Generated encode.rs (%d structs)\n", len(schema.Structs))
	}

	return nil
}

// generateDecode creates decode.rs with slice-based decoding
func generateDecode(schema *parser.Schema, outputDir string, verbose bool) error {
	filepath := filepath.Join(outputDir, "decode.rs")

	content, err := GenerateDecode(schema)
	if err != nil {
		return fmt.Errorf("failed to generate decode: %w", err)
	}

	if err := os.WriteFile(filepath, []byte(content), 0644); err != nil {
		return err
	}

	if verbose {
		fmt.Printf("  Generated decode.rs (%d structs)\n", len(schema.Structs))
	}

	return nil
}
