use serde::{Deserialize, Serialize};
use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;
use std::process::Command;

/// AST types matching Go parser output
#[derive(Debug, Deserialize, Serialize)]
struct Schema {
    structs: Vec<Struct>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Struct {
    name: String,
    fields: Vec<Field>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Field {
    name: String,
    #[serde(rename = "type")]
    field_type: Type,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "kind")]
enum Type {
    #[serde(rename = "primitive")]
    Primitive { name: String },
    #[serde(rename = "array")]
    Array { element: Box<Type> },
    #[serde(rename = "struct")]
    Struct { name: String },
    #[serde(rename = "optional")]
    Optional { inner: Box<Type> },
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    
    if args.len() < 3 {
        eprintln!("Usage: sdp-gen <schema.sdp> <output_dir>");
        eprintln!("Example: sdp-gen audiounit.sdp testdata/audiounit/rust");
        std::process::exit(1);
    }

    let schema_path = &args[1];
    let output_dir = &args[2];

    // Call Go parser to get AST as JSON
    let ast_json = match get_ast_from_go(schema_path) {
        Ok(json) => json,
        Err(e) => {
            eprintln!("Error parsing schema: {}", e);
            std::process::exit(1);
        }
    };

    // Parse AST
    let schema: Schema = match serde_json::from_str(&ast_json) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Error parsing AST JSON: {}", e);
            std::process::exit(1);
        }
    };

    // Generate Rust code
    match generate_rust(&schema, output_dir) {
        Ok(()) => {
            println!("Generated Rust code in {}", output_dir);
        }
        Err(e) => {
            eprintln!("Error generating code: {}", e);
            std::process::exit(1);
        }
    }
}

/// Call Go parser to get AST as JSON
fn get_ast_from_go(schema_path: &str) -> io::Result<String> {
    // TODO: For now, use sdp-gen from Go to output JSON
    // Later: implement parser in Rust or use C bindings
    let output = Command::new("../cmd/sdp-gen/sdp-gen")
        .args(&["--ast-json", schema_path])
        .output()?;

    if !output.status.success() {
        return Err(io::Error::new(
            io::ErrorKind::Other,
            format!("Go parser failed: {}", String::from_utf8_lossy(&output.stderr)),
        ));
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Generate Rust code from schema
fn generate_rust(schema: &Schema, output_dir: &str) -> io::Result<()> {
    fs::create_dir_all(output_dir)?;

    // Generate types.rs
    let types_code = generate_types(schema);
    fs::write(format!("{}/types.rs", output_dir), types_code)?;

    // Generate encode.rs
    let encode_code = generate_encode(schema);
    fs::write(format!("{}/encode.rs", output_dir), encode_code)?;

    // Generate decode.rs
    let decode_code = generate_decode(schema);
    fs::write(format!("{}/decode.rs", output_dir), decode_code)?;

    // Generate lib.rs
    let lib_code = generate_lib(schema);
    fs::write(format!("{}/lib.rs", output_dir), lib_code)?;

    Ok(())
}

/// Generate types.rs with struct definitions
fn generate_types(schema: &Schema) -> String {
    let mut code = String::from("// Code generated by sdp-gen. DO NOT EDIT.\n\n");
    code.push_str("#![allow(dead_code)]\n\n");

    for s in &schema.structs {
        code.push_str(&format!("#[derive(Debug, Clone, PartialEq)]\n"));
        code.push_str(&format!("pub struct {} {{\n", s.name));
        
        for field in &s.fields {
            let rust_type = map_type_to_rust(&field.field_type);
            code.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
        }
        
        code.push_str("}\n\n");
    }

    code
}

/// Generate encode.rs with encoding implementations
fn generate_encode(schema: &Schema) -> String {
    let mut code = String::from("// Code generated by sdp-gen. DO NOT EDIT.\n\n");
    code.push_str("use super::types::*;\n");
    code.push_str("use sdp::wire::{Encoder, Result};\n");
    code.push_str("use std::io::Write;\n\n");

    for s in &schema.structs {
        code.push_str(&format!("impl {} {{\n", s.name));
        code.push_str("    pub fn encode<W: Write>(&self, writer: &mut W) -> Result<()> {\n");
        code.push_str("        let mut enc = Encoder::new(writer);\n");
        
        for field in &s.fields {
            code.push_str(&generate_field_encode(&field.name, &field.field_type));
        }
        
        code.push_str("        Ok(())\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
    }

    code
}

/// Generate decode.rs with decoding implementations
fn generate_decode(schema: &Schema) -> String {
    let mut code = String::from("// Code generated by sdp-gen. DO NOT EDIT.\n\n");
    code.push_str("use super::types::*;\n");
    code.push_str("use sdp::wire::{Decoder, Result};\n");
    code.push_str("use std::io::Read;\n\n");

    for s in &schema.structs {
        code.push_str(&format!("impl {} {{\n", s.name));
        code.push_str("    pub fn decode<R: Read>(reader: &mut R) -> Result<Self> {\n");
        code.push_str("        let mut dec = Decoder::new(reader);\n");
        
        for field in &s.fields {
            code.push_str(&generate_field_decode(&field.name, &field.field_type));
        }
        
        code.push_str("        Ok(Self {\n");
        for field in &s.fields {
            code.push_str(&format!("            {},\n", field.name));
        }
        code.push_str("        })\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
    }

    code
}

/// Generate lib.rs
fn generate_lib(schema: &Schema) -> String {
    let mut code = String::from("// Code generated by sdp-gen. DO NOT EDIT.\n\n");
    code.push_str("mod types;\n");
    code.push_str("mod encode;\n");
    code.push_str("mod decode;\n\n");
    code.push_str("pub use types::*;\n");
    
    code
}

/// Map SDP type to Rust type
fn map_type_to_rust(t: &Type) -> String {
    match t {
        Type::Primitive { name } => match name.as_str() {
            "bool" => "bool".to_string(),
            "u8" => "u8".to_string(),
            "u16" => "u16".to_string(),
            "u32" => "u32".to_string(),
            "u64" => "u64".to_string(),
            "f32" => "f32".to_string(),
            "f64" => "f64".to_string(),
            "string" => "String".to_string(),
            "bytes" => "Vec<u8>".to_string(),
            _ => panic!("Unknown primitive type: {}", name),
        },
        Type::Array { element } => format!("Vec<{}>", map_type_to_rust(element)),
        Type::Struct { name } => name.clone(),
        Type::Optional { inner } => format!("Option<{}>", map_type_to_rust(inner)),
    }
}

/// Generate encoding code for a field
fn generate_field_encode(field_name: &str, field_type: &Type) -> String {
    match field_type {
        Type::Primitive { name } => match name.as_str() {
            "bool" => format!("        enc.write_bool(self.{})?\n", field_name),
            "u8" => format!("        enc.write_u8(self.{})?\n", field_name),
            "u16" => format!("        enc.write_u16(self.{})?\n", field_name),
            "u32" => format!("        enc.write_u32(self.{})?\n", field_name),
            "u64" => format!("        enc.write_u64(self.{})?\n", field_name),
            "f32" => format!("        enc.write_f32(self.{})?\n", field_name),
            "f64" => format!("        enc.write_f64(self.{})?\n", field_name),
            "string" => format!("        enc.write_string(&self.{})?\n", field_name),
            "bytes" => format!("        enc.write_bytes(&self.{})?\n", field_name),
            _ => panic!("Unknown primitive: {}", name),
        },
        Type::Array { element } => {
            let elem_encode = generate_array_element_encode(element);
            format!(
                "        enc.write_u32(self.{}.len() as u32)?;\n        for item in &self.{} {{\n{}\n        }}\n",
                field_name, field_name, elem_encode
            )
        }
        Type::Struct { .. } => {
            format!("        self.{}.encode(&mut enc.writer)?;\n", field_name)
        }
        Type::Optional { inner } => {
            format!(
                "        enc.write_bool(self.{}.is_some())?;\n        if let Some(ref value) = self.{} {{\n{}\n        }}\n",
                field_name,
                field_name,
                generate_optional_encode("value", inner)
            )
        }
    }
}

fn generate_array_element_encode(element_type: &Type) -> String {
    match element_type {
        Type::Primitive { name } => match name.as_str() {
            "bool" => "            enc.write_bool(*item)?;".to_string(),
            "u8" => "            enc.write_u8(*item)?;".to_string(),
            "u16" => "            enc.write_u16(*item)?;".to_string(),
            "u32" => "            enc.write_u32(*item)?;".to_string(),
            "u64" => "            enc.write_u64(*item)?;".to_string(),
            "f32" => "            enc.write_f32(*item)?;".to_string(),
            "f64" => "            enc.write_f64(*item)?;".to_string(),
            "string" => "            enc.write_string(item)?;".to_string(),
            "bytes" => "            enc.write_bytes(item)?;".to_string(),
            _ => panic!("Unknown primitive: {}", name),
        },
        Type::Struct { .. } => "            item.encode(&mut enc.writer)?;".to_string(),
        _ => panic!("Unsupported array element type"),
    }
}

fn generate_optional_encode(var_name: &str, inner_type: &Type) -> String {
    match inner_type {
        Type::Primitive { name } => match name.as_str() {
            "bool" => format!("            enc.write_bool(*{})?;", var_name),
            "u8" => format!("            enc.write_u8(*{})?;", var_name),
            "u16" => format!("            enc.write_u16(*{})?;", var_name),
            "u32" => format!("            enc.write_u32(*{})?;", var_name),
            "u64" => format!("            enc.write_u64(*{})?;", var_name),
            "f32" => format!("            enc.write_f32(*{})?;", var_name),
            "f64" => format!("            enc.write_f64(*{})?;", var_name),
            "string" => format!("            enc.write_string({})?;", var_name),
            "bytes" => format!("            enc.write_bytes({})?;", var_name),
            _ => panic!("Unknown primitive: {}", name),
        },
        Type::Struct { .. } => format!("            {}.encode(&mut enc.writer)?;", var_name),
        _ => panic!("Unsupported optional type"),
    }
}

/// Generate decoding code for a field
fn generate_field_decode(field_name: &str, field_type: &Type) -> String {
    match field_type {
        Type::Primitive { name } => match name.as_str() {
            "bool" => format!("        let {} = dec.read_bool()?;\n", field_name),
            "u8" => format!("        let {} = dec.read_u8()?;\n", field_name),
            "u16" => format!("        let {} = dec.read_u16()?;\n", field_name),
            "u32" => format!("        let {} = dec.read_u32()?;\n", field_name),
            "u64" => format!("        let {} = dec.read_u64()?;\n", field_name),
            "f32" => format!("        let {} = dec.read_f32()?;\n", field_name),
            "f64" => format!("        let {} = dec.read_f64()?;\n", field_name),
            "string" => format!("        let {} = dec.read_string()?;\n", field_name),
            "bytes" => format!("        let {} = dec.read_bytes()?;\n", field_name),
            _ => panic!("Unknown primitive: {}", name),
        },
        Type::Array { element } => {
            let elem_decode = generate_array_element_decode(element);
            format!(
                "        let len = dec.read_u32()?;\n        let mut {} = Vec::with_capacity(len as usize);\n        for _ in 0..len {{\n{}\n            {}.push(item);\n        }}\n",
                field_name, elem_decode, field_name
            )
        }
        Type::Struct { name } => {
            format!("        let {} = {}::decode(&mut dec.reader)?;\n", field_name, name)
        }
        Type::Optional { inner } => {
            format!(
                "        let {} = if dec.read_bool()? {{\n{}\n            Some(value)\n        }} else {{\n            None\n        }};\n",
                field_name,
                generate_optional_decode(inner)
            )
        }
    }
}

fn generate_array_element_decode(element_type: &Type) -> String {
    match element_type {
        Type::Primitive { name } => match name.as_str() {
            "bool" => "            let item = dec.read_bool()?;".to_string(),
            "u8" => "            let item = dec.read_u8()?;".to_string(),
            "u16" => "            let item = dec.read_u16()?;".to_string(),
            "u32" => "            let item = dec.read_u32()?;".to_string(),
            "u64" => "            let item = dec.read_u64()?;".to_string(),
            "f32" => "            let item = dec.read_f32()?;".to_string(),
            "f64" => "            let item = dec.read_f64()?;".to_string(),
            "string" => "            let item = dec.read_string()?;".to_string(),
            "bytes" => "            let item = dec.read_bytes()?;".to_string(),
            _ => panic!("Unknown primitive: {}", name),
        },
        Type::Struct { name } => format!("            let item = {}::decode(&mut dec.reader)?;", name),
        _ => panic!("Unsupported array element type"),
    }
}

fn generate_optional_decode(inner_type: &Type) -> String {
    match inner_type {
        Type::Primitive { name } => match name.as_str() {
            "bool" => "            let value = dec.read_bool()?;".to_string(),
            "u8" => "            let value = dec.read_u8()?;".to_string(),
            "u16" => "            let value = dec.read_u16()?;".to_string(),
            "u32" => "            let value = dec.read_u32()?;".to_string(),
            "u64" => "            let value = dec.read_u64()?;".to_string(),
            "f32" => "            let value = dec.read_f32()?;".to_string(),
            "f64" => "            let value = dec.read_f64()?;".to_string(),
            "string" => "            let value = dec.read_string()?;".to_string(),
            "bytes" => "            let value = dec.read_bytes()?;".to_string(),
            _ => panic!("Unknown primitive: {}", name),
        },
        Type::Struct { name } => format!("            let value = {}::decode(&mut dec.reader)?;", name),
        _ => panic!("Unsupported optional type"),
    }
}
