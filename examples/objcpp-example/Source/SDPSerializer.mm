// SDPSerializer.mm
// Implementation using SDP C++ library

#import "SDPSerializer.h"

// C++ headers
#include <string>
#include <vector>

// SDP generated headers (generated by sdp-gen)
#include "types.hpp"
#include "encode.hpp"
#include "decode.hpp"

// Helper functions
#include "objcpp_helpers.hpp"

@implementation SDPSerializer

+ (nullable NSData *)encodeUser:(User *)user error:(NSError **)error {
    if (!user) {
        if (error) {
            *error = sdp::makeEncodeError(@"User object is nil");
        }
        return nil;
    }
    
    // Validate input
    if (!sdp::isValidStringLength(user.username) ||
        !sdp::isValidStringLength(user.email) ||
        !sdp::isValidArrayCount(user.tags)) {
        if (error) {
            *error = sdp::makeValidationError(@"User data exceeds SDP limits");
        }
        return nil;
    }
    
    @try {
        // Convert Objective-C User to C++ struct
        sdp::User cppUser{
            .id = sdp::toUInt32(user.userId),
            .username = sdp::toString(user.username),
            .email = sdp::toString(user.email),
            .age = (uint8_t)user.age,
            .is_active = sdp::toBool(user.isActive),
            .tags = sdp::toStringVector(user.tags),
            .metadata = nullptr // Handle optional separately
        };
        
        // Handle optional metadata
        if (user.metadata) {
            cppUser.metadata = new sdp::UserMetadata{
                .created_at = user.metadata.createdAt,
                .updated_at = user.metadata.updatedAt,
                .login_count = sdp::toUInt32(user.metadata.loginCount)
            };
        }
        
        // Encode to bytes
        std::vector<uint8_t> bytes = sdp::EncodeUser(cppUser);
        
        // Clean up optional field
        if (cppUser.metadata) {
            delete cppUser.metadata;
        }
        
        // Convert to NSData
        return sdp::toNSData(bytes);
        
    } @catch (NSException *exception) {
        if (error) {
            *error = sdp::makeEncodeError([NSString stringWithFormat:@"Encoding failed: %@", exception.reason]);
        }
        return nil;
    }
}

+ (nullable User *)decodeUser:(NSData *)data error:(NSError **)error {
    if (!data) {
        if (error) {
            *error = sdp::makeDecodeError(@"Data is nil");
        }
        return nil;
    }
    
    if (![self isValidData:data]) {
        if (error) {
            *error = sdp::makeValidationError(@"Data size exceeds SDP limits");
        }
        return nil;
    }
    
    @try {
        // Convert NSData to vector
        std::vector<uint8_t> bytes = sdp::toVector(data);
        
        // Decode C++ struct
        sdp::User cppUser;
        if (!sdp::DecodeUser(cppUser, bytes)) {
            if (error) {
                *error = sdp::makeDecodeError(@"Failed to decode user data");
            }
            return nil;
        }
        
        // Convert C++ struct to Objective-C object
        User *user = [[User alloc] init];
        user.userId = cppUser.id;
        user.username = sdp::toNSString(cppUser.username);
        user.email = sdp::toNSString(cppUser.email);
        user.age = cppUser.age;
        user.isActive = sdp::toBOOL(cppUser.is_active);
        user.tags = sdp::toNSArray(cppUser.tags);
        
        // Handle optional metadata
        if (cppUser.metadata) {
            UserMetadata *metadata = [[UserMetadata alloc] init];
            metadata.createdAt = cppUser.metadata->created_at;
            metadata.updatedAt = cppUser.metadata->updated_at;
            metadata.loginCount = cppUser.metadata->login_count;
            user.metadata = metadata;
            
            // Clean up
            delete cppUser.metadata;
        }
        
        return user;
        
    } @catch (NSException *exception) {
        if (error) {
            *error = sdp::makeDecodeError([NSString stringWithFormat:@"Decoding failed: %@", exception.reason]);
        }
        return nil;
    }
}

+ (BOOL)isValidData:(NSData *)data {
    return sdp::isValidDataSize(data);
}

+ (NSUInteger)estimatedSizeForUser:(User *)user {
    // Rough estimate: 
    // Fixed fields: 4 (id) + 1 (age) + 1 (is_active) = 6 bytes
    // Strings: 4 bytes length + content for each
    // Tags array: 4 bytes count + strings
    // Metadata: 1 byte presence + 8 + 8 + 4 = 21 bytes if present
    
    NSUInteger size = 6; // Fixed fields
    
    size += 4 + user.username.length;
    size += 4 + user.email.length;
    
    size += 4; // Array count
    for (NSString *tag in user.tags) {
        size += 4 + tag.length;
    }
    
    if (user.metadata) {
        size += 21;
    } else {
        size += 1;
    }
    
    return size;
}

@end
