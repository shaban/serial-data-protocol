/* encode.cpp - Encoding implementations for audiounit
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "encode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

size_t parameter_size(const Parameter& msg) {
    size_t size = 0;
    size += 8;  // address
    size += 4 + msg.display_name.size();  // display_name
    size += 4 + msg.identifier.size();  // identifier
    size += 4 + msg.unit.size();  // unit
    size += 4;  // min_value
    size += 4;  // max_value
    size += 4;  // default_value
    size += 4;  // current_value
    size += 4;  // raw_flags
    size += 1;  // is_writable
    size += 1;  // can_ramp
    return size;
}

size_t parameter_encode(const Parameter& msg, uint8_t* buf) {
    size_t offset = 0;

    /* address */
        *(uint64_t*)(buf + offset) = SDP_HTOLE64(msg.address);
        offset += 8;

    /* display_name */
    uint32_t display_name_len = msg.display_name.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(display_name_len);
    offset += 4;
    std::memcpy(buf + offset, msg.display_name.data(), display_name_len);
    offset += display_name_len;

    /* identifier */
    uint32_t identifier_len = msg.identifier.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(identifier_len);
    offset += 4;
    std::memcpy(buf + offset, msg.identifier.data(), identifier_len);
    offset += identifier_len;

    /* unit */
    uint32_t unit_len = msg.unit.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(unit_len);
    offset += 4;
    std::memcpy(buf + offset, msg.unit.data(), unit_len);
    offset += unit_len;

    /* min_value */
        *(uint32_t*)(buf + offset) = sdp_f32_to_le(msg.min_value);
        offset += 4;

    /* max_value */
        *(uint32_t*)(buf + offset) = sdp_f32_to_le(msg.max_value);
        offset += 4;

    /* default_value */
        *(uint32_t*)(buf + offset) = sdp_f32_to_le(msg.default_value);
        offset += 4;

    /* current_value */
        *(uint32_t*)(buf + offset) = sdp_f32_to_le(msg.current_value);
        offset += 4;

    /* raw_flags */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.raw_flags);
        offset += 4;

    /* is_writable */
        buf[offset++] = msg.is_writable;

    /* can_ramp */
        buf[offset++] = msg.can_ramp;

    return offset;
}

size_t plugin_size(const Plugin& msg) {
    size_t size = 0;
    size += 4 + msg.name.size();  // name
    size += 4 + msg.manufacturer_id.size();  // manufacturer_id
    size += 4 + msg.component_type.size();  // component_type
    size += 4 + msg.component_subtype.size();  // component_subtype
    size += 4;  // parameters count
    for (const auto& elem : msg.parameters) {
        size += parameter_size(elem);
    }
    return size;
}

size_t plugin_encode(const Plugin& msg, uint8_t* buf) {
    size_t offset = 0;

    /* name */
    uint32_t name_len = msg.name.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
    offset += 4;
    std::memcpy(buf + offset, msg.name.data(), name_len);
    offset += name_len;

    /* manufacturer_id */
    uint32_t manufacturer_id_len = msg.manufacturer_id.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(manufacturer_id_len);
    offset += 4;
    std::memcpy(buf + offset, msg.manufacturer_id.data(), manufacturer_id_len);
    offset += manufacturer_id_len;

    /* component_type */
    uint32_t component_type_len = msg.component_type.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(component_type_len);
    offset += 4;
    std::memcpy(buf + offset, msg.component_type.data(), component_type_len);
    offset += component_type_len;

    /* component_subtype */
    uint32_t component_subtype_len = msg.component_subtype.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(component_subtype_len);
    offset += 4;
    std::memcpy(buf + offset, msg.component_subtype.data(), component_subtype_len);
    offset += component_subtype_len;

    /* parameters */
    uint32_t parameters_count = msg.parameters.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(parameters_count);
    offset += 4;
    for (const auto& elem : msg.parameters) {
            *(uint64_t*)(buf + offset) = SDP_HTOLE64(elem.address);
            offset += 8;
        uint32_t display_name_len = elem.display_name.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(display_name_len);
        offset += 4;
        std::memcpy(buf + offset, elem.display_name.data(), display_name_len);
        offset += display_name_len;
        uint32_t identifier_len = elem.identifier.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(identifier_len);
        offset += 4;
        std::memcpy(buf + offset, elem.identifier.data(), identifier_len);
        offset += identifier_len;
        uint32_t unit_len = elem.unit.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(unit_len);
        offset += 4;
        std::memcpy(buf + offset, elem.unit.data(), unit_len);
        offset += unit_len;
            *(uint32_t*)(buf + offset) = sdp_f32_to_le(elem.min_value);
            offset += 4;
            *(uint32_t*)(buf + offset) = sdp_f32_to_le(elem.max_value);
            offset += 4;
            *(uint32_t*)(buf + offset) = sdp_f32_to_le(elem.default_value);
            offset += 4;
            *(uint32_t*)(buf + offset) = sdp_f32_to_le(elem.current_value);
            offset += 4;
            *(uint32_t*)(buf + offset) = SDP_HTOLE32(elem.raw_flags);
            offset += 4;
            buf[offset++] = elem.is_writable;
            buf[offset++] = elem.can_ramp;
    }

    return offset;
}

size_t plugin_registry_size(const PluginRegistry& msg) {
    size_t size = 0;
    size += 4;  // plugins count
    for (const auto& elem : msg.plugins) {
        size += plugin_size(elem);
    }
    size += 4;  // total_plugin_count
    size += 4;  // total_parameter_count
    return size;
}

size_t plugin_registry_encode(const PluginRegistry& msg, uint8_t* buf) {
    size_t offset = 0;

    /* plugins */
    uint32_t plugins_count = msg.plugins.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(plugins_count);
    offset += 4;
    for (const auto& elem : msg.plugins) {
        uint32_t name_len = elem.name.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
        offset += 4;
        std::memcpy(buf + offset, elem.name.data(), name_len);
        offset += name_len;
        uint32_t manufacturer_id_len = elem.manufacturer_id.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(manufacturer_id_len);
        offset += 4;
        std::memcpy(buf + offset, elem.manufacturer_id.data(), manufacturer_id_len);
        offset += manufacturer_id_len;
        uint32_t component_type_len = elem.component_type.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(component_type_len);
        offset += 4;
        std::memcpy(buf + offset, elem.component_type.data(), component_type_len);
        offset += component_type_len;
        uint32_t component_subtype_len = elem.component_subtype.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(component_subtype_len);
        offset += 4;
        std::memcpy(buf + offset, elem.component_subtype.data(), component_subtype_len);
        offset += component_subtype_len;
        uint32_t parameters_count = elem.parameters.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(parameters_count);
        offset += 4;
        for (const auto& nested_elem : elem.parameters) {
            offset += parameter_encode(nested_elem, buf + offset);
        }
    }

    /* total_plugin_count */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.total_plugin_count);
        offset += 4;

    /* total_parameter_count */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.total_parameter_count);
        offset += 4;

    return offset;
}

}  // namespace sdp
