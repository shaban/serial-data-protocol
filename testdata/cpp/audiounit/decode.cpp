/* decode.cpp - Decoding implementations for audiounit_cpp
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "decode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

/* Array size limits */
constexpr uint32_t MAX_ARRAY_ELEMENTS = 1000000;
constexpr uint32_t MAX_TOTAL_ELEMENTS = 10000000;

/* Forward declarations for internal decode helpers */
static Parameter parameter_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static Plugin plugin_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static PluginRegistry plugin_registry_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);

static Parameter parameter_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Parameter result;

    /* address */
    if (offset + 8 > buf_len) throw DecodeError("Buffer too small");
    result.address = SDP_LE64TOH(*(const uint64_t*)(buf + offset));
    offset += 8;

    /* display_name */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t display_name_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + display_name_len > buf_len) throw DecodeError("Buffer too small");
    result.display_name = std::string(reinterpret_cast<const char*>(buf + offset), display_name_len);
    offset += display_name_len;

    /* identifier */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t identifier_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + identifier_len > buf_len) throw DecodeError("Buffer too small");
    result.identifier = std::string(reinterpret_cast<const char*>(buf + offset), identifier_len);
    offset += identifier_len;

    /* unit */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t unit_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + unit_len > buf_len) throw DecodeError("Buffer too small");
    result.unit = std::string(reinterpret_cast<const char*>(buf + offset), unit_len);
    offset += unit_len;

    /* min_value */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.min_value = sdp_le_to_f32(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* max_value */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.max_value = sdp_le_to_f32(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* default_value */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.default_value = sdp_le_to_f32(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* current_value */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.current_value = sdp_le_to_f32(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* raw_flags */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.raw_flags = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* is_writable */
    if (offset + 1 > buf_len) throw DecodeError("Buffer too small");
    result.is_writable = buf[offset++] != 0;

    /* can_ramp */
    if (offset + 1 > buf_len) throw DecodeError("Buffer too small");
    result.can_ramp = buf[offset++] != 0;

    return result;
}

Parameter parameter_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return parameter_decode_impl(buf, buf_len, offset);
}

static Plugin plugin_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Plugin result;
    uint32_t total_elements = 0;

    /* name */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t name_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + name_len > buf_len) throw DecodeError("Buffer too small");
    result.name = std::string(reinterpret_cast<const char*>(buf + offset), name_len);
    offset += name_len;

    /* manufacturer_id */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t manufacturer_id_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + manufacturer_id_len > buf_len) throw DecodeError("Buffer too small");
    result.manufacturer_id = std::string(reinterpret_cast<const char*>(buf + offset), manufacturer_id_len);
    offset += manufacturer_id_len;

    /* component_type */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t component_type_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + component_type_len > buf_len) throw DecodeError("Buffer too small");
    result.component_type = std::string(reinterpret_cast<const char*>(buf + offset), component_type_len);
    offset += component_type_len;

    /* component_subtype */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t component_subtype_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + component_subtype_len > buf_len) throw DecodeError("Buffer too small");
    result.component_subtype = std::string(reinterpret_cast<const char*>(buf + offset), component_subtype_len);
    offset += component_subtype_len;

    /* parameters */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t parameters_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (parameters_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += parameters_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.parameters.reserve(parameters_count);
    for (uint32_t i = 0; i < parameters_count; i++) {
        result.parameters.push_back(parameter_decode_impl(buf, buf_len, offset));
    }

    return result;
}

Plugin plugin_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return plugin_decode_impl(buf, buf_len, offset);
}

static PluginRegistry plugin_registry_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    PluginRegistry result;
    uint32_t total_elements = 0;

    /* plugins */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t plugins_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (plugins_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += plugins_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.plugins.reserve(plugins_count);
    for (uint32_t i = 0; i < plugins_count; i++) {
        result.plugins.push_back(plugin_decode_impl(buf, buf_len, offset));
    }

    /* total_plugin_count */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.total_plugin_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* total_parameter_count */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.total_parameter_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    return result;
}

PluginRegistry plugin_registry_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return plugin_registry_decode_impl(buf, buf_len, offset);
}

}  // namespace sdp
