/* decode.cpp - Decoding implementations for arrays_cpp
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "decode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

/* Array size limits */
constexpr uint32_t MAX_ARRAY_ELEMENTS = 1000000;
constexpr uint32_t MAX_TOTAL_ELEMENTS = 10000000;

static ArraysOfPrimitives arrays_of_primitives_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    ArraysOfPrimitives result;
    uint32_t total_elements = 0;

    /* u8_array */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t u8_array_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (u8_array_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += u8_array_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.u8_array.reserve(u8_array_count);
    if (offset + u8_array_count > buf_len) throw DecodeError("Buffer too small");
    result.u8_array.assign(buf + offset, buf + offset + u8_array_count);
    offset += u8_array_count;

    /* u32_array */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t u32_array_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (u32_array_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += u32_array_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.u32_array.reserve(u32_array_count);
    if (offset + u32_array_count * 4 > buf_len) throw DecodeError("Buffer too small");
    for (uint32_t i = 0; i < u32_array_count; i++) {
        uint32_t elem;
        elem = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
        offset += 4;
        result.u32_array.push_back(elem);
    }

    /* f64_array */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t f64_array_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (f64_array_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += f64_array_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.f64_array.reserve(f64_array_count);
    if (offset + f64_array_count * 8 > buf_len) throw DecodeError("Buffer too small");
    for (uint32_t i = 0; i < f64_array_count; i++) {
        double elem;
        elem = sdp_le_to_f64(*(const uint64_t*)(buf + offset));
        offset += 8;
        result.f64_array.push_back(elem);
    }

    /* str_array */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t str_array_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (str_array_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += str_array_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.str_array.reserve(str_array_count);
    for (uint32_t i = 0; i < str_array_count; i++) {
        if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
        uint32_t len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
        offset += 4;
        if (offset + len > buf_len) throw DecodeError("Buffer too small");
        result.str_array.emplace_back(reinterpret_cast<const char*>(buf + offset), len);
        offset += len;
    }

    /* bool_array */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t bool_array_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (bool_array_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += bool_array_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.bool_array.reserve(bool_array_count);
    if (offset + bool_array_count * 1 > buf_len) throw DecodeError("Buffer too small");
    for (uint32_t i = 0; i < bool_array_count; i++) {
        bool elem;
        elem = buf[offset++] != 0;
        result.bool_array.push_back(elem);
    }

    return result;
}

ArraysOfPrimitives arrays_of_primitives_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return arrays_of_primitives_decode_impl(buf, buf_len, offset);
}

static Item item_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Item result;

    /* id */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.id = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* name */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t name_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + name_len > buf_len) throw DecodeError("Buffer too small");
    result.name = std::string(reinterpret_cast<const char*>(buf + offset), name_len);
    offset += name_len;

    return result;
}

Item item_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return item_decode_impl(buf, buf_len, offset);
}

static ArraysOfStructs arrays_of_structs_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    ArraysOfStructs result;
    uint32_t total_elements = 0;

    /* items */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t items_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (items_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += items_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.items.reserve(items_count);
    for (uint32_t i = 0; i < items_count; i++) {
        result.items.push_back(item_decode_impl(buf, buf_len, offset));
    }

    /* count */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    return result;
}

ArraysOfStructs arrays_of_structs_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return arrays_of_structs_decode_impl(buf, buf_len, offset);
}

}  // namespace sdp
