/* encode.cpp - Encoding implementations for arrays_cpp
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "encode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

size_t arrays_of_primitives_size(const ArraysOfPrimitives& msg) {
    size_t size = 0;
    size += 4;  // u8_array count
    size += msg.u8_array.size() * 1;
    size += 4;  // u32_array count
    size += msg.u32_array.size() * 4;
    size += 4;  // f64_array count
    size += msg.f64_array.size() * 8;
    size += 4;  // str_array count
    for (const auto& elem : msg.str_array) {
        size += 4 + elem.size();
    }
    size += 4;  // bool_array count
    size += msg.bool_array.size() * 1;
    return size;
}

size_t arrays_of_primitives_encode(const ArraysOfPrimitives& msg, uint8_t* buf) {
    size_t offset = 0;

    /* u8_array */
    uint32_t u8_array_count = msg.u8_array.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(u8_array_count);
    offset += 4;
    std::memcpy(buf + offset, msg.u8_array.data(), u8_array_count);
    offset += u8_array_count;

    /* u32_array */
    uint32_t u32_array_count = msg.u32_array.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(u32_array_count);
    offset += 4;
    for (const auto& elem : msg.u32_array) {
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(elem);
        offset += 4;
    }

    /* f64_array */
    uint32_t f64_array_count = msg.f64_array.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(f64_array_count);
    offset += 4;
    for (const auto& elem : msg.f64_array) {
        *(uint64_t*)(buf + offset) = sdp_f64_to_le(elem);
        offset += 8;
    }

    /* str_array */
    uint32_t str_array_count = msg.str_array.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(str_array_count);
    offset += 4;
    for (const auto& elem : msg.str_array) {
        uint32_t len = elem.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(len);
        offset += 4;
        std::memcpy(buf + offset, elem.data(), len);
        offset += len;
    }

    /* bool_array */
    uint32_t bool_array_count = msg.bool_array.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(bool_array_count);
    offset += 4;
    for (const auto& elem : msg.bool_array) {
        buf[offset++] = elem;
    }

    return offset;
}

size_t item_size(const Item& msg) {
    size_t size = 0;
    size += 4;  // id
    size += 4 + msg.name.size();  // name
    return size;
}

size_t item_encode(const Item& msg, uint8_t* buf) {
    size_t offset = 0;

    /* id */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.id);
        offset += 4;

    /* name */
    uint32_t name_len = msg.name.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
    offset += 4;
    std::memcpy(buf + offset, msg.name.data(), name_len);
    offset += name_len;

    return offset;
}

size_t arrays_of_structs_size(const ArraysOfStructs& msg) {
    size_t size = 0;
    size += 4;  // items count
    for (const auto& elem : msg.items) {
        size += item_size(elem);
    }
    size += 4;  // count
    return size;
}

size_t arrays_of_structs_encode(const ArraysOfStructs& msg, uint8_t* buf) {
    size_t offset = 0;

    /* items */
    uint32_t items_count = msg.items.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(items_count);
    offset += 4;
    for (const auto& elem : msg.items) {
        offset += item_encode(elem, buf + offset);
    }

    /* count */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.count);
        offset += 4;

    return offset;
}

}  // namespace sdp
