// test_crosslang.cpp - Cross-language message mode compatibility test
// Tests C++ message mode against reference .sdpb files generated by Go/C++
#include "message_decode.hpp"
#include "message_encode.hpp"
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdint>
#include <iomanip>

// Read binary file into vector
std::vector<uint8_t> read_file(const std::string& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path);
    }
    
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    std::vector<uint8_t> buffer(size);
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path);
    }
    
    return buffer;
}

// Print hex string for debugging
void print_hex(const std::vector<uint8_t>& data) {
    for (uint8_t byte : data) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << (int)byte;
    }
    std::cout << std::dec << std::endl;
}

int main() {
    try {
        std::cout << "=== C++/Go Cross-Language Message Mode Test ===" << std::endl;
        std::cout << "Using .sdpb reference files from testdata/binaries/" << std::endl << std::endl;
        
        // Test 1: Decode Go-generated Point message
        {
            std::cout << "Test 1: Decode Go Point message" << std::endl;
            std::vector<uint8_t> go_point_data = read_file("../../binaries/message_point.sdpb");
            std::cout << "  Loaded " << go_point_data.size() << " bytes" << std::endl;
            std::cout << "  Hex: ";
            print_hex(go_point_data);
            
            sdp::Point point = sdp::DecodePointMessage(go_point_data);
            
            const double expected_x = 3.14;
            const double expected_y = 2.71;
            const double epsilon = 0.00001;
            
            if (std::abs(point.x - expected_x) > epsilon || std::abs(point.y - expected_y) > epsilon) {
                std::cerr << "ERROR: Point values mismatch" << std::endl;
                std::cerr << "  Expected: (" << expected_x << ", " << expected_y << ")" << std::endl;
                std::cerr << "  Got:      (" << point.x << ", " << point.y << ")" << std::endl;
                return 1;
            }
            
            std::cout << "  Decoded: Point(" << point.x << ", " << point.y << ")" << std::endl;
            std::cout << "  ✓ Point decode OK" << std::endl << std::endl;
        }
        
        // Test 2: Decode Go-generated Rectangle message
        {
            std::cout << "Test 2: Decode Go Rectangle message" << std::endl;
            std::vector<uint8_t> go_rect_data = read_file("../../binaries/message_rectangle.sdpb");
            std::cout << "  Loaded " << go_rect_data.size() << " bytes" << std::endl;
            std::cout << "  Hex: ";
            print_hex(go_rect_data);
            
            sdp::Rectangle rect = sdp::DecodeRectangleMessage(go_rect_data);
            
            const double epsilon = 0.00001;
            if (std::abs(rect.top_left.x - 10.0) > epsilon ||
                std::abs(rect.top_left.y - 20.0) > epsilon ||
                std::abs(rect.width - 100.0) > epsilon ||
                std::abs(rect.height - 50.0) > epsilon) {
                std::cerr << "ERROR: Rectangle values mismatch" << std::endl;
                return 1;
            }
            
            std::cout << "  Decoded: Rectangle(top_left=(" << rect.top_left.x << ", " << rect.top_left.y << "), ";
            std::cout << "width=" << rect.width << ", height=" << rect.height << ")" << std::endl;
            std::cout << "  ✓ Rectangle decode OK" << std::endl << std::endl;
        }
        
        // Test 3: Round-trip - Encode in C++, compare to Go reference
        {
            std::cout << "Test 3: C++ encode matches Go reference" << std::endl;
            
            sdp::Point point;
            point.x = 3.14;
            point.y = 2.71;
            
            std::vector<uint8_t> cpp_encoded = sdp::EncodePointMessage(point);
            std::vector<uint8_t> go_reference = read_file("../../binaries/message_point.sdpb");
            
            std::cout << "  C++ encoded: ";
            print_hex(cpp_encoded);
            std::cout << "  Go  encoded: ";
            print_hex(go_reference);
            
            if (cpp_encoded != go_reference) {
                std::cerr << "ERROR: C++ encoding doesn't match Go reference!" << std::endl;
                std::cerr << "  C++ size: " << cpp_encoded.size() << " bytes" << std::endl;
                std::cerr << "  Go size:  " << go_reference.size() << " bytes" << std::endl;
                return 1;
            }
            
            std::cout << "  ✓ C++ encoding matches Go (byte-for-byte identical)" << std::endl << std::endl;
        }
        
        // Test 4: Decode C++-generated message
        {
            std::cout << "Test 4: Decode C++ Rectangle message" << std::endl;
            std::vector<uint8_t> cpp_rect_data = read_file("../../binaries/message_rectangle_cpp.sdpb");
            std::cout << "  Loaded " << cpp_rect_data.size() << " bytes" << std::endl;
            
            sdp::Rectangle rect = sdp::DecodeRectangleMessage(cpp_rect_data);
            
            const double epsilon = 0.00001;
            if (std::abs(rect.width - 100.0) > epsilon || std::abs(rect.height - 50.0) > epsilon) {
                std::cerr << "ERROR: C++ round-trip failed" << std::endl;
                return 1;
            }
            
            std::cout << "  ✓ C++ round-trip OK" << std::endl << std::endl;
        }
        
        // Test 5: Message dispatcher with Go-generated files
        {
            std::cout << "Test 5: Message dispatcher with Go files" << std::endl;
            
            std::vector<uint8_t> point_data = read_file("../../binaries/message_point.sdpb");
            auto point_msg = sdp::DecodeMessage(point_data);
            
            if (!std::holds_alternative<sdp::Point>(point_msg)) {
                std::cerr << "ERROR: Dispatcher returned wrong type for Point" << std::endl;
                return 1;
            }
            
            sdp::Point point = std::get<sdp::Point>(point_msg);
            std::cout << "  Dispatcher decoded Point: (" << point.x << ", " << point.y << ")" << std::endl;
            std::cout << "  ✓ Dispatcher OK" << std::endl << std::endl;
        }
        
        std::cout << "=== All cross-language tests passed! ===" << std::endl;
        return 0;
        
    } catch (const std::exception& e) {
        std::cerr << "ERROR: " << e.what() << std::endl;
        return 1;
    }
}
