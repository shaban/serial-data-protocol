// Auto-generated by sdp-gen. DO NOT EDIT.
// Message mode decoders - self-describing messages with type headers.

use byteorder::{ByteOrder, LittleEndian};
use crate::types::*;
use crate::decode::*;
use crate::message_encode::{MESSAGE_HEADER_SIZE, MESSAGE_MAGIC, MESSAGE_VERSION};

/// Message mode errors
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MessageError {
    /// Message is too short (minimum 10 bytes required)
    MessageTooShort,
    /// Invalid magic bytes (expected 'SDP')
    InvalidMagic,
    /// Invalid protocol version (expected '2')
    InvalidVersion,
    /// Unknown message type ID
    UnknownMessageType(u16),
    /// Payload size mismatch
    PayloadSizeMismatch,
    /// Decode error (payload is invalid)
    DecodeError(String),
}

impl std::fmt::Display for MessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MessageError::MessageTooShort => write!(f, "Message too short"),
            MessageError::InvalidMagic => write!(f, "Invalid magic bytes"),
            MessageError::InvalidVersion => write!(f, "Invalid protocol version"),
            MessageError::UnknownMessageType(id) => write!(f, "Unknown message type: {}", id),
            MessageError::PayloadSizeMismatch => write!(f, "Payload size mismatch"),
            MessageError::DecodeError(msg) => write!(f, "Decode error: {}", msg),
        }
    }
}

impl std::error::Error for MessageError {}

/// Message enum representing all possible message types.
/// Use pattern matching to handle different message types.
#[derive(Debug, Clone)]
pub enum Message {
    Request(Request),
    Metadata(Metadata),
    Config(Config),
    DatabaseConfig(DatabaseConfig),
    CacheConfig(CacheConfig),
    Document(Document),
    TagList(TagList),
}

/// Decodes a Request from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 1
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_request_message(data: &[u8]) -> Result<Request, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 1 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    Request::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a Metadata from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 2
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_metadata_message(data: &[u8]) -> Result<Metadata, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 2 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    Metadata::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a Config from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 3
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_config_message(data: &[u8]) -> Result<Config, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 3 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    Config::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a DatabaseConfig from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 4
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_database_config_message(data: &[u8]) -> Result<DatabaseConfig, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 4 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    DatabaseConfig::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a CacheConfig from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 5
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_cache_config_message(data: &[u8]) -> Result<CacheConfig, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 5 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    CacheConfig::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a Document from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 6
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_document_message(data: &[u8]) -> Result<Document, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 6 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    Document::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a TagList from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 7
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_tag_list_message(data: &[u8]) -> Result<TagList, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 7 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    TagList::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a message and returns the appropriate Message enum variant.
///
/// This is the main entry point for decoding self-describing messages.
/// Use pattern matching on the returned Message enum to handle different types.
///
/// # Example
/// ```ignore
/// match decode_message(data)? {
///     Message::Request(val) => { /* handle Request */ },
///     // ... other variants
/// }
/// ```
pub fn decode_message(data: &[u8]) -> Result<Message, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Extract type ID and dispatch to appropriate decoder
    let type_id = LittleEndian::read_u16(&data[4..6]);

    match type_id {
        1 => {
            decode_request_message(data).map(Message::Request)
        }
        2 => {
            decode_metadata_message(data).map(Message::Metadata)
        }
        3 => {
            decode_config_message(data).map(Message::Config)
        }
        4 => {
            decode_database_config_message(data).map(Message::DatabaseConfig)
        }
        5 => {
            decode_cache_config_message(data).map(Message::CacheConfig)
        }
        6 => {
            decode_document_message(data).map(Message::Document)
        }
        7 => {
            decode_tag_list_message(data).map(Message::TagList)
        }
        _ => Err(MessageError::UnknownMessageType(type_id)),
    }
}
