// Code generated by sdp-gen. DO NOT EDIT.

use super::types::*;
use super::wire_slice::{self, SliceResult as Result};

impl Request {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.id)?;
        offset += 4;
        wire_slice::encode_bool(buf, offset, self.metadata.is_some())?;
        offset += 1;
        if let Some(ref value) = self.metadata {
            let written = value.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // u32
        size += 1; // presence flag
        if let Some(ref value) = self.metadata {
            size += value.encoded_size();
        }

        size
    }
}

impl Metadata {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u64(buf, offset, self.user_id)?;
        offset += 8;
        let written = wire_slice::encode_string(buf, offset, &self.username)?;
        offset += written;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 8; // u64
        size += 4 + self.username.len(); // length + bytes

        size
    }
}

impl Config {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        let written = wire_slice::encode_string(buf, offset, &self.name)?;
        offset += written;
        wire_slice::encode_bool(buf, offset, self.database.is_some())?;
        offset += 1;
        if let Some(ref value) = self.database {
            let written = value.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }
        wire_slice::encode_bool(buf, offset, self.cache.is_some())?;
        offset += 1;
        if let Some(ref value) = self.cache {
            let written = value.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4 + self.name.len(); // length + bytes
        size += 1; // presence flag
        if let Some(ref value) = self.database {
            size += value.encoded_size();
        }
        size += 1; // presence flag
        if let Some(ref value) = self.cache {
            size += value.encoded_size();
        }

        size
    }
}

impl DatabaseConfig {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        let written = wire_slice::encode_string(buf, offset, &self.host)?;
        offset += written;
        wire_slice::encode_u16(buf, offset, self.port)?;
        offset += 2;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4 + self.host.len(); // length + bytes
        size += 2; // u16

        size
    }
}

impl CacheConfig {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.size_mb)?;
        offset += 4;
        wire_slice::encode_u32(buf, offset, self.ttl_seconds)?;
        offset += 4;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // u32
        size += 4; // u32

        size
    }
}

impl Document {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.id)?;
        offset += 4;
        wire_slice::encode_bool(buf, offset, self.tags.is_some())?;
        offset += 1;
        if let Some(ref value) = self.tags {
            let written = value.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // u32
        size += 1; // presence flag
        if let Some(ref value) = self.tags {
            size += value.encoded_size();
        }

        size
    }
}

impl TagList {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.items.len() as u32)?;
        offset += 4;
        for item in &self.items {
            let written = wire_slice::encode_string(buf, offset, item)?;
            offset += written;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // array length
        for item in &self.items {
            size += 4 + item.len(); // length + bytes
        }

        size
    }
}

