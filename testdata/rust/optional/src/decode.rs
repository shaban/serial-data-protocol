// Code generated by sdp-gen. DO NOT EDIT.

use super::types::*;
use super::wire_slice::{self, SliceResult as Result};

impl Request {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let id = wire_slice::decode_u32(buf, offset)?;
        offset += 4;
        let present = wire_slice::decode_bool(buf, offset)?;
        offset += 1;
        let metadata = if present {
            let value = Metadata::decode_from_slice(&buf[offset..])?;
            offset += value.encoded_size();
            Some(value)
        } else {
            None
        };

        Ok(Self {
            id,
            metadata,
        })
    }
}

impl Metadata {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let user_id = wire_slice::decode_u64(buf, offset)?;
        offset += 8;
        let (username, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;

        Ok(Self {
            user_id,
            username,
        })
    }
}

impl Config {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let (name, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let present = wire_slice::decode_bool(buf, offset)?;
        offset += 1;
        let database = if present {
            let value = DatabaseConfig::decode_from_slice(&buf[offset..])?;
            offset += value.encoded_size();
            Some(value)
        } else {
            None
        };
        let present = wire_slice::decode_bool(buf, offset)?;
        offset += 1;
        let cache = if present {
            let value = CacheConfig::decode_from_slice(&buf[offset..])?;
            offset += value.encoded_size();
            Some(value)
        } else {
            None
        };

        Ok(Self {
            name,
            database,
            cache,
        })
    }
}

impl DatabaseConfig {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let (host, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let port = wire_slice::decode_u16(buf, offset)?;
        offset += 2;

        Ok(Self {
            host,
            port,
        })
    }
}

impl CacheConfig {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let size_mb = wire_slice::decode_u32(buf, offset)?;
        offset += 4;
        let ttl_seconds = wire_slice::decode_u32(buf, offset)?;
        offset += 4;

        Ok(Self {
            size_mb,
            ttl_seconds,
        })
    }
}

impl Document {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let id = wire_slice::decode_u32(buf, offset)?;
        offset += 4;
        let present = wire_slice::decode_bool(buf, offset)?;
        offset += 1;
        let tags = if present {
            let value = TagList::decode_from_slice(&buf[offset..])?;
            offset += value.encoded_size();
            Some(value)
        } else {
            None
        };

        Ok(Self {
            id,
            tags,
        })
    }
}

impl TagList {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        let mut items = Vec::with_capacity(array_len);
        for _ in 0..array_len {
            let (item, consumed) = wire_slice::decode_string(buf, offset)?;
            offset += consumed;
            items.push(item);
        }

        Ok(Self {
            items,
        })
    }
}

