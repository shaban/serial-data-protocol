// Auto-generated by sdp-gen. DO NOT EDIT.
// Message mode encoders - self-describing messages with type headers.

use byteorder::{ByteOrder, LittleEndian};
use crate::types::*;
use crate::encode::*;

/// Message mode constants
pub const MESSAGE_HEADER_SIZE: usize = 10;
pub const MESSAGE_MAGIC: &[u8; 3] = b"SDP";
pub const MESSAGE_VERSION: u8 = b'2';  // ASCII '2' for v0.2.0

/// Encodes a Request to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 1
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_request_message(src: &Request) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 1);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a Metadata to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 2
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_metadata_message(src: &Metadata) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 2);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a Config to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 3
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_config_message(src: &Config) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 3);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a DatabaseConfig to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 4
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_database_config_message(src: &DatabaseConfig) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 4);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a CacheConfig to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 5
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_cache_config_message(src: &CacheConfig) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 5);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a Document to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 6
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_document_message(src: &Document) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 6);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a TagList to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 7
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_tag_list_message(src: &TagList) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 7);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

