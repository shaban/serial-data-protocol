// Code generated by sdp-gen. DO NOT EDIT.

use super::types::*;
use super::wire_slice::{self, SliceResult as Result};

impl Parameter {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u64(buf, offset, self.address)?;
        offset += 8;
        let written = wire_slice::encode_string(buf, offset, &self.display_name)?;
        offset += written;
        let written = wire_slice::encode_string(buf, offset, &self.identifier)?;
        offset += written;
        let written = wire_slice::encode_string(buf, offset, &self.unit)?;
        offset += written;
        wire_slice::encode_f32(buf, offset, self.min_value)?;
        offset += 4;
        wire_slice::encode_f32(buf, offset, self.max_value)?;
        offset += 4;
        wire_slice::encode_f32(buf, offset, self.default_value)?;
        offset += 4;
        wire_slice::encode_f32(buf, offset, self.current_value)?;
        offset += 4;
        wire_slice::encode_u32(buf, offset, self.raw_flags)?;
        offset += 4;
        wire_slice::encode_bool(buf, offset, self.is_writable)?;
        offset += 1;
        wire_slice::encode_bool(buf, offset, self.can_ramp)?;
        offset += 1;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 8; // u64
        size += 4 + self.display_name.len(); // length + bytes
        size += 4 + self.identifier.len(); // length + bytes
        size += 4 + self.unit.len(); // length + bytes
        size += 4; // f32
        size += 4; // f32
        size += 4; // f32
        size += 4; // f32
        size += 4; // u32
        size += 1; // bool
        size += 1; // bool

        size
    }
}

impl Plugin {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        let written = wire_slice::encode_string(buf, offset, &self.name)?;
        offset += written;
        let written = wire_slice::encode_string(buf, offset, &self.manufacturer_id)?;
        offset += written;
        let written = wire_slice::encode_string(buf, offset, &self.component_type)?;
        offset += written;
        let written = wire_slice::encode_string(buf, offset, &self.component_subtype)?;
        offset += written;
        wire_slice::encode_u32(buf, offset, self.parameters.len() as u32)?;
        offset += 4;
        for item in &self.parameters {
            let written = item.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4 + self.name.len(); // length + bytes
        size += 4 + self.manufacturer_id.len(); // length + bytes
        size += 4 + self.component_type.len(); // length + bytes
        size += 4 + self.component_subtype.len(); // length + bytes
        size += 4; // array length
        for item in &self.parameters {
            size += item.encoded_size();
        }

        size
    }
}

impl PluginRegistry {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.plugins.len() as u32)?;
        offset += 4;
        for item in &self.plugins {
            let written = item.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }
        wire_slice::encode_u32(buf, offset, self.total_plugin_count)?;
        offset += 4;
        wire_slice::encode_u32(buf, offset, self.total_parameter_count)?;
        offset += 4;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // array length
        for item in &self.plugins {
            size += item.encoded_size();
        }
        size += 4; // u32
        size += 4; // u32

        size
    }
}

