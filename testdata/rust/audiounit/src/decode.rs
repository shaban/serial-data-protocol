// Code generated by sdp-gen. DO NOT EDIT.

use super::types::*;
use super::wire_slice::{self, SliceResult as Result};

impl Parameter {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let address = wire_slice::decode_u64(buf, offset)?;
        offset += 8;
        let (display_name, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let (identifier, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let (unit, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let min_value = wire_slice::decode_f32(buf, offset)?;
        offset += 4;
        let max_value = wire_slice::decode_f32(buf, offset)?;
        offset += 4;
        let default_value = wire_slice::decode_f32(buf, offset)?;
        offset += 4;
        let current_value = wire_slice::decode_f32(buf, offset)?;
        offset += 4;
        let raw_flags = wire_slice::decode_u32(buf, offset)?;
        offset += 4;
        let is_writable = wire_slice::decode_bool(buf, offset)?;
        offset += 1;
        let can_ramp = wire_slice::decode_bool(buf, offset)?;
        offset += 1;

        Ok(Self {
            address,
            display_name,
            identifier,
            unit,
            min_value,
            max_value,
            default_value,
            current_value,
            raw_flags,
            is_writable,
            can_ramp,
        })
    }
}

impl Plugin {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let (name, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let (manufacturer_id, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let (component_type, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let (component_subtype, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;
        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        let mut parameters = Vec::with_capacity(array_len);
        for _ in 0..array_len {
            let item = Parameter::decode_from_slice(&buf[offset..])?;
            offset += item.encoded_size();
            parameters.push(item);
        }

        Ok(Self {
            name,
            manufacturer_id,
            component_type,
            component_subtype,
            parameters,
        })
    }
}

impl PluginRegistry {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        let mut plugins = Vec::with_capacity(array_len);
        for _ in 0..array_len {
            let item = Plugin::decode_from_slice(&buf[offset..])?;
            offset += item.encoded_size();
            plugins.push(item);
        }
        let total_plugin_count = wire_slice::decode_u32(buf, offset)?;
        offset += 4;
        let total_parameter_count = wire_slice::decode_u32(buf, offset)?;
        offset += 4;

        Ok(Self {
            plugins,
            total_plugin_count,
            total_parameter_count,
        })
    }
}

