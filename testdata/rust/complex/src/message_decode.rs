// Auto-generated by sdp-gen. DO NOT EDIT.
// Message mode decoders - self-describing messages with type headers.

use byteorder::{ByteOrder, LittleEndian};
use crate::types::*;
use crate::decode::*;
use crate::message_encode::{MESSAGE_HEADER_SIZE, MESSAGE_MAGIC, MESSAGE_VERSION};

/// Message mode errors
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MessageError {
    /// Message is too short (minimum 10 bytes required)
    MessageTooShort,
    /// Invalid magic bytes (expected 'SDP')
    InvalidMagic,
    /// Invalid protocol version (expected '2')
    InvalidVersion,
    /// Unknown message type ID
    UnknownMessageType(u16),
    /// Payload size mismatch
    PayloadSizeMismatch,
    /// Decode error (payload is invalid)
    DecodeError(String),
}

impl std::fmt::Display for MessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MessageError::MessageTooShort => write!(f, "Message too short"),
            MessageError::InvalidMagic => write!(f, "Invalid magic bytes"),
            MessageError::InvalidVersion => write!(f, "Invalid protocol version"),
            MessageError::UnknownMessageType(id) => write!(f, "Unknown message type: {}", id),
            MessageError::PayloadSizeMismatch => write!(f, "Payload size mismatch"),
            MessageError::DecodeError(msg) => write!(f, "Decode error: {}", msg),
        }
    }
}

impl std::error::Error for MessageError {}

/// Message enum representing all possible message types.
/// Use pattern matching to handle different message types.
#[derive(Debug, Clone)]
pub enum Message {
    Parameter(Parameter),
    Plugin(Plugin),
    AudioDevice(AudioDevice),
}

/// Decodes a Parameter from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 1
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_parameter_message(data: &[u8]) -> Result<Parameter, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 1 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    Parameter::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a Plugin from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 2
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_plugin_message(data: &[u8]) -> Result<Plugin, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 2 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    Plugin::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a AudioDevice from self-describing message format.
///
/// Validates the 10-byte header:
/// - Magic bytes must be 'SDP'
/// - Version must be '2'
/// - Type ID must be 3
/// - Payload length must match actual data
///
/// Returns an error if validation fails or payload is invalid.
pub fn decode_audio_device_message(data: &[u8]) -> Result<AudioDevice, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Validate type ID
    let type_id = LittleEndian::read_u16(&data[4..6]);
    if type_id != 3 {
        return Err(MessageError::UnknownMessageType(type_id));
    }

    // Extract payload length
    let payload_length = LittleEndian::read_u32(&data[6..10]) as usize;

    // Validate total message size
    let expected_size = MESSAGE_HEADER_SIZE + payload_length;
    if data.len() < expected_size {
        return Err(MessageError::PayloadSizeMismatch);
    }

    // Extract payload
    let payload = &data[MESSAGE_HEADER_SIZE..expected_size];

    // Decode payload using byte mode decoder
    AudioDevice::decode_from_slice(payload)
        .map_err(|e| MessageError::DecodeError(e.to_string()))
}

/// Decodes a message and returns the appropriate Message enum variant.
///
/// This is the main entry point for decoding self-describing messages.
/// Use pattern matching on the returned Message enum to handle different types.
///
/// # Example
/// ```ignore
/// match decode_message(data)? {
///     Message::Parameter(val) => { /* handle Parameter */ },
///     // ... other variants
/// }
/// ```
pub fn decode_message(data: &[u8]) -> Result<Message, MessageError> {
    // Check minimum message size
    if data.len() < MESSAGE_HEADER_SIZE {
        return Err(MessageError::MessageTooShort);
    }

    // Validate magic bytes
    if &data[0..3] != MESSAGE_MAGIC {
        return Err(MessageError::InvalidMagic);
    }

    // Validate protocol version
    if data[3] != MESSAGE_VERSION {
        return Err(MessageError::InvalidVersion);
    }

    // Extract type ID and dispatch to appropriate decoder
    let type_id = LittleEndian::read_u16(&data[4..6]);

    match type_id {
        1 => {
            decode_parameter_message(data).map(Message::Parameter)
        }
        2 => {
            decode_plugin_message(data).map(Message::Plugin)
        }
        3 => {
            decode_audio_device_message(data).map(Message::AudioDevice)
        }
        _ => Err(MessageError::UnknownMessageType(type_id)),
    }
}
