// Code generated by sdp-gen. DO NOT EDIT.

use super::types::*;
use super::wire_slice::{self, SliceResult as Result};

impl Parameter {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.id)?;
        offset += 4;
        let written = wire_slice::encode_string(buf, offset, &self.name)?;
        offset += written;
        wire_slice::encode_f32(buf, offset, self.value)?;
        offset += 4;
        wire_slice::encode_f32(buf, offset, self.min)?;
        offset += 4;
        wire_slice::encode_f32(buf, offset, self.max)?;
        offset += 4;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // u32
        size += 4 + self.name.len(); // length + bytes
        size += 4; // f32
        size += 4; // f32
        size += 4; // f32

        size
    }
}

impl Plugin {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.id)?;
        offset += 4;
        let written = wire_slice::encode_string(buf, offset, &self.name)?;
        offset += written;
        let written = wire_slice::encode_string(buf, offset, &self.manufacturer)?;
        offset += written;
        wire_slice::encode_u32(buf, offset, self.version)?;
        offset += 4;
        wire_slice::encode_bool(buf, offset, self.enabled)?;
        offset += 1;
        wire_slice::encode_u32(buf, offset, self.parameters.len() as u32)?;
        offset += 4;
        for item in &self.parameters {
            let written = item.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // u32
        size += 4 + self.name.len(); // length + bytes
        size += 4 + self.manufacturer.len(); // length + bytes
        size += 4; // u32
        size += 1; // bool
        size += 4; // array length
        for item in &self.parameters {
            size += item.encoded_size();
        }

        size
    }
}

impl AudioDevice {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.device_id)?;
        offset += 4;
        let written = wire_slice::encode_string(buf, offset, &self.device_name)?;
        offset += written;
        wire_slice::encode_u32(buf, offset, self.sample_rate)?;
        offset += 4;
        wire_slice::encode_u32(buf, offset, self.buffer_size)?;
        offset += 4;
        wire_slice::encode_u16(buf, offset, self.input_channels)?;
        offset += 2;
        wire_slice::encode_u16(buf, offset, self.output_channels)?;
        offset += 2;
        wire_slice::encode_bool(buf, offset, self.is_default)?;
        offset += 1;
        wire_slice::encode_u32(buf, offset, self.active_plugins.len() as u32)?;
        offset += 4;
        for item in &self.active_plugins {
            let written = item.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // u32
        size += 4 + self.device_name.len(); // length + bytes
        size += 4; // u32
        size += 4; // u32
        size += 2; // u16
        size += 2; // u16
        size += 1; // bool
        size += 4; // array length
        for item in &self.active_plugins {
            size += item.encoded_size();
        }

        size
    }
}

