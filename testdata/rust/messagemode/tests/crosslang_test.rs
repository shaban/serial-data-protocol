// Cross-language message mode compatibility test
// Tests Rust message mode against reference .sdpb files generated by Go/C++

use std::fs;
use std::path::Path;

// Import generated types and message mode functions
use sdp_point::{Point, Rectangle, Message};
use sdp_point::{encode_point_message, decode_point_message};
use sdp_point::{encode_rectangle_message, decode_rectangle_message};
use sdp_point::decode_message;

/// Read binary file into Vec<u8>
fn read_file<P: AsRef<Path>>(path: P) -> Vec<u8> {
    fs::read(path.as_ref()).expect("Failed to read file")
}

/// Print hex string for debugging
fn print_hex(data: &[u8]) {
    for byte in data {
        print!("{:02x}", byte);
    }
    println!();
}

#[test]
fn test_decode_go_point_message() {
    println!("\n=== Test 1: Decode Go Point message ===");
    
    let go_point_data = read_file("../../binaries/message_point.sdpb");
    println!("  Loaded {} bytes", go_point_data.len());
    print!("  Hex: ");
    print_hex(&go_point_data);
    
    let point = decode_point_message(&go_point_data)
        .expect("Failed to decode Point message");
    
    const EXPECTED_X: f64 = 3.14;
    const EXPECTED_Y: f64 = 2.71;
    const EPSILON: f64 = 0.00001;
    
    assert!((point.x - EXPECTED_X).abs() < EPSILON, 
        "Point.x mismatch: expected {}, got {}", EXPECTED_X, point.x);
    assert!((point.y - EXPECTED_Y).abs() < EPSILON,
        "Point.y mismatch: expected {}, got {}", EXPECTED_Y, point.y);
    
    println!("  Decoded: Point({}, {})", point.x, point.y);
    println!("  ✓ Point decode OK");
}

#[test]
fn test_decode_go_rectangle_message() {
    println!("\n=== Test 2: Decode Go Rectangle message ===");
    
    let go_rect_data = read_file("../../binaries/message_rectangle.sdpb");
    println!("  Loaded {} bytes", go_rect_data.len());
    print!("  Hex: ");
    print_hex(&go_rect_data);
    
    let rect = decode_rectangle_message(&go_rect_data)
        .expect("Failed to decode Rectangle message");
    
    const EPSILON: f64 = 0.00001;
    
    assert!((rect.top_left.x - 10.0).abs() < EPSILON);
    assert!((rect.top_left.y - 20.0).abs() < EPSILON);
    assert!((rect.width - 100.0).abs() < EPSILON);
    assert!((rect.height - 50.0).abs() < EPSILON);
    
    println!("  Decoded: Rectangle(top_left=({}, {}), width={}, height={})",
        rect.top_left.x, rect.top_left.y, rect.width, rect.height);
    println!("  ✓ Rectangle decode OK");
}

#[test]
fn test_rust_encode_matches_go_reference() {
    println!("\n=== Test 3: Rust encode matches Go reference ===");
    
    let point = Point {
        x: 3.14,
        y: 2.71,
    };
    
    let rust_encoded = encode_point_message(&point);
    let go_reference = read_file("../../binaries/message_point.sdpb");
    
    println!("  Rust encoded: {} bytes", rust_encoded.len());
    println!("  Go reference: {} bytes", go_reference.len());
    
    assert_eq!(rust_encoded.len(), go_reference.len(),
        "Message size mismatch");
    
    print!("  Rust hex: ");
    print_hex(&rust_encoded);
    print!("  Go   hex: ");
    print_hex(&go_reference);
    
    assert_eq!(rust_encoded, go_reference,
        "Rust encoding does not match Go reference (byte-for-byte)");
    
    println!("  ✓ Byte-for-byte identical");
}

#[test]
fn test_rust_roundtrip() {
    println!("\n=== Test 4: Rust roundtrip (encode + decode) ===");
    
    let original = Rectangle {
        top_left: Point { x: 10.0, y: 20.0 },
        width: 100.0,
        height: 50.0,
    };
    
    // Encode
    let encoded = encode_rectangle_message(&original);
    println!("  Encoded: {} bytes", encoded.len());
    print!("  Hex: ");
    print_hex(&encoded);
    
    // Decode
    let decoded = decode_rectangle_message(&encoded)
        .expect("Failed to decode");
    
    // Verify
    const EPSILON: f64 = 0.00001;
    assert!((decoded.top_left.x - original.top_left.x).abs() < EPSILON);
    assert!((decoded.top_left.y - original.top_left.y).abs() < EPSILON);
    assert!((decoded.width - original.width).abs() < EPSILON);
    assert!((decoded.height - original.height).abs() < EPSILON);
    
    println!("  ✓ Roundtrip successful");
}

#[test]
fn test_enum_dispatcher_point() {
    println!("\n=== Test 5: Enum dispatcher (Point) ===");
    
    let go_point_data = read_file("../../binaries/message_point.sdpb");
    
    let message = decode_message(&go_point_data)
        .expect("Failed to decode message");
    
    match message {
        Message::Point(point) => {
            const EPSILON: f64 = 0.00001;
            assert!((point.x - 3.14).abs() < EPSILON);
            assert!((point.y - 2.71).abs() < EPSILON);
            println!("  Matched Point variant: ({}, {})", point.x, point.y);
            println!("  ✓ Dispatcher correctly routed to Point");
        }
        Message::Rectangle(_) => {
            panic!("Dispatcher incorrectly routed to Rectangle");
        }
    }
}

#[test]
fn test_enum_dispatcher_rectangle() {
    println!("\n=== Test 6: Enum dispatcher (Rectangle) ===");
    
    let go_rect_data = read_file("../../binaries/message_rectangle.sdpb");
    
    let message = decode_message(&go_rect_data)
        .expect("Failed to decode message");
    
    match message {
        Message::Point(_) => {
            panic!("Dispatcher incorrectly routed to Point");
        }
        Message::Rectangle(rect) => {
            const EPSILON: f64 = 0.00001;
            assert!((rect.top_left.x - 10.0).abs() < EPSILON);
            assert!((rect.top_left.y - 20.0).abs() < EPSILON);
            println!("  Matched Rectangle variant");
            println!("  ✓ Dispatcher correctly routed to Rectangle");
        }
    }
}

#[test]
fn test_decode_cpp_point_message() {
    println!("\n=== Test 7: Decode C++ Point message ===");
    
    let cpp_point_data = read_file("../../binaries/message_point_cpp.sdpb");
    println!("  Loaded {} bytes", cpp_point_data.len());
    
    let point = decode_point_message(&cpp_point_data)
        .expect("Failed to decode C++ Point message");
    
    const EXPECTED_X: f64 = 3.14;
    const EXPECTED_Y: f64 = 2.71;
    const EPSILON: f64 = 0.00001;
    
    assert!((point.x - EXPECTED_X).abs() < EPSILON);
    assert!((point.y - EXPECTED_Y).abs() < EPSILON);
    
    println!("  Decoded: Point({}, {})", point.x, point.y);
    println!("  ✓ C++ Point decode OK");
}

#[test]
fn test_decode_cpp_rectangle_message() {
    println!("\n=== Test 8: Decode C++ Rectangle message ===");
    
    let cpp_rect_data = read_file("../../binaries/message_rectangle_cpp.sdpb");
    println!("  Loaded {} bytes", cpp_rect_data.len());
    
    let rect = decode_rectangle_message(&cpp_rect_data)
        .expect("Failed to decode C++ Rectangle message");
    
    const EPSILON: f64 = 0.00001;
    
    assert!((rect.top_left.x - 10.0).abs() < EPSILON);
    assert!((rect.top_left.y - 20.0).abs() < EPSILON);
    assert!((rect.width - 100.0).abs() < EPSILON);
    assert!((rect.height - 50.0).abs() < EPSILON);
    
    println!("  Decoded: Rectangle(top_left=({}, {}), width={}, height={})",
        rect.top_left.x, rect.top_left.y, rect.width, rect.height);
    println!("  ✓ C++ Rectangle decode OK");
}

#[test]
fn test_cross_language_compatibility() {
    println!("\n=== Test 9: Go ↔ Rust ↔ C++ compatibility ===");
    
    // All three languages must produce byte-identical messages
    let go_point = read_file("../../binaries/message_point.sdpb");
    let cpp_point = read_file("../../binaries/message_point_cpp.sdpb");
    
    let point = Point { x: 3.14, y: 2.71 };
    let rust_point = encode_point_message(&point);
    
    println!("  Go size:   {} bytes", go_point.len());
    println!("  C++ size:  {} bytes", cpp_point.len());
    println!("  Rust size: {} bytes", rust_point.len());
    
    assert_eq!(go_point.len(), cpp_point.len(), "Go/C++ size mismatch");
    assert_eq!(go_point.len(), rust_point.len(), "Go/Rust size mismatch");
    
    assert_eq!(go_point, cpp_point, "Go ≠ C++ (byte-for-byte)");
    assert_eq!(go_point, rust_point, "Go ≠ Rust (byte-for-byte)");
    assert_eq!(cpp_point, rust_point, "C++ ≠ Rust (byte-for-byte)");
    
    println!("  ✓ All three languages produce identical wire format");
}
