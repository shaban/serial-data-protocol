// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (8x faster encoding).
// All memory accesses are bounds-checked at buffer allocation.
// Safe for use - the unsafe operations are verified by the code generator.

extension AllPrimitives {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            buffer[offset] = self.u8Field
            offset += 1
            let u16FieldLE = self.u16Field.littleEndian
            withUnsafeBytes(of: u16FieldLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 2)
            }
            offset += 2
            let u32FieldLE = self.u32Field.littleEndian
            withUnsafeBytes(of: u32FieldLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let u64FieldLE = self.u64Field.littleEndian
            withUnsafeBytes(of: u64FieldLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 8)
            }
            offset += 8
            buffer[offset] = UInt8(bitPattern: self.i8Field)
            offset += 1
            let i16FieldLE = self.i16Field.littleEndian
            withUnsafeBytes(of: i16FieldLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 2)
            }
            offset += 2
            let i32FieldLE = self.i32Field.littleEndian
            withUnsafeBytes(of: i32FieldLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let i64FieldLE = self.i64Field.littleEndian
            withUnsafeBytes(of: i64FieldLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 8)
            }
            offset += 8
            let f32FieldBits = self.f32Field.bitPattern.littleEndian
            withUnsafeBytes(of: f32FieldBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let f64FieldBits = self.f64Field.bitPattern.littleEndian
            withUnsafeBytes(of: f64FieldBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 8)
            }
            offset += 8
            buffer[offset] = self.boolField ? 1 : 0
            offset += 1
            let strFieldBytes = Array(self.strField.utf8)
            let strFieldLen = UInt32(strFieldBytes.count).littleEndian
            withUnsafeBytes(of: strFieldLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            strFieldBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: strFieldBytes.count)
            }
            offset += strFieldBytes.count
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 1
        size += 2
        size += 4
        size += 8
        size += 1
        size += 2
        size += 4
        size += 8
        size += 4
        size += 8
        size += 1
        size += 4 + self.strField.utf8.count
        return size
    }
}

