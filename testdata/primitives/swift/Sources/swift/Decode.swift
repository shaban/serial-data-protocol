// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension AllPrimitives {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let u8Field = data[offset]
        offset += 1
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        let u16Field = data[offset..<offset+2].withUnsafeBytes {
            $0.load(as: UInt16.self).littleEndian
        }
        offset += 2
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let u32Field = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        let u64Field = data[offset..<offset+8].withUnsafeBytes {
            $0.load(as: UInt64.self).littleEndian
        }
        offset += 8
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let i8Field = Int8(bitPattern: data[offset])
        offset += 1
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        let i16Field = data[offset..<offset+2].withUnsafeBytes {
            $0.load(as: Int16.self).littleEndian
        }
        offset += 2
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let i32Field = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: Int32.self).littleEndian
        }
        offset += 4
        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        let i64Field = data[offset..<offset+8].withUnsafeBytes {
            $0.load(as: Int64.self).littleEndian
        }
        offset += 8
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let f32FieldBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let f32Field = Float(bitPattern: f32FieldBits)
        offset += 4
        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        let f64FieldBits = data[offset..<offset+8].withUnsafeBytes {
            $0.load(as: UInt64.self).littleEndian
        }
        let f64Field = Double(bitPattern: f64FieldBits)
        offset += 8
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let boolFieldByte = data[offset]
        guard boolFieldByte == 0 || boolFieldByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let boolField = boolFieldByte == 1
        offset += 1
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let strFieldLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(strFieldLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let strFieldData = data[offset..<offset+Int(strFieldLen)]
        guard let strField = String(data: strFieldData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(strFieldLen)

        return Self(
            u8Field: u8Field,
            u16Field: u16Field,
            u32Field: u32Field,
            u64Field: u64Field,
            i8Field: i8Field,
            i16Field: i16Field,
            i32Field: i32Field,
            i64Field: i64Field,
            f32Field: f32Field,
            f64Field: f64Field,
            boolField: boolField,
            strField: strField
        )
    }
}

