// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension AllPrimitives {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let u8Field = data[offset]
        offset += 1
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        var u16FieldBytes = [UInt8](repeating: 0, count: 2)
        data.copyBytes(to: &u16FieldBytes, from: offset..<offset+2)
        let u16Field = UInt16(littleEndian: u16FieldBytes.withUnsafeBytes { $0.load(as: UInt16.self) })
        offset += 2
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var u32FieldBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &u32FieldBytes, from: offset..<offset+4)
        let u32Field = UInt32(littleEndian: u32FieldBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        var u64FieldBytes = [UInt8](repeating: 0, count: 8)
        data.copyBytes(to: &u64FieldBytes, from: offset..<offset+8)
        let u64Field = UInt64(littleEndian: u64FieldBytes.withUnsafeBytes { $0.load(as: UInt64.self) })
        offset += 8
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let i8Field = Int8(bitPattern: data[offset])
        offset += 1
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        var i16FieldBytes = [UInt8](repeating: 0, count: 2)
        data.copyBytes(to: &i16FieldBytes, from: offset..<offset+2)
        let i16Field = Int16(bitPattern: UInt16(littleEndian: i16FieldBytes.withUnsafeBytes { $0.load(as: UInt16.self) }))
        offset += 2
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var i32FieldBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &i32FieldBytes, from: offset..<offset+4)
        let i32Field = Int32(bitPattern: UInt32(littleEndian: i32FieldBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        var i64FieldBytes = [UInt8](repeating: 0, count: 8)
        data.copyBytes(to: &i64FieldBytes, from: offset..<offset+8)
        let i64Field = Int64(bitPattern: UInt64(littleEndian: i64FieldBytes.withUnsafeBytes { $0.load(as: UInt64.self) }))
        offset += 8
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var f32FieldBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &f32FieldBitsBytes, from: offset..<offset+4)
        let f32FieldBits = UInt32(littleEndian: f32FieldBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let f32Field = Float(bitPattern: f32FieldBits)
        offset += 4
        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        var f64FieldBitsBytes = [UInt8](repeating: 0, count: 8)
        data.copyBytes(to: &f64FieldBitsBytes, from: offset..<offset+8)
        let f64FieldBits = UInt64(littleEndian: f64FieldBitsBytes.withUnsafeBytes { $0.load(as: UInt64.self) })
        let f64Field = Double(bitPattern: f64FieldBits)
        offset += 8
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let boolFieldByte = data[offset]
        guard boolFieldByte == 0 || boolFieldByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let boolField = boolFieldByte == 1
        offset += 1
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var strFieldLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &strFieldLenBytes, from: offset..<offset+4)
        let strFieldLen = Int(UInt32(littleEndian: strFieldLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + strFieldLen <= data.count else { throw SDPDecodeError.insufficientData }
        let strFieldData = data[offset..<offset+strFieldLen]
        guard let strField = String(data: strFieldData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += strFieldLen

        return Self(
            u8Field: u8Field,
            u16Field: u16Field,
            u32Field: u32Field,
            u64Field: u64Field,
            i8Field: i8Field,
            i16Field: i16Field,
            i32Field: i32Field,
            i64Field: i64Field,
            f32Field: f32Field,
            f64Field: f64Field,
            boolField: boolField,
            strField: strField
        )
    }
}

