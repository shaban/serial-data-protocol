// Code generated by sdp-gen. DO NOT EDIT.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension AllPrimitives {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
        let u8Field = bytes[offset]
        offset += 1
        guard offset + 2 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let u16Field = bytes[offset..<offset+2].withUnsafeBytes { UInt16(littleEndian: $0.load(as: UInt16.self)) }
        offset += 2
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let u32Field = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 8 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let u64Field = bytes[offset..<offset+8].withUnsafeBytes { UInt64(littleEndian: $0.load(as: UInt64.self)) }
        offset += 8
        guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
        let i8Field = Int8(bitPattern: bytes[offset])
        offset += 1
        guard offset + 2 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let i16Field = bytes[offset..<offset+2].withUnsafeBytes { Int16(bitPattern: UInt16(littleEndian: $0.load(as: UInt16.self))) }
        offset += 2
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let i32Field = bytes[offset..<offset+4].withUnsafeBytes { Int32(bitPattern: UInt32(littleEndian: $0.load(as: UInt32.self))) }
        offset += 4
        guard offset + 8 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let i64Field = bytes[offset..<offset+8].withUnsafeBytes { Int64(bitPattern: UInt64(littleEndian: $0.load(as: UInt64.self))) }
        offset += 8
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let f32FieldBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let f32Field = Float(bitPattern: f32FieldBits)
        offset += 4
        guard offset + 8 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let f64FieldBits = bytes[offset..<offset+8].withUnsafeBytes { UInt64(littleEndian: $0.load(as: UInt64.self)) }
        let f64Field = Double(bitPattern: f64FieldBits)
        offset += 8
        guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
        let boolFieldByte = bytes[offset]
        guard boolFieldByte == 0 || boolFieldByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let boolField = boolFieldByte == 1
        offset += 1
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let strFieldLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + strFieldLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let strFieldBytes = Array(bytes[offset..<offset+strFieldLen])
        guard let strField = String(bytes: strFieldBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += strFieldLen

        return Self(
            u8Field: u8Field,
            u16Field: u16Field,
            u32Field: u32Field,
            u64Field: u64Field,
            i8Field: i8Field,
            i16Field: i16Field,
            i32Field: i32Field,
            i64Field: i64Field,
            f32Field: f32Field,
            f64Field: f64Field,
            boolField: boolField,
            strField: strField
        )
    }
}

