// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension ArraysOfPrimitives {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var u8ArrayLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &u8ArrayLenBytes, from: offset..<offset+4)
        let u8ArrayLen = Int(UInt32(littleEndian: u8ArrayLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var u8Array: [UInt8] = []
        u8Array.reserveCapacity(Int(u8ArrayLen))
        for _ in 0..<Int(u8ArrayLen) {
            guard offset < data.count else { throw SDPDecodeError.insufficientData }
            let elem = data[offset]
            offset += 1
            u8Array.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var u32ArrayLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &u32ArrayLenBytes, from: offset..<offset+4)
        let u32ArrayLen = Int(UInt32(littleEndian: u32ArrayLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var u32Array: [UInt32] = []
        u32Array.reserveCapacity(Int(u32ArrayLen))
        for _ in 0..<Int(u32ArrayLen) {
            guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
            var elemBytes = [UInt8](repeating: 0, count: 4)
            data.copyBytes(to: &elemBytes, from: offset..<offset+4)
            let elem = UInt32(littleEndian: elemBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
            offset += 4
            u32Array.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var f64ArrayLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &f64ArrayLenBytes, from: offset..<offset+4)
        let f64ArrayLen = Int(UInt32(littleEndian: f64ArrayLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var f64Array: [Double] = []
        f64Array.reserveCapacity(Int(f64ArrayLen))
        for _ in 0..<Int(f64ArrayLen) {
            guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
            var elemBitsBytes = [UInt8](repeating: 0, count: 8)
            data.copyBytes(to: &elemBitsBytes, from: offset..<offset+8)
            let elemBits = UInt64(littleEndian: elemBitsBytes.withUnsafeBytes { $0.load(as: UInt64.self) })
            let elem = Double(bitPattern: elemBits)
            offset += 8
            f64Array.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var strArrayLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &strArrayLenBytes, from: offset..<offset+4)
        let strArrayLen = Int(UInt32(littleEndian: strArrayLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var strArray: [String] = []
        strArray.reserveCapacity(Int(strArrayLen))
        for _ in 0..<Int(strArrayLen) {
            guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
            var elemLenBytes = [UInt8](repeating: 0, count: 4)
            data.copyBytes(to: &elemLenBytes, from: offset..<offset+4)
            let elemLen = Int(UInt32(littleEndian: elemLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
            offset += 4
            guard offset + elemLen <= data.count else { throw SDPDecodeError.insufficientData }
            let elemData = data[offset..<offset+elemLen]
            guard let elem = String(data: elemData, encoding: .utf8) else {
                throw SDPDecodeError.invalidUTF8
            }
            offset += elemLen
            strArray.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var boolArrayLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &boolArrayLenBytes, from: offset..<offset+4)
        let boolArrayLen = Int(UInt32(littleEndian: boolArrayLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var boolArray: [Bool] = []
        boolArray.reserveCapacity(Int(boolArrayLen))
        for _ in 0..<Int(boolArrayLen) {
            guard offset < data.count else { throw SDPDecodeError.insufficientData }
            let elemByte = data[offset]
            guard elemByte == 0 || elemByte == 1 else { throw SDPDecodeError.invalidBoolValue }
            let elem = elemByte == 1
            offset += 1
            boolArray.append(elem)
        }

        return Self(
            u8Array: u8Array,
            u32Array: u32Array,
            f64Array: f64Array,
            strArray: strArray,
            boolArray: boolArray
        )
    }
}

extension Item {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var idBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &idBytes, from: offset..<offset+4)
        let id = UInt32(littleEndian: idBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var nameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &nameLenBytes, from: offset..<offset+4)
        let nameLen = Int(UInt32(littleEndian: nameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + nameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+nameLen]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen

        return Self(
            id: id,
            name: name
        )
    }
}

extension ArraysOfStructs {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var itemsLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &itemsLenBytes, from: offset..<offset+4)
        let itemsLen = Int(UInt32(littleEndian: itemsLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var items: [Item] = []
        items.reserveCapacity(Int(itemsLen))
        for _ in 0..<Int(itemsLen) {
            let elem = try Item.decode(from: data[offset...])
            offset += elem.encodedSize()
            items.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var countBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &countBytes, from: offset..<offset+4)
        let count = UInt32(littleEndian: countBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4

        return Self(
            items: items,
            count: count
        )
    }
}

