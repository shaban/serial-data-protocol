// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (3x faster decoding).
// All memory accesses are bounds-checked once at function entry.
// Safe for use - the unsafe operations are verified by the code generator.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension ArraysOfPrimitives {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            // Decode array u8Array
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let u8ArrayLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let u8ArrayLen = Int(UInt32(littleEndian: u8ArrayLenPtr.load(as: UInt32.self)))
            offset += 4

            let u8Array: ContiguousArray<UInt8> = ContiguousArray(unsafeUninitializedCapacity: u8ArrayLen) { arrayBuffer, count in
                guard offset + (u8ArrayLen * 1) <= _bufferSize else {
                    count = 0
                    return
                }
                let srcPtr = UnsafeRawPointer(buffer.advanced(by: offset))
                for i in 0..<u8ArrayLen {
                    let elemPtr = srcPtr.advanced(by: i * 1)
                    let value = UInt8(littleEndian: elemPtr.load(as: UInt8.self))
                    arrayBuffer[i] = value
                }
                count = u8ArrayLen
            }
            offset += u8ArrayLen * 1

            // Decode array u32Array
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let u32ArrayLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let u32ArrayLen = Int(UInt32(littleEndian: u32ArrayLenPtr.load(as: UInt32.self)))
            offset += 4

            let u32Array: ContiguousArray<UInt32> = ContiguousArray(unsafeUninitializedCapacity: u32ArrayLen) { arrayBuffer, count in
                guard offset + (u32ArrayLen * 4) <= _bufferSize else {
                    count = 0
                    return
                }
                let srcPtr = UnsafeRawPointer(buffer.advanced(by: offset))
                for i in 0..<u32ArrayLen {
                    let elemPtr = srcPtr.advanced(by: i * 4)
                    let value = UInt32(littleEndian: elemPtr.load(as: UInt32.self))
                    arrayBuffer[i] = value
                }
                count = u32ArrayLen
            }
            offset += u32ArrayLen * 4

            // Decode array f64Array
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let f64ArrayLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let f64ArrayLen = Int(UInt32(littleEndian: f64ArrayLenPtr.load(as: UInt32.self)))
            offset += 4

            let f64Array: ContiguousArray<Double> = ContiguousArray(unsafeUninitializedCapacity: f64ArrayLen) { arrayBuffer, count in
                guard offset + (f64ArrayLen * 8) <= _bufferSize else {
                    count = 0
                    return
                }
                let srcPtr = UnsafeRawPointer(buffer.advanced(by: offset))
                for i in 0..<f64ArrayLen {
                    let elemPtr = srcPtr.advanced(by: i * 8)
                    let bits = UInt64(littleEndian: elemPtr.load(as: UInt64.self))
                    let value = Double(bitPattern: bits)
                    arrayBuffer[i] = value
                }
                count = f64ArrayLen
            }
            offset += f64ArrayLen * 8

            // Decode array strArray
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let strArrayLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let strArrayLen = Int(UInt32(littleEndian: strArrayLenPtr.load(as: UInt32.self)))
            offset += 4

            var strArray = ContiguousArray<String>()
            strArray.reserveCapacity(strArrayLen)
            for _ in 0..<strArrayLen {
                guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
                let elemLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
                let elemLen = Int(UInt32(littleEndian: elemLenPtr.load(as: UInt32.self)))
                offset += 4
                guard offset + elemLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
                let elemBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: elemLen)
                let elem = String(decoding: elemBuffer, as: UTF8.self)
                offset += elemLen
                strArray.append(elem)
            }
            // Decode array boolArray
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let boolArrayLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let boolArrayLen = Int(UInt32(littleEndian: boolArrayLenPtr.load(as: UInt32.self)))
            offset += 4

            var boolArray = ContiguousArray<Bool>()
            boolArray.reserveCapacity(boolArrayLen)
            for _ in 0..<boolArrayLen {
                guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
                let elemByte = buffer[offset]
                guard elemByte == 0 || elemByte == 1 else { throw SDPDecodeError.invalidBoolValue }
                let elem = elemByte == 1
                offset += 1
                boolArray.append(elem)
            }

            return Self(
                u8Array: u8Array,
                u32Array: u32Array,
                f64Array: f64Array,
                strArray: strArray,
                boolArray: boolArray
            )
        }
    }
}

extension Item {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let idPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let id = UInt32(littleEndian: idPtr.load(as: UInt32.self))
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let nameLen = Int(UInt32(littleEndian: nameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + nameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: nameLen)
            let name = String(decoding: nameBuffer, as: UTF8.self)
            offset += nameLen

            return Self(
                id: id,
                name: name
            )
        }
    }
}

extension ArraysOfStructs {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            // Decode array items
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let itemsLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let itemsLen = Int(UInt32(littleEndian: itemsLenPtr.load(as: UInt32.self)))
            offset += 4

            var items = ContiguousArray<Item>()
            items.reserveCapacity(itemsLen)
            for _ in 0..<itemsLen {
                let elem = try Item.decode(from: Array(bytes[offset...]))
                offset += elem.encodedSize()
                items.append(elem)
            }
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let countPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let count = UInt32(littleEndian: countPtr.load(as: UInt32.self))
            offset += 4

            return Self(
                items: items,
                count: count
            )
        }
    }
}

