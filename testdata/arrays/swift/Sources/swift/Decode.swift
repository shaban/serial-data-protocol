// Code generated by sdp-gen. DO NOT EDIT.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension ArraysOfPrimitives {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let u8ArrayLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var u8Array: [UInt8] = []
        u8Array.reserveCapacity(Int(u8ArrayLen))
        for _ in 0..<Int(u8ArrayLen) {
            guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
            let elem = bytes[offset]
            offset += 1
            u8Array.append(elem)
        }
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let u32ArrayLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var u32Array: [UInt32] = []
        u32Array.reserveCapacity(Int(u32ArrayLen))
        for _ in 0..<Int(u32ArrayLen) {
            guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
            let elem = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
            offset += 4
            u32Array.append(elem)
        }
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let f64ArrayLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var f64Array: [Double] = []
        f64Array.reserveCapacity(Int(f64ArrayLen))
        for _ in 0..<Int(f64ArrayLen) {
            guard offset + 8 <= bytes.count else { throw SDPDecodeError.insufficientData }
            let elemBits = bytes[offset..<offset+8].withUnsafeBytes { UInt64(littleEndian: $0.load(as: UInt64.self)) }
            let elem = Double(bitPattern: elemBits)
            offset += 8
            f64Array.append(elem)
        }
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let strArrayLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var strArray: [String] = []
        strArray.reserveCapacity(Int(strArrayLen))
        for _ in 0..<Int(strArrayLen) {
            guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
            let elemLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
            offset += 4
            guard offset + elemLen <= bytes.count else { throw SDPDecodeError.insufficientData }
            let elemBytes = Array(bytes[offset..<offset+elemLen])
            guard let elem = String(bytes: elemBytes, encoding: .utf8) else {
                throw SDPDecodeError.invalidUTF8
            }
            offset += elemLen
            strArray.append(elem)
        }
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let boolArrayLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var boolArray: [Bool] = []
        boolArray.reserveCapacity(Int(boolArrayLen))
        for _ in 0..<Int(boolArrayLen) {
            guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
            let elemByte = bytes[offset]
            guard elemByte == 0 || elemByte == 1 else { throw SDPDecodeError.invalidBoolValue }
            let elem = elemByte == 1
            offset += 1
            boolArray.append(elem)
        }

        return Self(
            u8Array: u8Array,
            u32Array: u32Array,
            f64Array: f64Array,
            strArray: strArray,
            boolArray: boolArray
        )
    }
}

extension Item {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let id = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + nameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameBytes = Array(bytes[offset..<offset+nameLen])
        guard let name = String(bytes: nameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen

        return Self(
            id: id,
            name: name
        )
    }
}

extension ArraysOfStructs {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let itemsLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var items: [Item] = []
        items.reserveCapacity(Int(itemsLen))
        for _ in 0..<Int(itemsLen) {
            let elem = try Item.decode(from: Array(bytes[offset...]))
            offset += elem.encodedSize()
            items.append(elem)
        }
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let count = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4

        return Self(
            items: items,
            count: count
        )
    }
}

