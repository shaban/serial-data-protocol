// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension ArraysOfPrimitives {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let u8ArrayLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var u8Array: [UInt8] = []
        u8Array.reserveCapacity(Int(u8ArrayLen))
        for _ in 0..<Int(u8ArrayLen) {
            guard offset < data.count else { throw SDPDecodeError.insufficientData }
            let elem = data[offset]
            offset += 1
            u8Array.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let u32ArrayLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var u32Array: [UInt32] = []
        u32Array.reserveCapacity(Int(u32ArrayLen))
        for _ in 0..<Int(u32ArrayLen) {
            guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
            let elem = data[offset..<offset+4].withUnsafeBytes {
                $0.load(as: UInt32.self).littleEndian
            }
            offset += 4
            u32Array.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let f64ArrayLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var f64Array: [Double] = []
        f64Array.reserveCapacity(Int(f64ArrayLen))
        for _ in 0..<Int(f64ArrayLen) {
            guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
            let elemBits = data[offset..<offset+8].withUnsafeBytes {
                $0.load(as: UInt64.self).littleEndian
            }
            let elem = Double(bitPattern: elemBits)
            offset += 8
            f64Array.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let strArrayLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var strArray: [String] = []
        strArray.reserveCapacity(Int(strArrayLen))
        for _ in 0..<Int(strArrayLen) {
            guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
            let elemLen = data[offset..<offset+4].withUnsafeBytes {
                $0.load(as: UInt32.self).littleEndian
            }
            offset += 4
            guard offset + Int(elemLen) <= data.count else { throw SDPDecodeError.insufficientData }
            let elemData = data[offset..<offset+Int(elemLen)]
            guard let elem = String(data: elemData, encoding: .utf8) else {
                throw SDPDecodeError.invalidUTF8
            }
            offset += Int(elemLen)
            strArray.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let boolArrayLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var boolArray: [Bool] = []
        boolArray.reserveCapacity(Int(boolArrayLen))
        for _ in 0..<Int(boolArrayLen) {
            guard offset < data.count else { throw SDPDecodeError.insufficientData }
            let elemByte = data[offset]
            guard elemByte == 0 || elemByte == 1 else { throw SDPDecodeError.invalidBoolValue }
            let elem = elemByte == 1
            offset += 1
            boolArray.append(elem)
        }

        return Self(
            u8Array: u8Array,
            u32Array: u32Array,
            f64Array: f64Array,
            strArray: strArray,
            boolArray: boolArray
        )
    }
}

extension Item {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let id = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let nameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(nameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+Int(nameLen)]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(nameLen)

        return Self(
            id: id,
            name: name
        )
    }
}

extension ArraysOfStructs {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let itemsLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var items: [Item] = []
        items.reserveCapacity(Int(itemsLen))
        for _ in 0..<Int(itemsLen) {
            let elem = try Item.decode(from: data[offset...])
            offset += elem.encodedSize()
            items.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let count = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4

        return Self(
            items: items,
            count: count
        )
    }
}

