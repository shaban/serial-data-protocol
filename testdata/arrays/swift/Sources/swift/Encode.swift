// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

extension ArraysOfPrimitives {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        let u8ArrayLen = UInt32(self.u8Array.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: u8ArrayLen) { Data($0) })
        for elem in self.u8Array {
            data.append(elem)
        }
        let u32ArrayLen = UInt32(self.u32Array.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: u32ArrayLen) { Data($0) })
        for elem in self.u32Array {
            data.append(contentsOf: withUnsafeBytes(of: elem.littleEndian) { Data($0) })
        }
        let f64ArrayLen = UInt32(self.f64Array.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: f64ArrayLen) { Data($0) })
        for elem in self.f64Array {
            let elemBits = elem.bitPattern.littleEndian
            data.append(contentsOf: withUnsafeBytes(of: elemBits) { Data($0) })
        }
        let strArrayLen = UInt32(self.strArray.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: strArrayLen) { Data($0) })
        for elem in self.strArray {
            let elemData = elem.data(using: .utf8)!
            let elemLen = UInt32(elemData.count).littleEndian
            data.append(contentsOf: withUnsafeBytes(of: elemLen) { Data($0) })
            data.append(elemData)
        }
        let boolArrayLen = UInt32(self.boolArray.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: boolArrayLen) { Data($0) })
        for elem in self.boolArray {
            data.append(elem ? 1 : 0)
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 // array length
        size += self.u8Array.count * 1
        size += 4 // array length
        size += self.u32Array.count * 4
        size += 4 // array length
        size += self.f64Array.count * 8
        size += 4 // array length
        for elem in self.strArray {
            size += 4 + elem.utf8.count
        }
        size += 4 // array length
        size += self.boolArray.count * 1
        return size
    }
}

extension Item {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        data.append(contentsOf: withUnsafeBytes(of: self.id.littleEndian) { Data($0) })
        let nameData = self.name.data(using: .utf8)!
        let nameLen = UInt32(nameData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: nameLen) { Data($0) })
        data.append(nameData)
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4 + self.name.utf8.count
        return size
    }
}

extension ArraysOfStructs {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        let itemsLen = UInt32(self.items.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: itemsLen) { Data($0) })
        for elem in self.items {
            try elem.encode(to: &data)
        }
        data.append(contentsOf: withUnsafeBytes(of: self.count.littleEndian) { Data($0) })
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 // array length
        for elem in self.items {
            size += elem.encodedSize()
        }
        size += 4
        return size
    }
}

