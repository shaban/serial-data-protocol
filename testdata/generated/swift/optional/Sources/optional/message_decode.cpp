// Auto-generated by sdp-gen. DO NOT EDIT.
// Message mode decoders - implementation.

#include "message_decode.hpp"
#include "message_encode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

Request DecodeRequestMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 1) {
        throw MessageDecodeError("Wrong type ID: expected 1 (Request), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return request_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

Metadata DecodeMetadataMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 2) {
        throw MessageDecodeError("Wrong type ID: expected 2 (Metadata), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return metadata_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

Config DecodeConfigMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 3) {
        throw MessageDecodeError("Wrong type ID: expected 3 (Config), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return config_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

DatabaseConfig DecodeDatabaseConfigMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 4) {
        throw MessageDecodeError("Wrong type ID: expected 4 (DatabaseConfig), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return database_config_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

CacheConfig DecodeCacheConfigMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 5) {
        throw MessageDecodeError("Wrong type ID: expected 5 (CacheConfig), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return cache_config_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

Document DecodeDocumentMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 6) {
        throw MessageDecodeError("Wrong type ID: expected 6 (Document), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return document_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

TagList DecodeTagListMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 7) {
        throw MessageDecodeError("Wrong type ID: expected 7 (TagList), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return tag_list_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

MessageVariant DecodeMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Extract type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));

    // Dispatch to specific decoder
    switch (typeID) {
    case 1:
        return DecodeRequestMessage(data);
    case 2:
        return DecodeMetadataMessage(data);
    case 3:
        return DecodeConfigMessage(data);
    case 4:
        return DecodeDatabaseConfigMessage(data);
    case 5:
        return DecodeCacheConfigMessage(data);
    case 6:
        return DecodeDocumentMessage(data);
    case 7:
        return DecodeTagListMessage(data);
    default:
        throw MessageDecodeError("Unknown type ID: " + std::to_string(typeID));
    }
}

} // namespace sdp
