// Auto-generated by sdp-gen. DO NOT EDIT.
// Message mode encoders - implementation.

#include "message_encode.hpp"
#include "endian.hpp"
#include <stdexcept>

namespace sdp {

std::vector<uint8_t> EncodeRequestMessage(const Request& src) {
    // Calculate payload size
    size_t payloadSize = request_size(src);

    // Allocate message buffer (header + payload)
    size_t messageSize = MESSAGE_HEADER_SIZE + payloadSize;
    std::vector<uint8_t> message(messageSize);
    uint8_t* buf = message.data();

    // Write header
    std::memcpy(buf, MESSAGE_MAGIC, 3);  // Magic bytes 'SDP'
    buf[3] = MESSAGE_VERSION;            // Protocol version '2'
    *(uint16_t*)(buf + 4) = SDP_HTOLE16(1);  // Type ID
    *(uint32_t*)(buf + 6) = SDP_HTOLE32(static_cast<uint32_t>(payloadSize));  // Payload length

    // Encode payload
    request_encode(src, buf + MESSAGE_HEADER_SIZE);

    return message;
}

std::vector<uint8_t> EncodeMetadataMessage(const Metadata& src) {
    // Calculate payload size
    size_t payloadSize = metadata_size(src);

    // Allocate message buffer (header + payload)
    size_t messageSize = MESSAGE_HEADER_SIZE + payloadSize;
    std::vector<uint8_t> message(messageSize);
    uint8_t* buf = message.data();

    // Write header
    std::memcpy(buf, MESSAGE_MAGIC, 3);  // Magic bytes 'SDP'
    buf[3] = MESSAGE_VERSION;            // Protocol version '2'
    *(uint16_t*)(buf + 4) = SDP_HTOLE16(2);  // Type ID
    *(uint32_t*)(buf + 6) = SDP_HTOLE32(static_cast<uint32_t>(payloadSize));  // Payload length

    // Encode payload
    metadata_encode(src, buf + MESSAGE_HEADER_SIZE);

    return message;
}

std::vector<uint8_t> EncodeConfigMessage(const Config& src) {
    // Calculate payload size
    size_t payloadSize = config_size(src);

    // Allocate message buffer (header + payload)
    size_t messageSize = MESSAGE_HEADER_SIZE + payloadSize;
    std::vector<uint8_t> message(messageSize);
    uint8_t* buf = message.data();

    // Write header
    std::memcpy(buf, MESSAGE_MAGIC, 3);  // Magic bytes 'SDP'
    buf[3] = MESSAGE_VERSION;            // Protocol version '2'
    *(uint16_t*)(buf + 4) = SDP_HTOLE16(3);  // Type ID
    *(uint32_t*)(buf + 6) = SDP_HTOLE32(static_cast<uint32_t>(payloadSize));  // Payload length

    // Encode payload
    config_encode(src, buf + MESSAGE_HEADER_SIZE);

    return message;
}

std::vector<uint8_t> EncodeDatabaseConfigMessage(const DatabaseConfig& src) {
    // Calculate payload size
    size_t payloadSize = database_config_size(src);

    // Allocate message buffer (header + payload)
    size_t messageSize = MESSAGE_HEADER_SIZE + payloadSize;
    std::vector<uint8_t> message(messageSize);
    uint8_t* buf = message.data();

    // Write header
    std::memcpy(buf, MESSAGE_MAGIC, 3);  // Magic bytes 'SDP'
    buf[3] = MESSAGE_VERSION;            // Protocol version '2'
    *(uint16_t*)(buf + 4) = SDP_HTOLE16(4);  // Type ID
    *(uint32_t*)(buf + 6) = SDP_HTOLE32(static_cast<uint32_t>(payloadSize));  // Payload length

    // Encode payload
    database_config_encode(src, buf + MESSAGE_HEADER_SIZE);

    return message;
}

std::vector<uint8_t> EncodeCacheConfigMessage(const CacheConfig& src) {
    // Calculate payload size
    size_t payloadSize = cache_config_size(src);

    // Allocate message buffer (header + payload)
    size_t messageSize = MESSAGE_HEADER_SIZE + payloadSize;
    std::vector<uint8_t> message(messageSize);
    uint8_t* buf = message.data();

    // Write header
    std::memcpy(buf, MESSAGE_MAGIC, 3);  // Magic bytes 'SDP'
    buf[3] = MESSAGE_VERSION;            // Protocol version '2'
    *(uint16_t*)(buf + 4) = SDP_HTOLE16(5);  // Type ID
    *(uint32_t*)(buf + 6) = SDP_HTOLE32(static_cast<uint32_t>(payloadSize));  // Payload length

    // Encode payload
    cache_config_encode(src, buf + MESSAGE_HEADER_SIZE);

    return message;
}

std::vector<uint8_t> EncodeDocumentMessage(const Document& src) {
    // Calculate payload size
    size_t payloadSize = document_size(src);

    // Allocate message buffer (header + payload)
    size_t messageSize = MESSAGE_HEADER_SIZE + payloadSize;
    std::vector<uint8_t> message(messageSize);
    uint8_t* buf = message.data();

    // Write header
    std::memcpy(buf, MESSAGE_MAGIC, 3);  // Magic bytes 'SDP'
    buf[3] = MESSAGE_VERSION;            // Protocol version '2'
    *(uint16_t*)(buf + 4) = SDP_HTOLE16(6);  // Type ID
    *(uint32_t*)(buf + 6) = SDP_HTOLE32(static_cast<uint32_t>(payloadSize));  // Payload length

    // Encode payload
    document_encode(src, buf + MESSAGE_HEADER_SIZE);

    return message;
}

std::vector<uint8_t> EncodeTagListMessage(const TagList& src) {
    // Calculate payload size
    size_t payloadSize = tag_list_size(src);

    // Allocate message buffer (header + payload)
    size_t messageSize = MESSAGE_HEADER_SIZE + payloadSize;
    std::vector<uint8_t> message(messageSize);
    uint8_t* buf = message.data();

    // Write header
    std::memcpy(buf, MESSAGE_MAGIC, 3);  // Magic bytes 'SDP'
    buf[3] = MESSAGE_VERSION;            // Protocol version '2'
    *(uint16_t*)(buf + 4) = SDP_HTOLE16(7);  // Type ID
    *(uint32_t*)(buf + 6) = SDP_HTOLE32(static_cast<uint32_t>(payloadSize));  // Payload length

    // Encode payload
    tag_list_encode(src, buf + MESSAGE_HEADER_SIZE);

    return message;
}

} // namespace sdp
