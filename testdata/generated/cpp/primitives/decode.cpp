/* decode.cpp - Decoding implementations for primitives
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "decode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

/* Forward declarations for internal decode helpers */
static AllPrimitives all_primitives_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);

static AllPrimitives all_primitives_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    AllPrimitives result;

    /* u8_field */
    if (offset + 1 > buf_len) throw DecodeError("Buffer too small");
    result.u8_field = buf[offset++];

    /* u16_field */
    if (offset + 2 > buf_len) throw DecodeError("Buffer too small");
    result.u16_field = SDP_LE16TOH(*(const uint16_t*)(buf + offset));
    offset += 2;

    /* u32_field */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.u32_field = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* u64_field */
    if (offset + 8 > buf_len) throw DecodeError("Buffer too small");
    result.u64_field = SDP_LE64TOH(*(const uint64_t*)(buf + offset));
    offset += 8;

    /* i8_field */
    if (offset + 1 > buf_len) throw DecodeError("Buffer too small");
    result.i8_field = (int8_t)buf[offset++];

    /* i16_field */
    if (offset + 2 > buf_len) throw DecodeError("Buffer too small");
    result.i16_field = (int16_t)SDP_LE16TOH(*(const uint16_t*)(buf + offset));
    offset += 2;

    /* i32_field */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.i32_field = (int32_t)SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* i64_field */
    if (offset + 8 > buf_len) throw DecodeError("Buffer too small");
    result.i64_field = (int64_t)SDP_LE64TOH(*(const uint64_t*)(buf + offset));
    offset += 8;

    /* f32_field */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.f32_field = sdp_le_to_f32(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* f64_field */
    if (offset + 8 > buf_len) throw DecodeError("Buffer too small");
    result.f64_field = sdp_le_to_f64(*(const uint64_t*)(buf + offset));
    offset += 8;

    /* bool_field */
    if (offset + 1 > buf_len) throw DecodeError("Buffer too small");
    result.bool_field = buf[offset++] != 0;

    /* str_field */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t str_field_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + str_field_len > buf_len) throw DecodeError("Buffer too small");
    result.str_field = std::string(reinterpret_cast<const char*>(buf + offset), str_field_len);
    offset += str_field_len;

    return result;
}

AllPrimitives all_primitives_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return all_primitives_decode_impl(buf, buf_len, offset);
}

}  // namespace sdp
