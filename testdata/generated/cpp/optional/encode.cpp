/* encode.cpp - Encoding implementations for optional
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "encode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

size_t request_size(const Request& msg) {
    size_t size = 0;
    size += 4;  // id
    size += 1;  // metadata presence
    if (msg.metadata.has_value()) {
        size += metadata_size(*msg.metadata);
    }
    return size;
}

size_t request_encode(const Request& msg, uint8_t* buf) {
    size_t offset = 0;

    /* id */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.id);
        offset += 4;

    /* metadata */
    buf[offset++] = msg.metadata.has_value() ? 1 : 0;
    if (msg.metadata.has_value()) {
        offset += metadata_encode(*msg.metadata, buf + offset);
    }

    return offset;
}

size_t metadata_size(const Metadata& msg) {
    size_t size = 0;
    size += 8;  // user_id
    size += 4 + msg.username.size();  // username
    return size;
}

size_t metadata_encode(const Metadata& msg, uint8_t* buf) {
    size_t offset = 0;

    /* user_id */
        *(uint64_t*)(buf + offset) = SDP_HTOLE64(msg.user_id);
        offset += 8;

    /* username */
    uint32_t username_len = msg.username.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(username_len);
    offset += 4;
    std::memcpy(buf + offset, msg.username.data(), username_len);
    offset += username_len;

    return offset;
}

size_t config_size(const Config& msg) {
    size_t size = 0;
    size += 4 + msg.name.size();  // name
    size += 1;  // database presence
    if (msg.database.has_value()) {
        size += database_config_size(*msg.database);
    }
    size += 1;  // cache presence
    if (msg.cache.has_value()) {
        size += cache_config_size(*msg.cache);
    }
    return size;
}

size_t config_encode(const Config& msg, uint8_t* buf) {
    size_t offset = 0;

    /* name */
    uint32_t name_len = msg.name.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
    offset += 4;
    std::memcpy(buf + offset, msg.name.data(), name_len);
    offset += name_len;

    /* database */
    buf[offset++] = msg.database.has_value() ? 1 : 0;
    if (msg.database.has_value()) {
        offset += database_config_encode(*msg.database, buf + offset);
    }

    /* cache */
    buf[offset++] = msg.cache.has_value() ? 1 : 0;
    if (msg.cache.has_value()) {
        offset += cache_config_encode(*msg.cache, buf + offset);
    }

    return offset;
}

size_t database_config_size(const DatabaseConfig& msg) {
    size_t size = 0;
    size += 4 + msg.host.size();  // host
    size += 2;  // port
    return size;
}

size_t database_config_encode(const DatabaseConfig& msg, uint8_t* buf) {
    size_t offset = 0;

    /* host */
    uint32_t host_len = msg.host.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(host_len);
    offset += 4;
    std::memcpy(buf + offset, msg.host.data(), host_len);
    offset += host_len;

    /* port */
        *(uint16_t*)(buf + offset) = SDP_HTOLE16(msg.port);
        offset += 2;

    return offset;
}

size_t cache_config_size(const CacheConfig& msg) {
    (void)msg;  // Fixed-size struct, parameter unused
    size_t size = 0;
    size += 4;  // size_mb
    size += 4;  // ttl_seconds
    return size;
}

size_t cache_config_encode(const CacheConfig& msg, uint8_t* buf) {
    size_t offset = 0;

    /* size_mb */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.size_mb);
        offset += 4;

    /* ttl_seconds */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.ttl_seconds);
        offset += 4;

    return offset;
}

size_t document_size(const Document& msg) {
    size_t size = 0;
    size += 4;  // id
    size += 1;  // tags presence
    if (msg.tags.has_value()) {
        size += tag_list_size(*msg.tags);
    }
    return size;
}

size_t document_encode(const Document& msg, uint8_t* buf) {
    size_t offset = 0;

    /* id */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.id);
        offset += 4;

    /* tags */
    buf[offset++] = msg.tags.has_value() ? 1 : 0;
    if (msg.tags.has_value()) {
        offset += tag_list_encode(*msg.tags, buf + offset);
    }

    return offset;
}

size_t tag_list_size(const TagList& msg) {
    size_t size = 0;
    size += 4;  // items count
    for (const auto& elem : msg.items) {
        size += 4 + elem.size();
    }
    return size;
}

size_t tag_list_encode(const TagList& msg, uint8_t* buf) {
    size_t offset = 0;

    /* items */
    uint32_t items_count = msg.items.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(items_count);
    offset += 4;
    for (const auto& elem : msg.items) {
        uint32_t len = elem.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(len);
        offset += 4;
        std::memcpy(buf + offset, elem.data(), len);
        offset += len;
    }

    return offset;
}

}  // namespace sdp
