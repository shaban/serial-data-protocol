// Auto-generated by sdp-gen. DO NOT EDIT.
// Message mode decoders - implementation.

#include "message_decode.hpp"
#include "message_encode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

Point DecodePointMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 1) {
        throw MessageDecodeError("Wrong type ID: expected 1 (Point), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return point_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

Rectangle DecodeRectangleMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 2) {
        throw MessageDecodeError("Wrong type ID: expected 2 (Rectangle), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return rectangle_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

Scene DecodeSceneMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Validate type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));
    if (typeID != 3) {
        throw MessageDecodeError("Wrong type ID: expected 3 (Scene), got " + std::to_string(typeID));
    }

    // Extract payload length
    uint32_t payloadLength = SDP_LE32TOH(*(const uint32_t*)(data.data() + 6));

    // Validate total message size
    size_t expectedSize = MESSAGE_HEADER_SIZE + payloadLength;
    if (data.size() < expectedSize) {
        throw MessageDecodeError("Message too short: expected " + 
            std::to_string(expectedSize) + " bytes, got " + std::to_string(data.size()));
    }

    // Decode payload
    return scene_decode(data.data() + MESSAGE_HEADER_SIZE, payloadLength);
}

MessageVariant DecodeMessage(const std::vector<uint8_t>& data) {
    // Check minimum message size
    if (data.size() < MESSAGE_HEADER_SIZE) {
        throw MessageDecodeError("Message too short: expected at least " + 
            std::to_string(MESSAGE_HEADER_SIZE) + " bytes, got " + std::to_string(data.size()));
    }

    // Validate magic bytes
    if (std::memcmp(data.data(), MESSAGE_MAGIC, 3) != 0) {
        throw MessageDecodeError("Invalid magic bytes: expected 'SDP'");
    }

    // Validate protocol version
    if (data[3] != MESSAGE_VERSION) {
        throw MessageDecodeError("Invalid version: expected " + 
            std::to_string(MESSAGE_VERSION) + ", got " + std::to_string(data[3]));
    }

    // Extract type ID
    uint16_t typeID = SDP_LE16TOH(*(const uint16_t*)(data.data() + 4));

    // Dispatch to specific decoder
    switch (typeID) {
    case 1:
        return DecodePointMessage(data);
    case 2:
        return DecodeRectangleMessage(data);
    case 3:
        return DecodeSceneMessage(data);
    default:
        throw MessageDecodeError("Unknown type ID: " + std::to_string(typeID));
    }
}

} // namespace sdp
