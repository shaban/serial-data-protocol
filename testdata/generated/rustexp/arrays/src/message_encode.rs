// Auto-generated by sdp-gen. DO NOT EDIT.
// Message mode encoders - self-describing messages with type headers.

use byteorder::{ByteOrder, LittleEndian};
use crate::types::*;
use crate::encode::*;

/// Message mode constants
pub const MESSAGE_HEADER_SIZE: usize = 10;
pub const MESSAGE_MAGIC: &[u8; 3] = b"SDP";
pub const MESSAGE_VERSION: u8 = b'2';  // ASCII '2' for v0.2.0

/// Encodes a ArraysOfPrimitives to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 1
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_arrays_of_primitives_message(src: &ArraysOfPrimitives) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 1);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a Item to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 2
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_item_message(src: &Item) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 2);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

/// Encodes a ArraysOfStructs to self-describing message format.
///
/// Wire format: [SDP:3][version:1][type_id:2][length:4][payload:N]
/// - Type ID: 3
/// - Header: 10 bytes
/// - Total size: 10 + payload_size bytes
///
/// This format is suitable for:
/// - Persistence (databases, files)
/// - Network transmission (RPC, queues)
/// - Cross-service communication
pub fn encode_arrays_of_structs_message(src: &ArraysOfStructs) -> Vec<u8> {
    // Encode payload using byte mode encoder
    let payload_size = src.encoded_size();
    let mut payload = vec![0u8; payload_size];
    src.encode_to_slice(&mut payload).expect("encoding failed");

    // Allocate message buffer (header + payload)
    let message_size = MESSAGE_HEADER_SIZE + payload.len();
    let mut message = vec![0u8; message_size];

    // Write header
    message[0..3].copy_from_slice(MESSAGE_MAGIC);  // Magic bytes 'SDP'
    message[3] = MESSAGE_VERSION;                  // Protocol version '2'
    LittleEndian::write_u16(&mut message[4..6], 3);  // Type ID
    LittleEndian::write_u32(&mut message[6..10], payload.len() as u32);  // Payload length

    // Copy payload
    message[10..].copy_from_slice(&payload);

    message
}

