// Code generated by sdp-gen. DO NOT EDIT.

use super::types::*;
use super::wire_slice::{self, SliceResult as Result};

impl ArraysOfPrimitives {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        // Experimental fast-path decode for primitive arrays
        let u8_array = if array_len > 0 {
            wire_slice::check_bounds(buf, offset, array_len)?;
            let slice = &buf[offset..offset + array_len];
            offset += array_len;
            slice.to_vec()
        } else {
            Vec::new()
        };
        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        // Experimental fast-path decode for primitive arrays
        let u32_array = if array_len > 0 {
            let byte_len = array_len * 4;
            wire_slice::check_bounds(buf, offset, byte_len)?;
            let bytes = &buf[offset..offset + byte_len];
            offset += byte_len;
            wire_slice::decode_u32_array_fast(bytes, array_len)?
        } else {
            Vec::new()
        };
        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        // Experimental fast-path decode for primitive arrays
        let f64_array = if array_len > 0 {
            let byte_len = array_len * 8;
            wire_slice::check_bounds(buf, offset, byte_len)?;
            let bytes = &buf[offset..offset + byte_len];
            offset += byte_len;
            wire_slice::decode_f64_array_fast(bytes, array_len)?
        } else {
            Vec::new()
        };
        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        let mut str_array = Vec::with_capacity(array_len);
        for _ in 0..array_len {
            let (item, consumed) = wire_slice::decode_string(buf, offset)?;
            offset += consumed;
            str_array.push(item);
        }
        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        let mut bool_array = Vec::with_capacity(array_len);
        for _ in 0..array_len {
            let item = wire_slice::decode_bool(buf, offset)?;
            offset += 1;
            bool_array.push(item);
        }

        Ok(Self {
            u8_array,
            u32_array,
            f64_array,
            str_array,
            bool_array,
        })
    }
}

impl Item {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let id = wire_slice::decode_u32(buf, offset)?;
        offset += 4;
        let (name, consumed) = wire_slice::decode_string(buf, offset)?;
        offset += consumed;

        Ok(Self {
            id,
            name,
        })
    }
}

impl ArraysOfStructs {
    /// Decode from a byte slice (IPC mode - fast path)
    pub fn decode_from_slice(buf: &[u8]) -> Result<Self> {
        let mut offset = 0;

        let array_len = wire_slice::decode_u32(buf, offset)? as usize;
        offset += 4;
        let mut items = Vec::with_capacity(array_len);
        for _ in 0..array_len {
            let item = Item::decode_from_slice(&buf[offset..])?;
            offset += item.encoded_size();
            items.push(item);
        }
        let count = wire_slice::decode_u32(buf, offset)?;
        offset += 4;

        Ok(Self {
            items,
            count,
        })
    }
}

