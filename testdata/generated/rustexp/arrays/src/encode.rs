// Code generated by sdp-gen. DO NOT EDIT.

use super::types::*;
use super::wire_slice::{self, SliceResult as Result};

impl ArraysOfPrimitives {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.u8_array.len() as u32)?;
        offset += 4;
        // Bulk encode optimization for primitive arrays
        if !self.u8_array.is_empty() {
            let src = if std::mem::size_of::<i8>() == 1 {
                unsafe { std::slice::from_raw_parts(self.u8_array.as_ptr() as *const u8, self.u8_array.len()) }
            } else { unreachable!() };
            wire_slice::check_bounds(buf, offset, src.len())?;
            buf[offset..offset + src.len()].copy_from_slice(src);
            offset += src.len();
        }
        wire_slice::encode_u32(buf, offset, self.u32_array.len() as u32)?;
        offset += 4;
        // Bulk encode optimization for primitive arrays
        if !self.u32_array.is_empty() {
            let bytes = bytemuck::cast_slice(&self.u32_array);
            wire_slice::check_bounds(buf, offset, bytes.len())?;
            buf[offset..offset + bytes.len()].copy_from_slice(bytes);
            offset += bytes.len();
        }
        wire_slice::encode_u32(buf, offset, self.f64_array.len() as u32)?;
        offset += 4;
        // Bulk encode optimization for primitive arrays
        if !self.f64_array.is_empty() {
            let bytes = bytemuck::cast_slice(&self.f64_array);
            wire_slice::check_bounds(buf, offset, bytes.len())?;
            buf[offset..offset + bytes.len()].copy_from_slice(bytes);
            offset += bytes.len();
        }
        wire_slice::encode_u32(buf, offset, self.str_array.len() as u32)?;
        offset += 4;
        for item in &self.str_array {
            let written = wire_slice::encode_string(buf, offset, item)?;
            offset += written;
        }
        wire_slice::encode_u32(buf, offset, self.bool_array.len() as u32)?;
        offset += 4;
        for item in &self.bool_array {
            wire_slice::encode_bool(buf, offset, *item)?;
            offset += 1;
        }

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // array length
        size += self.u8_array.len() * 1;
        size += 4; // array length
        size += self.u32_array.len() * 4;
        size += 4; // array length
        size += self.f64_array.len() * 8;
        size += 4; // array length
        for item in &self.str_array {
            size += 4 + item.len(); // length + bytes
        }
        size += 4; // array length
        size += self.bool_array.len() * 1;

        size
    }
}

impl Item {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.id)?;
        offset += 4;
        let written = wire_slice::encode_string(buf, offset, &self.name)?;
        offset += written;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // u32
        size += 4 + self.name.len(); // length + bytes

        size
    }
}

impl ArraysOfStructs {
    /// Encode to a byte slice (IPC mode - fast path)
    /// Returns the number of bytes written
    pub fn encode_to_slice(&self, buf: &mut [u8]) -> Result<usize> {
        let mut offset = 0;

        wire_slice::encode_u32(buf, offset, self.items.len() as u32)?;
        offset += 4;
        for item in &self.items {
            let written = item.encode_to_slice(&mut buf[offset..])?;
            offset += written;
        }
        wire_slice::encode_u32(buf, offset, self.count)?;
        offset += 4;

        Ok(offset)
    }

    /// Calculate the exact size needed for encoding
    pub fn encoded_size(&self) -> usize {
        let mut size = 0;

        size += 4; // array length
        for item in &self.items {
            size += item.encoded_size();
        }
        size += 4; // u32

        size
    }
}

