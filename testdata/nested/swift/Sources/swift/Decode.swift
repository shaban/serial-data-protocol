// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Point {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let xBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let x = Float(bitPattern: xBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let yBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let y = Float(bitPattern: yBits)
        offset += 4

        return Self(
            x: x,
            y: y
        )
    }
}

extension Rectangle {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        let topLeft = try Point.decode(from: data[offset...])
        offset += topLeft.encodedSize()
        let bottomRight = try Point.decode(from: data[offset...])
        offset += bottomRight.encodedSize()
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let color = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4

        return Self(
            topLeft: topLeft,
            bottomRight: bottomRight,
            color: color
        )
    }
}

extension Scene {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let nameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(nameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+Int(nameLen)]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(nameLen)
        let mainRect = try Rectangle.decode(from: data[offset...])
        offset += mainRect.encodedSize()
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let count = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4

        return Self(
            name: name,
            mainRect: mainRect,
            count: count
        )
    }
}

