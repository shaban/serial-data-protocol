// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (3x faster decoding).
// All memory accesses are bounds-checked once at function entry.
// Safe for use - the unsafe operations are verified by the code generator.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Point {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let xPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let xBits = UInt32(littleEndian: xPtr.load(as: UInt32.self))
            let x = Float(bitPattern: xBits)
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let yPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let yBits = UInt32(littleEndian: yPtr.load(as: UInt32.self))
            let y = Float(bitPattern: yBits)
            offset += 4

            return Self(
                x: x,
                y: y
            )
        }
    }
}

extension Rectangle {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            // Decode nested struct Point
            let topLeft = try Point.decode(from: Array(bytes[offset...]))
            offset += topLeft.encodedSize()
            // Decode nested struct Point
            let bottomRight = try Point.decode(from: Array(bytes[offset...]))
            offset += bottomRight.encodedSize()
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let colorPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let color = UInt32(littleEndian: colorPtr.load(as: UInt32.self))
            offset += 4

            return Self(
                topLeft: topLeft,
                bottomRight: bottomRight,
                color: color
            )
        }
    }
}

extension Scene {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let nameLen = Int(UInt32(littleEndian: nameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + nameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: nameLen)
            let name = String(decoding: nameBuffer, as: UTF8.self)
            offset += nameLen
            // Decode nested struct Rectangle
            let mainRect = try Rectangle.decode(from: Array(bytes[offset...]))
            offset += mainRect.encodedSize()
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let countPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let count = UInt32(littleEndian: countPtr.load(as: UInt32.self))
            offset += 4

            return Self(
                name: name,
                mainRect: mainRect,
                count: count
            )
        }
    }
}

