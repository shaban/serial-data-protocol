// Code generated by sdp-gen. DO NOT EDIT.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Point {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let xBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let x = Float(bitPattern: xBits)
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let yBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let y = Float(bitPattern: yBits)
        offset += 4

        return Self(
            x: x,
            y: y
        )
    }
}

extension Rectangle {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        let topLeft = try Point.decode(from: Array(bytes[offset...]))
        offset += topLeft.encodedSize()
        let bottomRight = try Point.decode(from: Array(bytes[offset...]))
        offset += bottomRight.encodedSize()
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let color = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4

        return Self(
            topLeft: topLeft,
            bottomRight: bottomRight,
            color: color
        )
    }
}

extension Scene {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + nameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameBytes = Array(bytes[offset..<offset+nameLen])
        guard let name = String(bytes: nameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        let mainRect = try Rectangle.decode(from: Array(bytes[offset...]))
        offset += mainRect.encodedSize()
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let count = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4

        return Self(
            name: name,
            mainRect: mainRect,
            count: count
        )
    }
}

