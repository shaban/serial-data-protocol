// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Point {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var xBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &xBitsBytes, from: offset..<offset+4)
        let xBits = UInt32(littleEndian: xBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let x = Float(bitPattern: xBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var yBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &yBitsBytes, from: offset..<offset+4)
        let yBits = UInt32(littleEndian: yBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let y = Float(bitPattern: yBits)
        offset += 4

        return Self(
            x: x,
            y: y
        )
    }
}

extension Rectangle {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        let topLeft = try Point.decode(from: data[offset...])
        offset += topLeft.encodedSize()
        let bottomRight = try Point.decode(from: data[offset...])
        offset += bottomRight.encodedSize()
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var colorBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &colorBytes, from: offset..<offset+4)
        let color = UInt32(littleEndian: colorBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4

        return Self(
            topLeft: topLeft,
            bottomRight: bottomRight,
            color: color
        )
    }
}

extension Scene {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var nameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &nameLenBytes, from: offset..<offset+4)
        let nameLen = Int(UInt32(littleEndian: nameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + nameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+nameLen]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        let mainRect = try Rectangle.decode(from: data[offset...])
        offset += mainRect.encodedSize()
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var countBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &countBytes, from: offset..<offset+4)
        let count = UInt32(littleEndian: countBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4

        return Self(
            name: name,
            mainRect: mainRect,
            count: count
        )
    }
}

