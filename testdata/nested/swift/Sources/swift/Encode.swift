// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (8x faster encoding).
// All memory accesses are bounds-checked at buffer allocation.
// Safe for use - the unsafe operations are verified by the code generator.

extension Point {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let xBits = self.x.bitPattern.littleEndian
            withUnsafeBytes(of: xBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let yBits = self.y.bitPattern.littleEndian
            withUnsafeBytes(of: yBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4
        return size
    }
}

extension Rectangle {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            // Nested struct: topLeft
            let topLeftBytes = self.topLeft.encodeToBytes()
            topLeftBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: topLeftBytes.count)
            }
            offset += topLeftBytes.count
            // Nested struct: bottomRight
            let bottomRightBytes = self.bottomRight.encodeToBytes()
            bottomRightBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: bottomRightBytes.count)
            }
            offset += bottomRightBytes.count
            let colorLE = self.color.littleEndian
            withUnsafeBytes(of: colorLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += self.topLeft.encodedSize()
        size += self.bottomRight.encodedSize()
        size += 4
        return size
    }
}

extension Scene {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let nameBytes = Array(self.name.utf8)
            let nameLen = UInt32(nameBytes.count).littleEndian
            withUnsafeBytes(of: nameLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            nameBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: nameBytes.count)
            }
            offset += nameBytes.count
            // Nested struct: mainRect
            let mainRectBytes = self.mainRect.encodeToBytes()
            mainRectBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: mainRectBytes.count)
            }
            offset += mainRectBytes.count
            let countLE = self.count.littleEndian
            withUnsafeBytes(of: countLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.name.utf8.count
        size += self.mainRect.encodedSize()
        size += 4
        return size
    }
}

