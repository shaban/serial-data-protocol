// Code generated by sdp-gen. DO NOT EDIT.

extension Point {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        let xBits = self.x.bitPattern.littleEndian
        withUnsafeBytes(of: xBits) { bytes.append(contentsOf: $0) }
        let yBits = self.y.bitPattern.littleEndian
        withUnsafeBytes(of: yBits) { bytes.append(contentsOf: $0) }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4
        return size
    }
}

extension Rectangle {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        try self.topLeft.encode(to: &data)
        try self.bottomRight.encode(to: &data)
        withUnsafeBytes(of: self.color.littleEndian) { bytes.append(contentsOf: $0) }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += self.topLeft.encodedSize()
        size += self.bottomRight.encodedSize()
        size += 4
        return size
    }
}

extension Scene {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        let nameBytes = Array(self.name.utf8)
        let nameLen = UInt32(nameBytes.count).littleEndian
        withUnsafeBytes(of: nameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: nameBytes)
        try self.mainRect.encode(to: &data)
        withUnsafeBytes(of: self.count.littleEndian) { bytes.append(contentsOf: $0) }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.name.utf8.count
        size += self.mainRect.encodedSize()
        size += 4
        return size
    }
}

