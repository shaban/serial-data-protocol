// Code generated by sdp-gen. DO NOT EDIT.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Request {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let id = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let metadataPresent = bytes[offset]
        offset += 1
        let metadata: Metadata?
        if metadataPresent == 1 {
            let value = try Metadata.decode(from: Array(bytes[offset...]))
            offset += value.encodedSize()
            metadata = value
        } else {
            metadata = nil
        }

        return Self(
            id: id,
            metadata: metadata
        )
    }
}

extension Metadata {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 8 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let userId = bytes[offset..<offset+8].withUnsafeBytes { UInt64(littleEndian: $0.load(as: UInt64.self)) }
        offset += 8
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let usernameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + usernameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let usernameBytes = Array(bytes[offset..<offset+usernameLen])
        guard let username = String(bytes: usernameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += usernameLen

        return Self(
            userId: userId,
            username: username
        )
    }
}

extension Config {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + nameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameBytes = Array(bytes[offset..<offset+nameLen])
        guard let name = String(bytes: nameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let databasePresent = bytes[offset]
        offset += 1
        let database: DatabaseConfig?
        if databasePresent == 1 {
            let value = try DatabaseConfig.decode(from: Array(bytes[offset...]))
            offset += value.encodedSize()
            database = value
        } else {
            database = nil
        }
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let cachePresent = bytes[offset]
        offset += 1
        let cache: CacheConfig?
        if cachePresent == 1 {
            let value = try CacheConfig.decode(from: Array(bytes[offset...]))
            offset += value.encodedSize()
            cache = value
        } else {
            cache = nil
        }

        return Self(
            name: name,
            database: database,
            cache: cache
        )
    }
}

extension DatabaseConfig {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let hostLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + hostLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let hostBytes = Array(bytes[offset..<offset+hostLen])
        guard let host = String(bytes: hostBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += hostLen
        guard offset + 2 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let port = bytes[offset..<offset+2].withUnsafeBytes { UInt16(littleEndian: $0.load(as: UInt16.self)) }
        offset += 2

        return Self(
            host: host,
            port: port
        )
    }
}

extension CacheConfig {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let sizeMb = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let ttlSeconds = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4

        return Self(
            sizeMb: sizeMb,
            ttlSeconds: ttlSeconds
        )
    }
}

extension Document {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let id = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let tagsPresent = bytes[offset]
        offset += 1
        let tags: TagList?
        if tagsPresent == 1 {
            let value = try TagList.decode(from: Array(bytes[offset...]))
            offset += value.encodedSize()
            tags = value
        } else {
            tags = nil
        }

        return Self(
            id: id,
            tags: tags
        )
    }
}

extension TagList {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let itemsLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var items: [String] = []
        items.reserveCapacity(Int(itemsLen))
        for _ in 0..<Int(itemsLen) {
            guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
            let elemLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
            offset += 4
            guard offset + elemLen <= bytes.count else { throw SDPDecodeError.insufficientData }
            let elemBytes = Array(bytes[offset..<offset+elemLen])
            guard let elem = String(bytes: elemBytes, encoding: .utf8) else {
                throw SDPDecodeError.invalidUTF8
            }
            offset += elemLen
            items.append(elem)
        }

        return Self(
            items: items
        )
    }
}

