// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Request {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let id = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let metadataPresent = data[offset]
        offset += 1
        let metadata: Metadata?
        if metadataPresent == 1 {
            let value = try Metadata.decode(from: data[offset...])
            offset += value.encodedSize()
            metadata = value
        } else {
            metadata = nil
        }

        return Self(
            id: id,
            metadata: metadata
        )
    }
}

extension Metadata {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        let userId = data[offset..<offset+8].withUnsafeBytes {
            $0.load(as: UInt64.self).littleEndian
        }
        offset += 8
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let usernameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(usernameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let usernameData = data[offset..<offset+Int(usernameLen)]
        guard let username = String(data: usernameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(usernameLen)

        return Self(
            userId: userId,
            username: username
        )
    }
}

extension Config {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let nameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(nameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+Int(nameLen)]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(nameLen)
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let databasePresent = data[offset]
        offset += 1
        let database: DatabaseConfig?
        if databasePresent == 1 {
            let value = try DatabaseConfig.decode(from: data[offset...])
            offset += value.encodedSize()
            database = value
        } else {
            database = nil
        }
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let cachePresent = data[offset]
        offset += 1
        let cache: CacheConfig?
        if cachePresent == 1 {
            let value = try CacheConfig.decode(from: data[offset...])
            offset += value.encodedSize()
            cache = value
        } else {
            cache = nil
        }

        return Self(
            name: name,
            database: database,
            cache: cache
        )
    }
}

extension DatabaseConfig {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let hostLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(hostLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let hostData = data[offset..<offset+Int(hostLen)]
        guard let host = String(data: hostData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(hostLen)
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        let port = data[offset..<offset+2].withUnsafeBytes {
            $0.load(as: UInt16.self).littleEndian
        }
        offset += 2

        return Self(
            host: host,
            port: port
        )
    }
}

extension CacheConfig {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let sizeMb = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let ttlSeconds = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4

        return Self(
            sizeMb: sizeMb,
            ttlSeconds: ttlSeconds
        )
    }
}

extension Document {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let id = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let tagsPresent = data[offset]
        offset += 1
        let tags: TagList?
        if tagsPresent == 1 {
            let value = try TagList.decode(from: data[offset...])
            offset += value.encodedSize()
            tags = value
        } else {
            tags = nil
        }

        return Self(
            id: id,
            tags: tags
        )
    }
}

extension TagList {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let itemsLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var items: [String] = []
        items.reserveCapacity(Int(itemsLen))
        for _ in 0..<Int(itemsLen) {
            guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
            let elemLen = data[offset..<offset+4].withUnsafeBytes {
                $0.load(as: UInt32.self).littleEndian
            }
            offset += 4
            guard offset + Int(elemLen) <= data.count else { throw SDPDecodeError.insufficientData }
            let elemData = data[offset..<offset+Int(elemLen)]
            guard let elem = String(data: elemData, encoding: .utf8) else {
                throw SDPDecodeError.invalidUTF8
            }
            offset += Int(elemLen)
            items.append(elem)
        }

        return Self(
            items: items
        )
    }
}

