// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (3x faster decoding).
// All memory accesses are bounds-checked once at function entry.
// Safe for use - the unsafe operations are verified by the code generator.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Request {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let idPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let id = UInt32(littleEndian: idPtr.load(as: UInt32.self))
            offset += 4
            // Decode optional metadata
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let metadataPresent = buffer[offset]
            offset += 1

            let metadata: Metadata?
            if metadataPresent == 1 {
                let value = try Metadata.decode(from: Array(bytes[offset...]))
                offset += value.encodedSize()
                metadata = value
            } else {
                metadata = nil
            }


            return Self(
                id: id,
                metadata: metadata
            )
        }
    }
}

extension Metadata {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 8 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let userIdPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let userId = UInt64(littleEndian: userIdPtr.load(as: UInt64.self))
            offset += 8
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let usernameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let usernameLen = Int(UInt32(littleEndian: usernameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + usernameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let usernameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: usernameLen)
            let username = String(decoding: usernameBuffer, as: UTF8.self)
            offset += usernameLen

            return Self(
                userId: userId,
                username: username
            )
        }
    }
}

extension Config {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let nameLen = Int(UInt32(littleEndian: nameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + nameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: nameLen)
            let name = String(decoding: nameBuffer, as: UTF8.self)
            offset += nameLen
            // Decode optional database
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let databasePresent = buffer[offset]
            offset += 1

            let database: DatabaseConfig?
            if databasePresent == 1 {
                let value = try DatabaseConfig.decode(from: Array(bytes[offset...]))
                offset += value.encodedSize()
                database = value
            } else {
                database = nil
            }

            // Decode optional cache
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let cachePresent = buffer[offset]
            offset += 1

            let cache: CacheConfig?
            if cachePresent == 1 {
                let value = try CacheConfig.decode(from: Array(bytes[offset...]))
                offset += value.encodedSize()
                cache = value
            } else {
                cache = nil
            }


            return Self(
                name: name,
                database: database,
                cache: cache
            )
        }
    }
}

extension DatabaseConfig {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let hostLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let hostLen = Int(UInt32(littleEndian: hostLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + hostLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let hostBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: hostLen)
            let host = String(decoding: hostBuffer, as: UTF8.self)
            offset += hostLen
            guard offset + 2 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let portPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let port = UInt16(littleEndian: portPtr.load(as: UInt16.self))
            offset += 2

            return Self(
                host: host,
                port: port
            )
        }
    }
}

extension CacheConfig {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let sizeMbPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let sizeMb = UInt32(littleEndian: sizeMbPtr.load(as: UInt32.self))
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let ttlSecondsPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let ttlSeconds = UInt32(littleEndian: ttlSecondsPtr.load(as: UInt32.self))
            offset += 4

            return Self(
                sizeMb: sizeMb,
                ttlSeconds: ttlSeconds
            )
        }
    }
}

extension Document {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let idPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let id = UInt32(littleEndian: idPtr.load(as: UInt32.self))
            offset += 4
            // Decode optional tags
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let tagsPresent = buffer[offset]
            offset += 1

            let tags: TagList?
            if tagsPresent == 1 {
                let value = try TagList.decode(from: Array(bytes[offset...]))
                offset += value.encodedSize()
                tags = value
            } else {
                tags = nil
            }


            return Self(
                id: id,
                tags: tags
            )
        }
    }
}

extension TagList {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            // Decode array items
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let itemsLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let itemsLen = Int(UInt32(littleEndian: itemsLenPtr.load(as: UInt32.self)))
            offset += 4

            var items = ContiguousArray<String>()
            items.reserveCapacity(itemsLen)
            for _ in 0..<itemsLen {
                guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
                let elemLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
                let elemLen = Int(UInt32(littleEndian: elemLenPtr.load(as: UInt32.self)))
                offset += 4
                guard offset + elemLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
                let elemBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: elemLen)
                let elem = String(decoding: elemBuffer, as: UTF8.self)
                offset += elemLen
                items.append(elem)
            }

            return Self(
                items: items
            )
        }
    }
}

