// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Request {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var idBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &idBytes, from: offset..<offset+4)
        let id = UInt32(littleEndian: idBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let metadataPresent = data[offset]
        offset += 1
        let metadata: Metadata?
        if metadataPresent == 1 {
            let value = try Metadata.decode(from: data[offset...])
            offset += value.encodedSize()
            metadata = value
        } else {
            metadata = nil
        }

        return Self(
            id: id,
            metadata: metadata
        )
    }
}

extension Metadata {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        var userIdBytes = [UInt8](repeating: 0, count: 8)
        data.copyBytes(to: &userIdBytes, from: offset..<offset+8)
        let userId = UInt64(littleEndian: userIdBytes.withUnsafeBytes { $0.load(as: UInt64.self) })
        offset += 8
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var usernameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &usernameLenBytes, from: offset..<offset+4)
        let usernameLen = Int(UInt32(littleEndian: usernameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + usernameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let usernameData = data[offset..<offset+usernameLen]
        guard let username = String(data: usernameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += usernameLen

        return Self(
            userId: userId,
            username: username
        )
    }
}

extension Config {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var nameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &nameLenBytes, from: offset..<offset+4)
        let nameLen = Int(UInt32(littleEndian: nameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + nameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+nameLen]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let databasePresent = data[offset]
        offset += 1
        let database: DatabaseConfig?
        if databasePresent == 1 {
            let value = try DatabaseConfig.decode(from: data[offset...])
            offset += value.encodedSize()
            database = value
        } else {
            database = nil
        }
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let cachePresent = data[offset]
        offset += 1
        let cache: CacheConfig?
        if cachePresent == 1 {
            let value = try CacheConfig.decode(from: data[offset...])
            offset += value.encodedSize()
            cache = value
        } else {
            cache = nil
        }

        return Self(
            name: name,
            database: database,
            cache: cache
        )
    }
}

extension DatabaseConfig {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var hostLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &hostLenBytes, from: offset..<offset+4)
        let hostLen = Int(UInt32(littleEndian: hostLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + hostLen <= data.count else { throw SDPDecodeError.insufficientData }
        let hostData = data[offset..<offset+hostLen]
        guard let host = String(data: hostData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += hostLen
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        var portBytes = [UInt8](repeating: 0, count: 2)
        data.copyBytes(to: &portBytes, from: offset..<offset+2)
        let port = UInt16(littleEndian: portBytes.withUnsafeBytes { $0.load(as: UInt16.self) })
        offset += 2

        return Self(
            host: host,
            port: port
        )
    }
}

extension CacheConfig {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var sizeMbBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &sizeMbBytes, from: offset..<offset+4)
        let sizeMb = UInt32(littleEndian: sizeMbBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var ttlSecondsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &ttlSecondsBytes, from: offset..<offset+4)
        let ttlSeconds = UInt32(littleEndian: ttlSecondsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4

        return Self(
            sizeMb: sizeMb,
            ttlSeconds: ttlSeconds
        )
    }
}

extension Document {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var idBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &idBytes, from: offset..<offset+4)
        let id = UInt32(littleEndian: idBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let tagsPresent = data[offset]
        offset += 1
        let tags: TagList?
        if tagsPresent == 1 {
            let value = try TagList.decode(from: data[offset...])
            offset += value.encodedSize()
            tags = value
        } else {
            tags = nil
        }

        return Self(
            id: id,
            tags: tags
        )
    }
}

extension TagList {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var itemsLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &itemsLenBytes, from: offset..<offset+4)
        let itemsLen = Int(UInt32(littleEndian: itemsLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var items: [String] = []
        items.reserveCapacity(Int(itemsLen))
        for _ in 0..<Int(itemsLen) {
            guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
            var elemLenBytes = [UInt8](repeating: 0, count: 4)
            data.copyBytes(to: &elemLenBytes, from: offset..<offset+4)
            let elemLen = Int(UInt32(littleEndian: elemLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
            offset += 4
            guard offset + elemLen <= data.count else { throw SDPDecodeError.insufficientData }
            let elemData = data[offset..<offset+elemLen]
            guard let elem = String(data: elemData, encoding: .utf8) else {
                throw SDPDecodeError.invalidUTF8
            }
            offset += elemLen
            items.append(elem)
        }

        return Self(
            items: items
        )
    }
}

