// Code generated by sdp-gen. DO NOT EDIT.

extension Request {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.id.littleEndian) { bytes.append(contentsOf: $0) }
        if let value = self.metadata {
            bytes.append(1) // present
            value.encode(to: &bytes)
        } else {
            bytes.append(0) // absent
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 1 // optional flag
        if let value = self.metadata {
            size += value.encodedSize()
        }
        return size
    }
}

extension Metadata {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.userId.littleEndian) { bytes.append(contentsOf: $0) }
        let usernameBytes = Array(self.username.utf8)
        let usernameLen = UInt32(usernameBytes.count).littleEndian
        withUnsafeBytes(of: usernameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: usernameBytes)
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 8
        size += 4 + self.username.utf8.count
        return size
    }
}

extension Config {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        let nameBytes = Array(self.name.utf8)
        let nameLen = UInt32(nameBytes.count).littleEndian
        withUnsafeBytes(of: nameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: nameBytes)
        if let value = self.database {
            bytes.append(1) // present
            value.encode(to: &bytes)
        } else {
            bytes.append(0) // absent
        }
        if let value = self.cache {
            bytes.append(1) // present
            value.encode(to: &bytes)
        } else {
            bytes.append(0) // absent
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.name.utf8.count
        size += 1 // optional flag
        if let value = self.database {
            size += value.encodedSize()
        }
        size += 1 // optional flag
        if let value = self.cache {
            size += value.encodedSize()
        }
        return size
    }
}

extension DatabaseConfig {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        let hostBytes = Array(self.host.utf8)
        let hostLen = UInt32(hostBytes.count).littleEndian
        withUnsafeBytes(of: hostLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: hostBytes)
        withUnsafeBytes(of: self.port.littleEndian) { bytes.append(contentsOf: $0) }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.host.utf8.count
        size += 2
        return size
    }
}

extension CacheConfig {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.sizeMb.littleEndian) { bytes.append(contentsOf: $0) }
        withUnsafeBytes(of: self.ttlSeconds.littleEndian) { bytes.append(contentsOf: $0) }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4
        return size
    }
}

extension Document {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.id.littleEndian) { bytes.append(contentsOf: $0) }
        if let value = self.tags {
            bytes.append(1) // present
            value.encode(to: &bytes)
        } else {
            bytes.append(0) // absent
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 1 // optional flag
        if let value = self.tags {
            size += value.encodedSize()
        }
        return size
    }
}

extension TagList {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        let itemsLen = UInt32(self.items.count).littleEndian
        withUnsafeBytes(of: itemsLen) { bytes.append(contentsOf: $0) }
        for elem in self.items {
            let elemBytes = Array(elem.utf8)
            let elemLen = UInt32(elemBytes.count).littleEndian
            withUnsafeBytes(of: elemLen) { bytes.append(contentsOf: $0) }
            bytes.append(contentsOf: elemBytes)
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 // array length
        for elem in self.items {
            size += 4 + elem.utf8.count
        }
        return size
    }
}

