// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

extension Request {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        data.append(contentsOf: withUnsafeBytes(of: self.id.littleEndian) { Data($0) })
        if let value = self.metadata {
            data.append(1) // present
            try value.encode(to: &data)
        } else {
            data.append(0) // absent
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 1 // optional flag
        if let value = self.metadata {
            size += value.encodedSize()
        }
        return size
    }
}

extension Metadata {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        data.append(contentsOf: withUnsafeBytes(of: self.userId.littleEndian) { Data($0) })
        let usernameData = self.username.data(using: .utf8)!
        let usernameLen = UInt32(usernameData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: usernameLen) { Data($0) })
        data.append(usernameData)
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 8
        size += 4 + self.username.utf8.count
        return size
    }
}

extension Config {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        let nameData = self.name.data(using: .utf8)!
        let nameLen = UInt32(nameData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: nameLen) { Data($0) })
        data.append(nameData)
        if let value = self.database {
            data.append(1) // present
            try value.encode(to: &data)
        } else {
            data.append(0) // absent
        }
        if let value = self.cache {
            data.append(1) // present
            try value.encode(to: &data)
        } else {
            data.append(0) // absent
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.name.utf8.count
        size += 1 // optional flag
        if let value = self.database {
            size += value.encodedSize()
        }
        size += 1 // optional flag
        if let value = self.cache {
            size += value.encodedSize()
        }
        return size
    }
}

extension DatabaseConfig {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        let hostData = self.host.data(using: .utf8)!
        let hostLen = UInt32(hostData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: hostLen) { Data($0) })
        data.append(hostData)
        data.append(contentsOf: withUnsafeBytes(of: self.port.littleEndian) { Data($0) })
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.host.utf8.count
        size += 2
        return size
    }
}

extension CacheConfig {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        data.append(contentsOf: withUnsafeBytes(of: self.sizeMb.littleEndian) { Data($0) })
        data.append(contentsOf: withUnsafeBytes(of: self.ttlSeconds.littleEndian) { Data($0) })
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4
        return size
    }
}

extension Document {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        data.append(contentsOf: withUnsafeBytes(of: self.id.littleEndian) { Data($0) })
        if let value = self.tags {
            data.append(1) // present
            try value.encode(to: &data)
        } else {
            data.append(0) // absent
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 1 // optional flag
        if let value = self.tags {
            size += value.encodedSize()
        }
        return size
    }
}

extension TagList {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        let itemsLen = UInt32(self.items.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: itemsLen) { Data($0) })
        for elem in self.items {
            let elemData = elem.data(using: .utf8)!
            let elemLen = UInt32(elemData.count).littleEndian
            data.append(contentsOf: withUnsafeBytes(of: elemLen) { Data($0) })
            data.append(elemData)
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 // array length
        for elem in self.items {
            size += 4 + elem.utf8.count
        }
        return size
    }
}

