// Code generated by sdp-gen. DO NOT EDIT.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 8 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let address = bytes[offset..<offset+8].withUnsafeBytes { UInt64(littleEndian: $0.load(as: UInt64.self)) }
        offset += 8
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let displayNameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + displayNameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let displayNameBytes = Array(bytes[offset..<offset+displayNameLen])
        guard let displayName = String(bytes: displayNameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += displayNameLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let identifierLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + identifierLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let identifierBytes = Array(bytes[offset..<offset+identifierLen])
        guard let identifier = String(bytes: identifierBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += identifierLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let unitLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + unitLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let unitBytes = Array(bytes[offset..<offset+unitLen])
        guard let unit = String(bytes: unitBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += unitLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let minValueBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let minValue = Float(bitPattern: minValueBits)
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let maxValueBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let maxValue = Float(bitPattern: maxValueBits)
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let defaultValueBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let defaultValue = Float(bitPattern: defaultValueBits)
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let currentValueBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let currentValue = Float(bitPattern: currentValueBits)
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let rawFlags = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
        let isWritableByte = bytes[offset]
        guard isWritableByte == 0 || isWritableByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let isWritable = isWritableByte == 1
        offset += 1
        guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
        let canRampByte = bytes[offset]
        guard canRampByte == 0 || canRampByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let canRamp = canRampByte == 1
        offset += 1

        return Self(
            address: address,
            displayName: displayName,
            identifier: identifier,
            unit: unit,
            minValue: minValue,
            maxValue: maxValue,
            defaultValue: defaultValue,
            currentValue: currentValue,
            rawFlags: rawFlags,
            isWritable: isWritable,
            canRamp: canRamp
        )
    }
}

extension Plugin {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + nameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameBytes = Array(bytes[offset..<offset+nameLen])
        guard let name = String(bytes: nameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let manufacturerIdLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + manufacturerIdLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let manufacturerIdBytes = Array(bytes[offset..<offset+manufacturerIdLen])
        guard let manufacturerId = String(bytes: manufacturerIdBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += manufacturerIdLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let componentTypeLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + componentTypeLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let componentTypeBytes = Array(bytes[offset..<offset+componentTypeLen])
        guard let componentType = String(bytes: componentTypeBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += componentTypeLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let componentSubtypeLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + componentSubtypeLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let componentSubtypeBytes = Array(bytes[offset..<offset+componentSubtypeLen])
        guard let componentSubtype = String(bytes: componentSubtypeBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += componentSubtypeLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let parametersLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var parameters: [Parameter] = []
        parameters.reserveCapacity(Int(parametersLen))
        for _ in 0..<Int(parametersLen) {
            let elem = try Parameter.decode(from: Array(bytes[offset...]))
            offset += elem.encodedSize()
            parameters.append(elem)
        }

        return Self(
            name: name,
            manufacturerId: manufacturerId,
            componentType: componentType,
            componentSubtype: componentSubtype,
            parameters: parameters
        )
    }
}

extension PluginRegistry {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let pluginsLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var plugins: [Plugin] = []
        plugins.reserveCapacity(Int(pluginsLen))
        for _ in 0..<Int(pluginsLen) {
            let elem = try Plugin.decode(from: Array(bytes[offset...]))
            offset += elem.encodedSize()
            plugins.append(elem)
        }
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let totalPluginCount = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let totalParameterCount = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4

        return Self(
            plugins: plugins,
            totalPluginCount: totalPluginCount,
            totalParameterCount: totalParameterCount
        )
    }
}

