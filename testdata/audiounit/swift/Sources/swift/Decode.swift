// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        var addressBytes = [UInt8](repeating: 0, count: 8)
        data.copyBytes(to: &addressBytes, from: offset..<offset+8)
        let address = UInt64(littleEndian: addressBytes.withUnsafeBytes { $0.load(as: UInt64.self) })
        offset += 8
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var displayNameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &displayNameLenBytes, from: offset..<offset+4)
        let displayNameLen = Int(UInt32(littleEndian: displayNameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + displayNameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let displayNameData = data[offset..<offset+displayNameLen]
        guard let displayName = String(data: displayNameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += displayNameLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var identifierLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &identifierLenBytes, from: offset..<offset+4)
        let identifierLen = Int(UInt32(littleEndian: identifierLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + identifierLen <= data.count else { throw SDPDecodeError.insufficientData }
        let identifierData = data[offset..<offset+identifierLen]
        guard let identifier = String(data: identifierData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += identifierLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var unitLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &unitLenBytes, from: offset..<offset+4)
        let unitLen = Int(UInt32(littleEndian: unitLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + unitLen <= data.count else { throw SDPDecodeError.insufficientData }
        let unitData = data[offset..<offset+unitLen]
        guard let unit = String(data: unitData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += unitLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var minValueBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &minValueBitsBytes, from: offset..<offset+4)
        let minValueBits = UInt32(littleEndian: minValueBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let minValue = Float(bitPattern: minValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var maxValueBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &maxValueBitsBytes, from: offset..<offset+4)
        let maxValueBits = UInt32(littleEndian: maxValueBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let maxValue = Float(bitPattern: maxValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var defaultValueBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &defaultValueBitsBytes, from: offset..<offset+4)
        let defaultValueBits = UInt32(littleEndian: defaultValueBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let defaultValue = Float(bitPattern: defaultValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var currentValueBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &currentValueBitsBytes, from: offset..<offset+4)
        let currentValueBits = UInt32(littleEndian: currentValueBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let currentValue = Float(bitPattern: currentValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var rawFlagsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &rawFlagsBytes, from: offset..<offset+4)
        let rawFlags = UInt32(littleEndian: rawFlagsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let isWritableByte = data[offset]
        guard isWritableByte == 0 || isWritableByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let isWritable = isWritableByte == 1
        offset += 1
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let canRampByte = data[offset]
        guard canRampByte == 0 || canRampByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let canRamp = canRampByte == 1
        offset += 1

        return Self(
            address: address,
            displayName: displayName,
            identifier: identifier,
            unit: unit,
            minValue: minValue,
            maxValue: maxValue,
            defaultValue: defaultValue,
            currentValue: currentValue,
            rawFlags: rawFlags,
            isWritable: isWritable,
            canRamp: canRamp
        )
    }
}

extension Plugin {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var nameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &nameLenBytes, from: offset..<offset+4)
        let nameLen = Int(UInt32(littleEndian: nameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + nameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+nameLen]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var manufacturerIdLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &manufacturerIdLenBytes, from: offset..<offset+4)
        let manufacturerIdLen = Int(UInt32(littleEndian: manufacturerIdLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + manufacturerIdLen <= data.count else { throw SDPDecodeError.insufficientData }
        let manufacturerIdData = data[offset..<offset+manufacturerIdLen]
        guard let manufacturerId = String(data: manufacturerIdData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += manufacturerIdLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var componentTypeLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &componentTypeLenBytes, from: offset..<offset+4)
        let componentTypeLen = Int(UInt32(littleEndian: componentTypeLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + componentTypeLen <= data.count else { throw SDPDecodeError.insufficientData }
        let componentTypeData = data[offset..<offset+componentTypeLen]
        guard let componentType = String(data: componentTypeData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += componentTypeLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var componentSubtypeLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &componentSubtypeLenBytes, from: offset..<offset+4)
        let componentSubtypeLen = Int(UInt32(littleEndian: componentSubtypeLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + componentSubtypeLen <= data.count else { throw SDPDecodeError.insufficientData }
        let componentSubtypeData = data[offset..<offset+componentSubtypeLen]
        guard let componentSubtype = String(data: componentSubtypeData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += componentSubtypeLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var parametersLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &parametersLenBytes, from: offset..<offset+4)
        let parametersLen = Int(UInt32(littleEndian: parametersLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var parameters: [Parameter] = []
        parameters.reserveCapacity(Int(parametersLen))
        for _ in 0..<Int(parametersLen) {
            let elem = try Parameter.decode(from: data[offset...])
            offset += elem.encodedSize()
            parameters.append(elem)
        }

        return Self(
            name: name,
            manufacturerId: manufacturerId,
            componentType: componentType,
            componentSubtype: componentSubtype,
            parameters: parameters
        )
    }
}

extension PluginRegistry {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var pluginsLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &pluginsLenBytes, from: offset..<offset+4)
        let pluginsLen = Int(UInt32(littleEndian: pluginsLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var plugins: [Plugin] = []
        plugins.reserveCapacity(Int(pluginsLen))
        for _ in 0..<Int(pluginsLen) {
            let elem = try Plugin.decode(from: data[offset...])
            offset += elem.encodedSize()
            plugins.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var totalPluginCountBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &totalPluginCountBytes, from: offset..<offset+4)
        let totalPluginCount = UInt32(littleEndian: totalPluginCountBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var totalParameterCountBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &totalParameterCountBytes, from: offset..<offset+4)
        let totalParameterCount = UInt32(littleEndian: totalParameterCountBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4

        return Self(
            plugins: plugins,
            totalPluginCount: totalPluginCount,
            totalParameterCount: totalParameterCount
        )
    }
}

