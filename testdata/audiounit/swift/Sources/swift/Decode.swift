// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 8 <= data.count else { throw SDPDecodeError.insufficientData }
        let address = data[offset..<offset+8].withUnsafeBytes {
            $0.load(as: UInt64.self).littleEndian
        }
        offset += 8
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let displayNameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(displayNameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let displayNameData = data[offset..<offset+Int(displayNameLen)]
        guard let displayName = String(data: displayNameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(displayNameLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let identifierLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(identifierLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let identifierData = data[offset..<offset+Int(identifierLen)]
        guard let identifier = String(data: identifierData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(identifierLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let unitLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(unitLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let unitData = data[offset..<offset+Int(unitLen)]
        guard let unit = String(data: unitData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(unitLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let minValueBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let minValue = Float(bitPattern: minValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let maxValueBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let maxValue = Float(bitPattern: maxValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let defaultValueBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let defaultValue = Float(bitPattern: defaultValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let currentValueBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let currentValue = Float(bitPattern: currentValueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let rawFlags = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let isWritableByte = data[offset]
        guard isWritableByte == 0 || isWritableByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let isWritable = isWritableByte == 1
        offset += 1
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let canRampByte = data[offset]
        guard canRampByte == 0 || canRampByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let canRamp = canRampByte == 1
        offset += 1

        return Self(
            address: address,
            displayName: displayName,
            identifier: identifier,
            unit: unit,
            minValue: minValue,
            maxValue: maxValue,
            defaultValue: defaultValue,
            currentValue: currentValue,
            rawFlags: rawFlags,
            isWritable: isWritable,
            canRamp: canRamp
        )
    }
}

extension Plugin {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let nameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(nameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+Int(nameLen)]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(nameLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let manufacturerIdLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(manufacturerIdLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let manufacturerIdData = data[offset..<offset+Int(manufacturerIdLen)]
        guard let manufacturerId = String(data: manufacturerIdData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(manufacturerIdLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let componentTypeLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(componentTypeLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let componentTypeData = data[offset..<offset+Int(componentTypeLen)]
        guard let componentType = String(data: componentTypeData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(componentTypeLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let componentSubtypeLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(componentSubtypeLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let componentSubtypeData = data[offset..<offset+Int(componentSubtypeLen)]
        guard let componentSubtype = String(data: componentSubtypeData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(componentSubtypeLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let parametersLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var parameters: [Parameter] = []
        parameters.reserveCapacity(Int(parametersLen))
        for _ in 0..<Int(parametersLen) {
            let elem = try Parameter.decode(from: data[offset...])
            offset += elem.encodedSize()
            parameters.append(elem)
        }

        return Self(
            name: name,
            manufacturerId: manufacturerId,
            componentType: componentType,
            componentSubtype: componentSubtype,
            parameters: parameters
        )
    }
}

extension PluginRegistry {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let pluginsLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var plugins: [Plugin] = []
        plugins.reserveCapacity(Int(pluginsLen))
        for _ in 0..<Int(pluginsLen) {
            let elem = try Plugin.decode(from: data[offset...])
            offset += elem.encodedSize()
            plugins.append(elem)
        }
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let totalPluginCount = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let totalParameterCount = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4

        return Self(
            plugins: plugins,
            totalPluginCount: totalPluginCount,
            totalParameterCount: totalParameterCount
        )
    }
}

