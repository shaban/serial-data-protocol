// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (3x faster decoding).
// All memory accesses are bounds-checked once at function entry.
// Safe for use - the unsafe operations are verified by the code generator.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 8 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let addressPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let address = UInt64(littleEndian: addressPtr.load(as: UInt64.self))
            offset += 8
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let displayNameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let displayNameLen = Int(UInt32(littleEndian: displayNameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + displayNameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let displayNameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: displayNameLen)
            let displayName = String(decoding: displayNameBuffer, as: UTF8.self)
            offset += displayNameLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let identifierLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let identifierLen = Int(UInt32(littleEndian: identifierLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + identifierLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let identifierBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: identifierLen)
            let identifier = String(decoding: identifierBuffer, as: UTF8.self)
            offset += identifierLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let unitLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let unitLen = Int(UInt32(littleEndian: unitLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + unitLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let unitBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: unitLen)
            let unit = String(decoding: unitBuffer, as: UTF8.self)
            offset += unitLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let minValuePtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let minValueBits = UInt32(littleEndian: minValuePtr.load(as: UInt32.self))
            let minValue = Float(bitPattern: minValueBits)
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let maxValuePtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let maxValueBits = UInt32(littleEndian: maxValuePtr.load(as: UInt32.self))
            let maxValue = Float(bitPattern: maxValueBits)
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let defaultValuePtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let defaultValueBits = UInt32(littleEndian: defaultValuePtr.load(as: UInt32.self))
            let defaultValue = Float(bitPattern: defaultValueBits)
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let currentValuePtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let currentValueBits = UInt32(littleEndian: currentValuePtr.load(as: UInt32.self))
            let currentValue = Float(bitPattern: currentValueBits)
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let rawFlagsPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let rawFlags = UInt32(littleEndian: rawFlagsPtr.load(as: UInt32.self))
            offset += 4
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let isWritableByte = buffer[offset]
            guard isWritableByte == 0 || isWritableByte == 1 else { throw SDPDecodeError.invalidBoolValue }
            let isWritable = isWritableByte == 1
            offset += 1
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let canRampByte = buffer[offset]
            guard canRampByte == 0 || canRampByte == 1 else { throw SDPDecodeError.invalidBoolValue }
            let canRamp = canRampByte == 1
            offset += 1

            return Self(
                address: address,
                displayName: displayName,
                identifier: identifier,
                unit: unit,
                minValue: minValue,
                maxValue: maxValue,
                defaultValue: defaultValue,
                currentValue: currentValue,
                rawFlags: rawFlags,
                isWritable: isWritable,
                canRamp: canRamp
            )
        }
    }
}

extension Plugin {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let nameLen = Int(UInt32(littleEndian: nameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + nameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: nameLen)
            let name = String(decoding: nameBuffer, as: UTF8.self)
            offset += nameLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let manufacturerIdLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let manufacturerIdLen = Int(UInt32(littleEndian: manufacturerIdLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + manufacturerIdLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let manufacturerIdBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: manufacturerIdLen)
            let manufacturerId = String(decoding: manufacturerIdBuffer, as: UTF8.self)
            offset += manufacturerIdLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let componentTypeLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let componentTypeLen = Int(UInt32(littleEndian: componentTypeLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + componentTypeLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let componentTypeBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: componentTypeLen)
            let componentType = String(decoding: componentTypeBuffer, as: UTF8.self)
            offset += componentTypeLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let componentSubtypeLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let componentSubtypeLen = Int(UInt32(littleEndian: componentSubtypeLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + componentSubtypeLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let componentSubtypeBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: componentSubtypeLen)
            let componentSubtype = String(decoding: componentSubtypeBuffer, as: UTF8.self)
            offset += componentSubtypeLen
            // Decode array parameters
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let parametersLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let parametersLen = Int(UInt32(littleEndian: parametersLenPtr.load(as: UInt32.self)))
            offset += 4

            var parameters = ContiguousArray<Parameter>()
            parameters.reserveCapacity(parametersLen)
            for _ in 0..<parametersLen {
                let elem = try Parameter.decode(from: Array(bytes[offset...]))
                offset += elem.encodedSize()
                parameters.append(elem)
            }

            return Self(
                name: name,
                manufacturerId: manufacturerId,
                componentType: componentType,
                componentSubtype: componentSubtype,
                parameters: parameters
            )
        }
    }
}

extension PluginRegistry {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            // Decode array plugins
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let pluginsLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let pluginsLen = Int(UInt32(littleEndian: pluginsLenPtr.load(as: UInt32.self)))
            offset += 4

            var plugins = ContiguousArray<Plugin>()
            plugins.reserveCapacity(pluginsLen)
            for _ in 0..<pluginsLen {
                let elem = try Plugin.decode(from: Array(bytes[offset...]))
                offset += elem.encodedSize()
                plugins.append(elem)
            }
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let totalPluginCountPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let totalPluginCount = UInt32(littleEndian: totalPluginCountPtr.load(as: UInt32.self))
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let totalParameterCountPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let totalParameterCount = UInt32(littleEndian: totalParameterCountPtr.load(as: UInt32.self))
            offset += 4

            return Self(
                plugins: plugins,
                totalPluginCount: totalPluginCount,
                totalParameterCount: totalParameterCount
            )
        }
    }
}

