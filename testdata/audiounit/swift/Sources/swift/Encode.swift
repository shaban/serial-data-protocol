// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

extension Parameter {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        data.append(contentsOf: withUnsafeBytes(of: self.address.littleEndian) { Data($0) })
        let displayNameData = self.displayName.data(using: .utf8)!
        let displayNameLen = UInt32(displayNameData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: displayNameLen) { Data($0) })
        data.append(displayNameData)
        let identifierData = self.identifier.data(using: .utf8)!
        let identifierLen = UInt32(identifierData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: identifierLen) { Data($0) })
        data.append(identifierData)
        let unitData = self.unit.data(using: .utf8)!
        let unitLen = UInt32(unitData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: unitLen) { Data($0) })
        data.append(unitData)
        let minValueBits = self.minValue.bitPattern.littleEndian
        data.append(contentsOf: withUnsafeBytes(of: minValueBits) { Data($0) })
        let maxValueBits = self.maxValue.bitPattern.littleEndian
        data.append(contentsOf: withUnsafeBytes(of: maxValueBits) { Data($0) })
        let defaultValueBits = self.defaultValue.bitPattern.littleEndian
        data.append(contentsOf: withUnsafeBytes(of: defaultValueBits) { Data($0) })
        let currentValueBits = self.currentValue.bitPattern.littleEndian
        data.append(contentsOf: withUnsafeBytes(of: currentValueBits) { Data($0) })
        data.append(contentsOf: withUnsafeBytes(of: self.rawFlags.littleEndian) { Data($0) })
        data.append(self.isWritable ? 1 : 0)
        data.append(self.canRamp ? 1 : 0)
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 8
        size += 4 + self.displayName.utf8.count
        size += 4 + self.identifier.utf8.count
        size += 4 + self.unit.utf8.count
        size += 4
        size += 4
        size += 4
        size += 4
        size += 4
        size += 1
        size += 1
        return size
    }
}

extension Plugin {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        let nameData = self.name.data(using: .utf8)!
        let nameLen = UInt32(nameData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: nameLen) { Data($0) })
        data.append(nameData)
        let manufacturerIdData = self.manufacturerId.data(using: .utf8)!
        let manufacturerIdLen = UInt32(manufacturerIdData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: manufacturerIdLen) { Data($0) })
        data.append(manufacturerIdData)
        let componentTypeData = self.componentType.data(using: .utf8)!
        let componentTypeLen = UInt32(componentTypeData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: componentTypeLen) { Data($0) })
        data.append(componentTypeData)
        let componentSubtypeData = self.componentSubtype.data(using: .utf8)!
        let componentSubtypeLen = UInt32(componentSubtypeData.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: componentSubtypeLen) { Data($0) })
        data.append(componentSubtypeData)
        let parametersLen = UInt32(self.parameters.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: parametersLen) { Data($0) })
        for elem in self.parameters {
            try elem.encode(to: &data)
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.name.utf8.count
        size += 4 + self.manufacturerId.utf8.count
        size += 4 + self.componentType.utf8.count
        size += 4 + self.componentSubtype.utf8.count
        size += 4 // array length
        for elem in self.parameters {
            size += elem.encodedSize()
        }
        return size
    }
}

extension PluginRegistry {
    /// Encode to Data (IPC mode)
    public func encodeToData() throws -> Data {
        var data = Data(capacity: encodedSize())
        try encode(to: &data)
        return data
    }

    /// Encode to a Data buffer
    public func encode(to data: inout Data) throws {
        let pluginsLen = UInt32(self.plugins.count).littleEndian
        data.append(contentsOf: withUnsafeBytes(of: pluginsLen) { Data($0) })
        for elem in self.plugins {
            try elem.encode(to: &data)
        }
        data.append(contentsOf: withUnsafeBytes(of: self.totalPluginCount.littleEndian) { Data($0) })
        data.append(contentsOf: withUnsafeBytes(of: self.totalParameterCount.littleEndian) { Data($0) })
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 // array length
        for elem in self.plugins {
            size += elem.encodedSize()
        }
        size += 4
        size += 4
        return size
    }
}

