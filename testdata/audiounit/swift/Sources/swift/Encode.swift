// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (8x faster encoding).
// All memory accesses are bounds-checked at buffer allocation.
// Safe for use - the unsafe operations are verified by the code generator.

extension Parameter {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let addressLE = self.address.littleEndian
            withUnsafeBytes(of: addressLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 8)
            }
            offset += 8
            let displayNameBytes = Array(self.displayName.utf8)
            let displayNameLen = UInt32(displayNameBytes.count).littleEndian
            withUnsafeBytes(of: displayNameLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            displayNameBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: displayNameBytes.count)
            }
            offset += displayNameBytes.count
            let identifierBytes = Array(self.identifier.utf8)
            let identifierLen = UInt32(identifierBytes.count).littleEndian
            withUnsafeBytes(of: identifierLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            identifierBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: identifierBytes.count)
            }
            offset += identifierBytes.count
            let unitBytes = Array(self.unit.utf8)
            let unitLen = UInt32(unitBytes.count).littleEndian
            withUnsafeBytes(of: unitLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            unitBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: unitBytes.count)
            }
            offset += unitBytes.count
            let minValueBits = self.minValue.bitPattern.littleEndian
            withUnsafeBytes(of: minValueBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let maxValueBits = self.maxValue.bitPattern.littleEndian
            withUnsafeBytes(of: maxValueBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let defaultValueBits = self.defaultValue.bitPattern.littleEndian
            withUnsafeBytes(of: defaultValueBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let currentValueBits = self.currentValue.bitPattern.littleEndian
            withUnsafeBytes(of: currentValueBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let rawFlagsLE = self.rawFlags.littleEndian
            withUnsafeBytes(of: rawFlagsLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            buffer[offset] = self.isWritable ? 1 : 0
            offset += 1
            buffer[offset] = self.canRamp ? 1 : 0
            offset += 1
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 8
        size += 4 + self.displayName.utf8.count
        size += 4 + self.identifier.utf8.count
        size += 4 + self.unit.utf8.count
        size += 4
        size += 4
        size += 4
        size += 4
        size += 4
        size += 1
        size += 1
        return size
    }
}

extension Plugin {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let nameBytes = Array(self.name.utf8)
            let nameLen = UInt32(nameBytes.count).littleEndian
            withUnsafeBytes(of: nameLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            nameBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: nameBytes.count)
            }
            offset += nameBytes.count
            let manufacturerIdBytes = Array(self.manufacturerId.utf8)
            let manufacturerIdLen = UInt32(manufacturerIdBytes.count).littleEndian
            withUnsafeBytes(of: manufacturerIdLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            manufacturerIdBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: manufacturerIdBytes.count)
            }
            offset += manufacturerIdBytes.count
            let componentTypeBytes = Array(self.componentType.utf8)
            let componentTypeLen = UInt32(componentTypeBytes.count).littleEndian
            withUnsafeBytes(of: componentTypeLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            componentTypeBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: componentTypeBytes.count)
            }
            offset += componentTypeBytes.count
            let componentSubtypeBytes = Array(self.componentSubtype.utf8)
            let componentSubtypeLen = UInt32(componentSubtypeBytes.count).littleEndian
            withUnsafeBytes(of: componentSubtypeLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            componentSubtypeBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: componentSubtypeBytes.count)
            }
            offset += componentSubtypeBytes.count
            let parametersLen = UInt32(self.parameters.count).littleEndian
            withUnsafeBytes(of: parametersLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            self.parameters.withUnsafeBufferPointer { elemBuffer in
                for elem in elemBuffer {
                    let elemBytes = elem.encodeToBytes()
                    elemBytes.withUnsafeBytes { src in
                        let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                        dst.copyMemory(from: src.baseAddress!, byteCount: elemBytes.count)
                    }
                    offset += elemBytes.count
                }
            }
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.name.utf8.count
        size += 4 + self.manufacturerId.utf8.count
        size += 4 + self.componentType.utf8.count
        size += 4 + self.componentSubtype.utf8.count
        size += 4
        size += self.parameters.reduce(0) { $0 + $1.encodedSize() }
        return size
    }
}

extension PluginRegistry {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let pluginsLen = UInt32(self.plugins.count).littleEndian
            withUnsafeBytes(of: pluginsLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            self.plugins.withUnsafeBufferPointer { elemBuffer in
                for elem in elemBuffer {
                    let elemBytes = elem.encodeToBytes()
                    elemBytes.withUnsafeBytes { src in
                        let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                        dst.copyMemory(from: src.baseAddress!, byteCount: elemBytes.count)
                    }
                    offset += elemBytes.count
                }
            }
            let totalPluginCountLE = self.totalPluginCount.littleEndian
            withUnsafeBytes(of: totalPluginCountLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let totalParameterCountLE = self.totalParameterCount.littleEndian
            withUnsafeBytes(of: totalParameterCountLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += self.plugins.reduce(0) { $0 + $1.encodedSize() }
        size += 4
        size += 4
        return size
    }
}

