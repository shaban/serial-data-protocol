// Code generated by sdp-gen. DO NOT EDIT.

extension Parameter {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.address.littleEndian) { bytes.append(contentsOf: $0) }
        let displayNameBytes = Array(self.displayName.utf8)
        let displayNameLen = UInt32(displayNameBytes.count).littleEndian
        withUnsafeBytes(of: displayNameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: displayNameBytes)
        let identifierBytes = Array(self.identifier.utf8)
        let identifierLen = UInt32(identifierBytes.count).littleEndian
        withUnsafeBytes(of: identifierLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: identifierBytes)
        let unitBytes = Array(self.unit.utf8)
        let unitLen = UInt32(unitBytes.count).littleEndian
        withUnsafeBytes(of: unitLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: unitBytes)
        let minValueBits = self.minValue.bitPattern.littleEndian
        withUnsafeBytes(of: minValueBits) { bytes.append(contentsOf: $0) }
        let maxValueBits = self.maxValue.bitPattern.littleEndian
        withUnsafeBytes(of: maxValueBits) { bytes.append(contentsOf: $0) }
        let defaultValueBits = self.defaultValue.bitPattern.littleEndian
        withUnsafeBytes(of: defaultValueBits) { bytes.append(contentsOf: $0) }
        let currentValueBits = self.currentValue.bitPattern.littleEndian
        withUnsafeBytes(of: currentValueBits) { bytes.append(contentsOf: $0) }
        withUnsafeBytes(of: self.rawFlags.littleEndian) { bytes.append(contentsOf: $0) }
        bytes.append(self.isWritable ? 1 : 0)
        bytes.append(self.canRamp ? 1 : 0)
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 8
        size += 4 + self.displayName.utf8.count
        size += 4 + self.identifier.utf8.count
        size += 4 + self.unit.utf8.count
        size += 4
        size += 4
        size += 4
        size += 4
        size += 4
        size += 1
        size += 1
        return size
    }
}

extension Plugin {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        let nameBytes = Array(self.name.utf8)
        let nameLen = UInt32(nameBytes.count).littleEndian
        withUnsafeBytes(of: nameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: nameBytes)
        let manufacturerIdBytes = Array(self.manufacturerId.utf8)
        let manufacturerIdLen = UInt32(manufacturerIdBytes.count).littleEndian
        withUnsafeBytes(of: manufacturerIdLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: manufacturerIdBytes)
        let componentTypeBytes = Array(self.componentType.utf8)
        let componentTypeLen = UInt32(componentTypeBytes.count).littleEndian
        withUnsafeBytes(of: componentTypeLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: componentTypeBytes)
        let componentSubtypeBytes = Array(self.componentSubtype.utf8)
        let componentSubtypeLen = UInt32(componentSubtypeBytes.count).littleEndian
        withUnsafeBytes(of: componentSubtypeLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: componentSubtypeBytes)
        let parametersLen = UInt32(self.parameters.count).littleEndian
        withUnsafeBytes(of: parametersLen) { bytes.append(contentsOf: $0) }
        for elem in self.parameters {
            elem.encode(to: &bytes)
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 + self.name.utf8.count
        size += 4 + self.manufacturerId.utf8.count
        size += 4 + self.componentType.utf8.count
        size += 4 + self.componentSubtype.utf8.count
        size += 4 // array length
        for elem in self.parameters {
            size += elem.encodedSize()
        }
        return size
    }
}

extension PluginRegistry {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        let pluginsLen = UInt32(self.plugins.count).littleEndian
        withUnsafeBytes(of: pluginsLen) { bytes.append(contentsOf: $0) }
        for elem in self.plugins {
            elem.encode(to: &bytes)
        }
        withUnsafeBytes(of: self.totalPluginCount.littleEndian) { bytes.append(contentsOf: $0) }
        withUnsafeBytes(of: self.totalParameterCount.littleEndian) { bytes.append(contentsOf: $0) }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4 // array length
        for elem in self.plugins {
            size += elem.encodedSize()
        }
        size += 4
        size += 4
        return size
    }
}

