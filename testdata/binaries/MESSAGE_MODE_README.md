# Message Mode Testing with .sdpb Reference Files

This directory contains binary reference files (`.sdpb`) used for cross-language message mode testing.

## Reference Files

- `message_point.sdpb` - Point message (26 bytes)
  - Point{x: 3.14, y: 2.71}
  - Generated by: `testdata/tools/encode_messagemode_reference.go`

- `message_rectangle.sdpb` - Rectangle message (42 bytes)
  - Rectangle{top_left: Point{x: 10.0, y: 20.0}, width: 100.0, height: 50.0}
  - Generated by: `testdata/tools/encode_messagemode_reference.go`

- `message_point_cpp.sdpb` - Point message from C++ (26 bytes)
  - Same values as above
  - Generated by: `testdata/cpp/messagemode/encode_reference.cpp`

- `message_rectangle_cpp.sdpb` - Rectangle message from C++ (42 bytes)
  - Same values as above
  - Generated by: `testdata/cpp/messagemode/encode_reference.cpp`

## Wire Format

All message mode files use the same wire format:

```
[SDP:3][version:1][type_id:2][length:4][payload:N]
```

**Header breakdown (10 bytes):**
- Magic: `534450` (hex) = "SDP" (3 bytes)
- Version: `32` (hex) = '2' (ASCII, 1 byte)
- Type ID: little-endian uint16 (2 bytes)
  - Point = 1 (`0100`)
  - Rectangle = 2 (`0200`)
- Length: little-endian uint32 payload size (4 bytes)

**Example - Point message:**
```
53 44 50 32  01 00  10 00 00 00  [16 bytes payload]
|SDP|   |'2| |ID 1| |len=16|      [x: f64, y: f64]
```

## Regenerating Reference Files

When the wire format changes or new message types are added:

### Go Reference Files
```bash
cd testdata/tools
go run encode_messagemode_reference.go
```

### C++ Reference Files
```bash
cd testdata/cpp/messagemode
g++ -std=c++17 -o encode_reference encode_reference.cpp encode.cpp message_encode.cpp
./encode_reference
```

## Using in Tests

**C++ tests:**
```cpp
#include <fstream>
#include <vector>

std::vector<uint8_t> data = read_file("../../binaries/message_point.sdpb");
sdp::Point point = sdp::DecodePointMessage(data);
```

**Go tests:** (future)
```go
data, _ := os.ReadFile("../binaries/message_point.sdpb")
point, _ := messagemode.DecodePointMessage(data)
```

**Rust tests:** (future)
```rust
let data = std::fs::read("../binaries/message_point.sdpb")?;
let point = decode_point_message(&data)?;
```

## Cross-Language Compatibility

These `.sdpb` files serve as the ground truth for cross-language testing:

1. **Generate** reference files from Go/C++ encoders
2. **Verify** all languages can decode the same `.sdpb` files
3. **Compare** encoded output from each language matches byte-for-byte

This ensures:
- ✅ Wire format is language-agnostic
- ✅ Go ↔ C++ ↔ Rust interoperability
- ✅ Consistent behavior across implementations
- ✅ Version-controlled test data (no hardcoded hex strings)

## Benefits vs Hardcoded Hex

**Old approach (hardcoded hex in test files):**
- ❌ Duplicated across test files
- ❌ Hard to maintain when format changes
- ❌ Limited test coverage (only simple cases)
- ❌ Not reusable across languages

**New approach (.sdpb files):**
- ✅ Single source of truth in `testdata/binaries/`
- ✅ Easy to update (regenerate with tools)
- ✅ Can test complex schemas (arrays, nested, optional)
- ✅ Reusable across Go/C++/Rust tests
- ✅ Version controlled for regression testing
- ✅ Matches project's byte mode testing pattern
