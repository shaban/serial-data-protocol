/* decode.cpp - Decoding implementations for optional
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "decode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

/* Array size limits */
constexpr uint32_t MAX_ARRAY_ELEMENTS = 1000000;
constexpr uint32_t MAX_TOTAL_ELEMENTS = 10000000;

/* Forward declarations for internal decode helpers */
static Request request_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static Metadata metadata_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static Config config_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static DatabaseConfig database_config_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static CacheConfig cache_config_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static Document document_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static TagList tag_list_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);

static Metadata metadata_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Metadata result;

    /* user_id */
    if (offset + 8 > buf_len) throw DecodeError("Buffer too small");
    result.user_id = SDP_LE64TOH(*(const uint64_t*)(buf + offset));
    offset += 8;

    /* username */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t username_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + username_len > buf_len) throw DecodeError("Buffer too small");
    result.username = std::string(reinterpret_cast<const char*>(buf + offset), username_len);
    offset += username_len;

    return result;
}

Metadata metadata_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return metadata_decode_impl(buf, buf_len, offset);
}

static DatabaseConfig database_config_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    DatabaseConfig result;

    /* host */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t host_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + host_len > buf_len) throw DecodeError("Buffer too small");
    result.host = std::string(reinterpret_cast<const char*>(buf + offset), host_len);
    offset += host_len;

    /* port */
    if (offset + 2 > buf_len) throw DecodeError("Buffer too small");
    result.port = SDP_LE16TOH(*(const uint16_t*)(buf + offset));
    offset += 2;

    return result;
}

DatabaseConfig database_config_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return database_config_decode_impl(buf, buf_len, offset);
}

static CacheConfig cache_config_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    CacheConfig result;

    /* size_mb */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.size_mb = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* ttl_seconds */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.ttl_seconds = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    return result;
}

CacheConfig cache_config_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return cache_config_decode_impl(buf, buf_len, offset);
}

static TagList tag_list_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    TagList result;
    uint32_t total_elements = 0;

    /* items */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t items_count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (items_count > MAX_ARRAY_ELEMENTS) throw DecodeError("Array too large");
    total_elements += items_count;
    if (total_elements > MAX_TOTAL_ELEMENTS) throw DecodeError("Total elements too large");
    result.items.reserve(items_count);
    for (uint32_t i = 0; i < items_count; i++) {
        if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
        uint32_t len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
        offset += 4;
        if (offset + len > buf_len) throw DecodeError("Buffer too small");
        result.items.emplace_back(reinterpret_cast<const char*>(buf + offset), len);
        offset += len;
    }

    return result;
}

TagList tag_list_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return tag_list_decode_impl(buf, buf_len, offset);
}

static Request request_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Request result;

    /* id */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.id = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* metadata */
    if (offset >= buf_len) throw DecodeError("Buffer too small");
    uint8_t metadata_present = buf[offset++];
    if (metadata_present) {
        result.metadata = metadata_decode_impl(buf, buf_len, offset);
    }

    return result;
}

Request request_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return request_decode_impl(buf, buf_len, offset);
}

static Config config_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Config result;

    /* name */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t name_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + name_len > buf_len) throw DecodeError("Buffer too small");
    result.name = std::string(reinterpret_cast<const char*>(buf + offset), name_len);
    offset += name_len;

    /* database */
    if (offset >= buf_len) throw DecodeError("Buffer too small");
    uint8_t database_present = buf[offset++];
    if (database_present) {
        result.database = database_config_decode_impl(buf, buf_len, offset);
    }

    /* cache */
    if (offset >= buf_len) throw DecodeError("Buffer too small");
    uint8_t cache_present = buf[offset++];
    if (cache_present) {
        result.cache = cache_config_decode_impl(buf, buf_len, offset);
    }

    return result;
}

Config config_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return config_decode_impl(buf, buf_len, offset);
}

static Document document_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Document result;

    /* id */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.id = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* tags */
    if (offset >= buf_len) throw DecodeError("Buffer too small");
    uint8_t tags_present = buf[offset++];
    if (tags_present) {
        result.tags = tag_list_decode_impl(buf, buf_len, offset);
    }

    return result;
}

Document document_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return document_decode_impl(buf, buf_len, offset);
}

}  // namespace sdp
