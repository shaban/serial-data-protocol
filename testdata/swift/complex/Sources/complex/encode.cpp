/* encode.cpp - Encoding implementations for complex
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "encode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

size_t parameter_size(const Parameter& msg) {
    size_t size = 0;
    size += 4;  // id
    size += 4 + msg.name.size();  // name
    size += 4;  // value
    size += 4;  // min
    size += 4;  // max
    return size;
}

size_t parameter_encode(const Parameter& msg, uint8_t* buf) {
    size_t offset = 0;

    /* id */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.id);
        offset += 4;

    /* name */
    uint32_t name_len = msg.name.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
    offset += 4;
    std::memcpy(buf + offset, msg.name.data(), name_len);
    offset += name_len;

    /* value */
        *(uint32_t*)(buf + offset) = sdp_f32_to_le(msg.value);
        offset += 4;

    /* min */
        *(uint32_t*)(buf + offset) = sdp_f32_to_le(msg.min);
        offset += 4;

    /* max */
        *(uint32_t*)(buf + offset) = sdp_f32_to_le(msg.max);
        offset += 4;

    return offset;
}

size_t plugin_size(const Plugin& msg) {
    size_t size = 0;
    size += 4;  // id
    size += 4 + msg.name.size();  // name
    size += 4 + msg.manufacturer.size();  // manufacturer
    size += 4;  // version
    size += 1;  // enabled
    size += 4;  // parameters count
    for (const auto& elem : msg.parameters) {
        size += parameter_size(elem);
    }
    return size;
}

size_t plugin_encode(const Plugin& msg, uint8_t* buf) {
    size_t offset = 0;

    /* id */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.id);
        offset += 4;

    /* name */
    uint32_t name_len = msg.name.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
    offset += 4;
    std::memcpy(buf + offset, msg.name.data(), name_len);
    offset += name_len;

    /* manufacturer */
    uint32_t manufacturer_len = msg.manufacturer.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(manufacturer_len);
    offset += 4;
    std::memcpy(buf + offset, msg.manufacturer.data(), manufacturer_len);
    offset += manufacturer_len;

    /* version */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.version);
        offset += 4;

    /* enabled */
        buf[offset++] = msg.enabled;

    /* parameters */
    uint32_t parameters_count = msg.parameters.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(parameters_count);
    offset += 4;
    for (const auto& elem : msg.parameters) {
            *(uint32_t*)(buf + offset) = SDP_HTOLE32(elem.id);
            offset += 4;
        uint32_t name_len = elem.name.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
        offset += 4;
        std::memcpy(buf + offset, elem.name.data(), name_len);
        offset += name_len;
            *(uint32_t*)(buf + offset) = sdp_f32_to_le(elem.value);
            offset += 4;
            *(uint32_t*)(buf + offset) = sdp_f32_to_le(elem.min);
            offset += 4;
            *(uint32_t*)(buf + offset) = sdp_f32_to_le(elem.max);
            offset += 4;
    }

    return offset;
}

size_t audio_device_size(const AudioDevice& msg) {
    size_t size = 0;
    size += 4;  // device_id
    size += 4 + msg.device_name.size();  // device_name
    size += 4;  // sample_rate
    size += 4;  // buffer_size
    size += 2;  // input_channels
    size += 2;  // output_channels
    size += 1;  // is_default
    size += 4;  // active_plugins count
    for (const auto& elem : msg.active_plugins) {
        size += plugin_size(elem);
    }
    return size;
}

size_t audio_device_encode(const AudioDevice& msg, uint8_t* buf) {
    size_t offset = 0;

    /* device_id */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.device_id);
        offset += 4;

    /* device_name */
    uint32_t device_name_len = msg.device_name.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(device_name_len);
    offset += 4;
    std::memcpy(buf + offset, msg.device_name.data(), device_name_len);
    offset += device_name_len;

    /* sample_rate */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.sample_rate);
        offset += 4;

    /* buffer_size */
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(msg.buffer_size);
        offset += 4;

    /* input_channels */
        *(uint16_t*)(buf + offset) = SDP_HTOLE16(msg.input_channels);
        offset += 2;

    /* output_channels */
        *(uint16_t*)(buf + offset) = SDP_HTOLE16(msg.output_channels);
        offset += 2;

    /* is_default */
        buf[offset++] = msg.is_default;

    /* active_plugins */
    uint32_t active_plugins_count = msg.active_plugins.size();
    *(uint32_t*)(buf + offset) = SDP_HTOLE32(active_plugins_count);
    offset += 4;
    for (const auto& elem : msg.active_plugins) {
            *(uint32_t*)(buf + offset) = SDP_HTOLE32(elem.id);
            offset += 4;
        uint32_t name_len = elem.name.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(name_len);
        offset += 4;
        std::memcpy(buf + offset, elem.name.data(), name_len);
        offset += name_len;
        uint32_t manufacturer_len = elem.manufacturer.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(manufacturer_len);
        offset += 4;
        std::memcpy(buf + offset, elem.manufacturer.data(), manufacturer_len);
        offset += manufacturer_len;
            *(uint32_t*)(buf + offset) = SDP_HTOLE32(elem.version);
            offset += 4;
            buf[offset++] = elem.enabled;
        uint32_t parameters_count = elem.parameters.size();
        *(uint32_t*)(buf + offset) = SDP_HTOLE32(parameters_count);
        offset += 4;
        for (const auto& nested_elem : elem.parameters) {
            offset += parameter_encode(nested_elem, buf + offset);
        }
    }

    return offset;
}

}  // namespace sdp
