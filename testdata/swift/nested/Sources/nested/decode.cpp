/* decode.cpp - Decoding implementations for nested
 * Generated by sdp-gen - DO NOT EDIT
 */

#include "decode.hpp"
#include "endian.hpp"
#include <cstring>

namespace sdp {

/* Array size limits */
constexpr uint32_t MAX_ARRAY_ELEMENTS = 1000000;
constexpr uint32_t MAX_TOTAL_ELEMENTS = 10000000;

/* Forward declarations for internal decode helpers */
static Point point_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static Rectangle rectangle_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);
static Scene scene_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset);

static Point point_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Point result;

    /* x */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.x = sdp_le_to_f32(*(const uint32_t*)(buf + offset));
    offset += 4;

    /* y */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.y = sdp_le_to_f32(*(const uint32_t*)(buf + offset));
    offset += 4;

    return result;
}

Point point_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return point_decode_impl(buf, buf_len, offset);
}

static Rectangle rectangle_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Rectangle result;

    /* top_left */
    result.top_left = point_decode_impl(buf, buf_len, offset);

    /* bottom_right */
    result.bottom_right = point_decode_impl(buf, buf_len, offset);

    /* color */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.color = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    return result;
}

Rectangle rectangle_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return rectangle_decode_impl(buf, buf_len, offset);
}

static Scene scene_decode_impl(const uint8_t* buf, size_t buf_len, size_t& offset) {
    Scene result;

    /* name */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    uint32_t name_len = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;
    if (offset + name_len > buf_len) throw DecodeError("Buffer too small");
    result.name = std::string(reinterpret_cast<const char*>(buf + offset), name_len);
    offset += name_len;

    /* main_rect */
    result.main_rect = rectangle_decode_impl(buf, buf_len, offset);

    /* count */
    if (offset + 4 > buf_len) throw DecodeError("Buffer too small");
    result.count = SDP_LE32TOH(*(const uint32_t*)(buf + offset));
    offset += 4;

    return result;
}

Scene scene_decode(const uint8_t* buf, size_t buf_len) {
    size_t offset = 0;
    return scene_decode_impl(buf, buf_len, offset);
}

}  // namespace sdp
