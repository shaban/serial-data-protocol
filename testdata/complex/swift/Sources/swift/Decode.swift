// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var idBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &idBytes, from: offset..<offset+4)
        let id = UInt32(littleEndian: idBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var nameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &nameLenBytes, from: offset..<offset+4)
        let nameLen = Int(UInt32(littleEndian: nameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + nameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+nameLen]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var valueBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &valueBitsBytes, from: offset..<offset+4)
        let valueBits = UInt32(littleEndian: valueBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let value = Float(bitPattern: valueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var minBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &minBitsBytes, from: offset..<offset+4)
        let minBits = UInt32(littleEndian: minBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let min = Float(bitPattern: minBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var maxBitsBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &maxBitsBytes, from: offset..<offset+4)
        let maxBits = UInt32(littleEndian: maxBitsBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        let max = Float(bitPattern: maxBits)
        offset += 4

        return Self(
            id: id,
            name: name,
            value: value,
            min: min,
            max: max
        )
    }
}

extension Plugin {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var idBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &idBytes, from: offset..<offset+4)
        let id = UInt32(littleEndian: idBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var nameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &nameLenBytes, from: offset..<offset+4)
        let nameLen = Int(UInt32(littleEndian: nameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + nameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+nameLen]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var manufacturerLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &manufacturerLenBytes, from: offset..<offset+4)
        let manufacturerLen = Int(UInt32(littleEndian: manufacturerLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + manufacturerLen <= data.count else { throw SDPDecodeError.insufficientData }
        let manufacturerData = data[offset..<offset+manufacturerLen]
        guard let manufacturer = String(data: manufacturerData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += manufacturerLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var versionBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &versionBytes, from: offset..<offset+4)
        let version = UInt32(littleEndian: versionBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let enabledByte = data[offset]
        guard enabledByte == 0 || enabledByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let enabled = enabledByte == 1
        offset += 1
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var parametersLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &parametersLenBytes, from: offset..<offset+4)
        let parametersLen = Int(UInt32(littleEndian: parametersLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var parameters: [Parameter] = []
        parameters.reserveCapacity(Int(parametersLen))
        for _ in 0..<Int(parametersLen) {
            let elem = try Parameter.decode(from: data[offset...])
            offset += elem.encodedSize()
            parameters.append(elem)
        }

        return Self(
            id: id,
            name: name,
            manufacturer: manufacturer,
            version: version,
            enabled: enabled,
            parameters: parameters
        )
    }
}

extension AudioDevice {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var deviceIdBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &deviceIdBytes, from: offset..<offset+4)
        let deviceId = UInt32(littleEndian: deviceIdBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var deviceNameLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &deviceNameLenBytes, from: offset..<offset+4)
        let deviceNameLen = Int(UInt32(littleEndian: deviceNameLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        guard offset + deviceNameLen <= data.count else { throw SDPDecodeError.insufficientData }
        let deviceNameData = data[offset..<offset+deviceNameLen]
        guard let deviceName = String(data: deviceNameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += deviceNameLen
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var sampleRateBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &sampleRateBytes, from: offset..<offset+4)
        let sampleRate = UInt32(littleEndian: sampleRateBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var bufferSizeBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &bufferSizeBytes, from: offset..<offset+4)
        let bufferSize = UInt32(littleEndian: bufferSizeBytes.withUnsafeBytes { $0.load(as: UInt32.self) })
        offset += 4
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        var inputChannelsBytes = [UInt8](repeating: 0, count: 2)
        data.copyBytes(to: &inputChannelsBytes, from: offset..<offset+2)
        let inputChannels = UInt16(littleEndian: inputChannelsBytes.withUnsafeBytes { $0.load(as: UInt16.self) })
        offset += 2
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        var outputChannelsBytes = [UInt8](repeating: 0, count: 2)
        data.copyBytes(to: &outputChannelsBytes, from: offset..<offset+2)
        let outputChannels = UInt16(littleEndian: outputChannelsBytes.withUnsafeBytes { $0.load(as: UInt16.self) })
        offset += 2
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let isDefaultByte = data[offset]
        guard isDefaultByte == 0 || isDefaultByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let isDefault = isDefaultByte == 1
        offset += 1
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        var activePluginsLenBytes = [UInt8](repeating: 0, count: 4)
        data.copyBytes(to: &activePluginsLenBytes, from: offset..<offset+4)
        let activePluginsLen = Int(UInt32(littleEndian: activePluginsLenBytes.withUnsafeBytes { $0.load(as: UInt32.self) }))
        offset += 4
        var activePlugins: [Plugin] = []
        activePlugins.reserveCapacity(Int(activePluginsLen))
        for _ in 0..<Int(activePluginsLen) {
            let elem = try Plugin.decode(from: data[offset...])
            offset += elem.encodedSize()
            activePlugins.append(elem)
        }

        return Self(
            deviceId: deviceId,
            deviceName: deviceName,
            sampleRate: sampleRate,
            bufferSize: bufferSize,
            inputChannels: inputChannels,
            outputChannels: outputChannels,
            isDefault: isDefault,
            activePlugins: activePlugins
        )
    }
}

