// Code generated by sdp-gen. DO NOT EDIT.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let id = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + nameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameBytes = Array(bytes[offset..<offset+nameLen])
        guard let name = String(bytes: nameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let valueBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let value = Float(bitPattern: valueBits)
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let minBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let min = Float(bitPattern: minBits)
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let maxBits = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        let max = Float(bitPattern: maxBits)
        offset += 4

        return Self(
            id: id,
            name: name,
            value: value,
            min: min,
            max: max
        )
    }
}

extension Plugin {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let id = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + nameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let nameBytes = Array(bytes[offset..<offset+nameLen])
        guard let name = String(bytes: nameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += nameLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let manufacturerLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + manufacturerLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let manufacturerBytes = Array(bytes[offset..<offset+manufacturerLen])
        guard let manufacturer = String(bytes: manufacturerBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += manufacturerLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let version = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
        let enabledByte = bytes[offset]
        guard enabledByte == 0 || enabledByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let enabled = enabledByte == 1
        offset += 1
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let parametersLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var parameters: [Parameter] = []
        parameters.reserveCapacity(Int(parametersLen))
        for _ in 0..<Int(parametersLen) {
            let elem = try Parameter.decode(from: Array(bytes[offset...]))
            offset += elem.encodedSize()
            parameters.append(elem)
        }

        return Self(
            id: id,
            name: name,
            manufacturer: manufacturer,
            version: version,
            enabled: enabled,
            parameters: parameters
        )
    }
}

extension AudioDevice {
    /// Decode from byte array
    public static func decode(from bytes: [UInt8]) throws -> Self {
        var offset = 0

        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let deviceId = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let deviceNameLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        guard offset + deviceNameLen <= bytes.count else { throw SDPDecodeError.insufficientData }
        let deviceNameBytes = Array(bytes[offset..<offset+deviceNameLen])
        guard let deviceName = String(bytes: deviceNameBytes, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += deviceNameLen
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let sampleRate = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let bufferSize = bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) }
        offset += 4
        guard offset + 2 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let inputChannels = bytes[offset..<offset+2].withUnsafeBytes { UInt16(littleEndian: $0.load(as: UInt16.self)) }
        offset += 2
        guard offset + 2 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let outputChannels = bytes[offset..<offset+2].withUnsafeBytes { UInt16(littleEndian: $0.load(as: UInt16.self)) }
        offset += 2
        guard offset < bytes.count else { throw SDPDecodeError.insufficientData }
        let isDefaultByte = bytes[offset]
        guard isDefaultByte == 0 || isDefaultByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let isDefault = isDefaultByte == 1
        offset += 1
        guard offset + 4 <= bytes.count else { throw SDPDecodeError.insufficientData }
        let activePluginsLen = Int(bytes[offset..<offset+4].withUnsafeBytes { UInt32(littleEndian: $0.load(as: UInt32.self)) })
        offset += 4
        var activePlugins: [Plugin] = []
        activePlugins.reserveCapacity(Int(activePluginsLen))
        for _ in 0..<Int(activePluginsLen) {
            let elem = try Plugin.decode(from: Array(bytes[offset...]))
            offset += elem.encodedSize()
            activePlugins.append(elem)
        }

        return Self(
            deviceId: deviceId,
            deviceName: deviceName,
            sampleRate: sampleRate,
            bufferSize: bufferSize,
            inputChannels: inputChannels,
            outputChannels: outputChannels,
            isDefault: isDefault,
            activePlugins: activePlugins
        )
    }
}

