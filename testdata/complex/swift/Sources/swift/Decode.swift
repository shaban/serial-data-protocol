// Code generated by sdp-gen. DO NOT EDIT.

import Foundation

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let id = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let nameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(nameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+Int(nameLen)]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(nameLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let valueBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let value = Float(bitPattern: valueBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let minBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let min = Float(bitPattern: minBits)
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let maxBits = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        let max = Float(bitPattern: maxBits)
        offset += 4

        return Self(
            id: id,
            name: name,
            value: value,
            min: min,
            max: max
        )
    }
}

extension Plugin {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let id = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let nameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(nameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let nameData = data[offset..<offset+Int(nameLen)]
        guard let name = String(data: nameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(nameLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let manufacturerLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(manufacturerLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let manufacturerData = data[offset..<offset+Int(manufacturerLen)]
        guard let manufacturer = String(data: manufacturerData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(manufacturerLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let version = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let enabledByte = data[offset]
        guard enabledByte == 0 || enabledByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let enabled = enabledByte == 1
        offset += 1
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let parametersLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var parameters: [Parameter] = []
        parameters.reserveCapacity(Int(parametersLen))
        for _ in 0..<Int(parametersLen) {
            let elem = try Parameter.decode(from: data[offset...])
            offset += elem.encodedSize()
            parameters.append(elem)
        }

        return Self(
            id: id,
            name: name,
            manufacturer: manufacturer,
            version: version,
            enabled: enabled,
            parameters: parameters
        )
    }
}

extension AudioDevice {
    /// Decode from Data
    public static func decode(from data: Data) throws -> Self {
        var offset = 0

        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let deviceId = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let deviceNameLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + Int(deviceNameLen) <= data.count else { throw SDPDecodeError.insufficientData }
        let deviceNameData = data[offset..<offset+Int(deviceNameLen)]
        guard let deviceName = String(data: deviceNameData, encoding: .utf8) else {
            throw SDPDecodeError.invalidUTF8
        }
        offset += Int(deviceNameLen)
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let sampleRate = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let bufferSize = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        let inputChannels = data[offset..<offset+2].withUnsafeBytes {
            $0.load(as: UInt16.self).littleEndian
        }
        offset += 2
        guard offset + 2 <= data.count else { throw SDPDecodeError.insufficientData }
        let outputChannels = data[offset..<offset+2].withUnsafeBytes {
            $0.load(as: UInt16.self).littleEndian
        }
        offset += 2
        guard offset < data.count else { throw SDPDecodeError.insufficientData }
        let isDefaultByte = data[offset]
        guard isDefaultByte == 0 || isDefaultByte == 1 else { throw SDPDecodeError.invalidBoolValue }
        let isDefault = isDefaultByte == 1
        offset += 1
        guard offset + 4 <= data.count else { throw SDPDecodeError.insufficientData }
        let activePluginsLen = data[offset..<offset+4].withUnsafeBytes {
            $0.load(as: UInt32.self).littleEndian
        }
        offset += 4
        var activePlugins: [Plugin] = []
        activePlugins.reserveCapacity(Int(activePluginsLen))
        for _ in 0..<Int(activePluginsLen) {
            let elem = try Plugin.decode(from: data[offset...])
            offset += elem.encodedSize()
            activePlugins.append(elem)
        }

        return Self(
            deviceId: deviceId,
            deviceName: deviceName,
            sampleRate: sampleRate,
            bufferSize: bufferSize,
            inputChannels: inputChannels,
            outputChannels: outputChannels,
            isDefault: isDefault,
            activePlugins: activePlugins
        )
    }
}

