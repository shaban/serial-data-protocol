// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (3x faster decoding).
// All memory accesses are bounds-checked once at function entry.
// Safe for use - the unsafe operations are verified by the code generator.

public enum SDPDecodeError: Error {
    case insufficientData
    case invalidUTF8
    case invalidBoolValue
}

extension Parameter {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let idPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let id = UInt32(littleEndian: idPtr.load(as: UInt32.self))
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let nameLen = Int(UInt32(littleEndian: nameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + nameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: nameLen)
            let name = String(decoding: nameBuffer, as: UTF8.self)
            offset += nameLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let valuePtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let valueBits = UInt32(littleEndian: valuePtr.load(as: UInt32.self))
            let value = Float(bitPattern: valueBits)
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let minPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let minBits = UInt32(littleEndian: minPtr.load(as: UInt32.self))
            let min = Float(bitPattern: minBits)
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let maxPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let maxBits = UInt32(littleEndian: maxPtr.load(as: UInt32.self))
            let max = Float(bitPattern: maxBits)
            offset += 4

            return Self(
                id: id,
                name: name,
                value: value,
                min: min,
                max: max
            )
        }
    }
}

extension Plugin {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let idPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let id = UInt32(littleEndian: idPtr.load(as: UInt32.self))
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let nameLen = Int(UInt32(littleEndian: nameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + nameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let nameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: nameLen)
            let name = String(decoding: nameBuffer, as: UTF8.self)
            offset += nameLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let manufacturerLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let manufacturerLen = Int(UInt32(littleEndian: manufacturerLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + manufacturerLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let manufacturerBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: manufacturerLen)
            let manufacturer = String(decoding: manufacturerBuffer, as: UTF8.self)
            offset += manufacturerLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let versionPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let version = UInt32(littleEndian: versionPtr.load(as: UInt32.self))
            offset += 4
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let enabledByte = buffer[offset]
            guard enabledByte == 0 || enabledByte == 1 else { throw SDPDecodeError.invalidBoolValue }
            let enabled = enabledByte == 1
            offset += 1
            // Decode array parameters
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let parametersLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let parametersLen = Int(UInt32(littleEndian: parametersLenPtr.load(as: UInt32.self)))
            offset += 4

            var parameters = ContiguousArray<Parameter>()
            parameters.reserveCapacity(parametersLen)
            for _ in 0..<parametersLen {
                let elem = try Parameter.decode(from: Array(bytes[offset...]))
                offset += elem.encodedSize()
                parameters.append(elem)
            }

            return Self(
                id: id,
                name: name,
                manufacturer: manufacturer,
                version: version,
                enabled: enabled,
                parameters: parameters
            )
        }
    }
}

extension AudioDevice {
    /// Decode from byte array (unsafe optimized)
    public static func decode(from bytes: [UInt8]) throws -> Self {
        // Bounds check once upfront for performance
        guard !bytes.isEmpty else { throw SDPDecodeError.insufficientData }

        return try bytes.withUnsafeBytes { bufferPtr -> Self in
            guard let baseAddress = bufferPtr.baseAddress else {
                throw SDPDecodeError.insufficientData
            }
            let buffer = baseAddress.assumingMemoryBound(to: UInt8.self)
            let _bufferSize = bufferPtr.count
            var offset = 0

            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let deviceIdPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let deviceId = UInt32(littleEndian: deviceIdPtr.load(as: UInt32.self))
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let deviceNameLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let deviceNameLen = Int(UInt32(littleEndian: deviceNameLenPtr.load(as: UInt32.self)))
            offset += 4
            guard offset + deviceNameLen <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let deviceNameBuffer = UnsafeBufferPointer(start: buffer.advanced(by: offset), count: deviceNameLen)
            let deviceName = String(decoding: deviceNameBuffer, as: UTF8.self)
            offset += deviceNameLen
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let sampleRatePtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let sampleRate = UInt32(littleEndian: sampleRatePtr.load(as: UInt32.self))
            offset += 4
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let bufferSizePtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let bufferSize = UInt32(littleEndian: bufferSizePtr.load(as: UInt32.self))
            offset += 4
            guard offset + 2 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let inputChannelsPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let inputChannels = UInt16(littleEndian: inputChannelsPtr.load(as: UInt16.self))
            offset += 2
            guard offset + 2 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let outputChannelsPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let outputChannels = UInt16(littleEndian: outputChannelsPtr.load(as: UInt16.self))
            offset += 2
            guard offset < _bufferSize else { throw SDPDecodeError.insufficientData }
            let isDefaultByte = buffer[offset]
            guard isDefaultByte == 0 || isDefaultByte == 1 else { throw SDPDecodeError.invalidBoolValue }
            let isDefault = isDefaultByte == 1
            offset += 1
            // Decode array activePlugins
            guard offset + 4 <= _bufferSize else { throw SDPDecodeError.insufficientData }
            let activePluginsLenPtr = UnsafeRawPointer(buffer.advanced(by: offset))
            let activePluginsLen = Int(UInt32(littleEndian: activePluginsLenPtr.load(as: UInt32.self)))
            offset += 4

            var activePlugins = ContiguousArray<Plugin>()
            activePlugins.reserveCapacity(activePluginsLen)
            for _ in 0..<activePluginsLen {
                let elem = try Plugin.decode(from: Array(bytes[offset...]))
                offset += elem.encodedSize()
                activePlugins.append(elem)
            }

            return Self(
                deviceId: deviceId,
                deviceName: deviceName,
                sampleRate: sampleRate,
                bufferSize: bufferSize,
                inputChannels: inputChannels,
                outputChannels: outputChannels,
                isDefault: isDefault,
                activePlugins: activePlugins
            )
        }
    }
}

