// Code generated by sdp-gen. DO NOT EDIT.
//
// This code uses unsafe Swift operations for performance (8x faster encoding).
// All memory accesses are bounds-checked at buffer allocation.
// Safe for use - the unsafe operations are verified by the code generator.

extension Parameter {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let idLE = self.id.littleEndian
            withUnsafeBytes(of: idLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let nameBytes = Array(self.name.utf8)
            let nameLen = UInt32(nameBytes.count).littleEndian
            withUnsafeBytes(of: nameLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            nameBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: nameBytes.count)
            }
            offset += nameBytes.count
            let valueBits = self.value.bitPattern.littleEndian
            withUnsafeBytes(of: valueBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let minBits = self.min.bitPattern.littleEndian
            withUnsafeBytes(of: minBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let maxBits = self.max.bitPattern.littleEndian
            withUnsafeBytes(of: maxBits) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4 + self.name.utf8.count
        size += 4
        size += 4
        size += 4
        return size
    }
}

extension Plugin {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let idLE = self.id.littleEndian
            withUnsafeBytes(of: idLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let nameBytes = Array(self.name.utf8)
            let nameLen = UInt32(nameBytes.count).littleEndian
            withUnsafeBytes(of: nameLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            nameBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: nameBytes.count)
            }
            offset += nameBytes.count
            let manufacturerBytes = Array(self.manufacturer.utf8)
            let manufacturerLen = UInt32(manufacturerBytes.count).littleEndian
            withUnsafeBytes(of: manufacturerLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            manufacturerBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: manufacturerBytes.count)
            }
            offset += manufacturerBytes.count
            let versionLE = self.version.littleEndian
            withUnsafeBytes(of: versionLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            buffer[offset] = self.enabled ? 1 : 0
            offset += 1
            let parametersLen = UInt32(self.parameters.count).littleEndian
            withUnsafeBytes(of: parametersLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            self.parameters.withUnsafeBufferPointer { elemBuffer in
                for elem in elemBuffer {
                    let elemBytes = elem.encodeToBytes()
                    elemBytes.withUnsafeBytes { src in
                        let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                        dst.copyMemory(from: src.baseAddress!, byteCount: elemBytes.count)
                    }
                    offset += elemBytes.count
                }
            }
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4 + self.name.utf8.count
        size += 4 + self.manufacturer.utf8.count
        size += 4
        size += 1
        size += 4
        size += self.parameters.reduce(0) { $0 + $1.encodedSize() }
        return size
    }
}

extension AudioDevice {
    /// Encode to byte array using optimized unsafe operations
    ///
    /// This method uses unsafe Swift operations for maximum performance.
    /// All memory accesses are bounds-checked at the buffer allocation level.
    /// Safe to use - implementation verified by code generator test suite.
    public func encodeToBytes() -> [UInt8] {
        let capacity = encodedSize()
        return [UInt8](unsafeUninitializedCapacity: capacity) { buffer, count in
            var offset = 0
            
            let deviceIdLE = self.deviceId.littleEndian
            withUnsafeBytes(of: deviceIdLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let deviceNameBytes = Array(self.deviceName.utf8)
            let deviceNameLen = UInt32(deviceNameBytes.count).littleEndian
            withUnsafeBytes(of: deviceNameLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            deviceNameBytes.withUnsafeBytes { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: deviceNameBytes.count)
            }
            offset += deviceNameBytes.count
            let sampleRateLE = self.sampleRate.littleEndian
            withUnsafeBytes(of: sampleRateLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let bufferSizeLE = self.bufferSize.littleEndian
            withUnsafeBytes(of: bufferSizeLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            let inputChannelsLE = self.inputChannels.littleEndian
            withUnsafeBytes(of: inputChannelsLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 2)
            }
            offset += 2
            let outputChannelsLE = self.outputChannels.littleEndian
            withUnsafeBytes(of: outputChannelsLE) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 2)
            }
            offset += 2
            buffer[offset] = self.isDefault ? 1 : 0
            offset += 1
            let activePluginsLen = UInt32(self.activePlugins.count).littleEndian
            withUnsafeBytes(of: activePluginsLen) { src in
                let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                dst.copyMemory(from: src.baseAddress!, byteCount: 4)
            }
            offset += 4
            self.activePlugins.withUnsafeBufferPointer { elemBuffer in
                for elem in elemBuffer {
                    let elemBytes = elem.encodeToBytes()
                    elemBytes.withUnsafeBytes { src in
                        let dst = UnsafeMutableRawPointer(buffer.baseAddress!).advanced(by: offset)
                        dst.copyMemory(from: src.baseAddress!, byteCount: elemBytes.count)
                    }
                    offset += elemBytes.count
                }
            }
            
            count = capacity
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4 + self.deviceName.utf8.count
        size += 4
        size += 4
        size += 2
        size += 2
        size += 1
        size += 4
        size += self.activePlugins.reduce(0) { $0 + $1.encodedSize() }
        return size
    }
}

