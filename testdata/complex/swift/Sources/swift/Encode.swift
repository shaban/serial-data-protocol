// Code generated by sdp-gen. DO NOT EDIT.

extension Parameter {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.id.littleEndian) { bytes.append(contentsOf: $0) }
        let nameBytes = Array(self.name.utf8)
        let nameLen = UInt32(nameBytes.count).littleEndian
        withUnsafeBytes(of: nameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: nameBytes)
        let valueBits = self.value.bitPattern.littleEndian
        withUnsafeBytes(of: valueBits) { bytes.append(contentsOf: $0) }
        let minBits = self.min.bitPattern.littleEndian
        withUnsafeBytes(of: minBits) { bytes.append(contentsOf: $0) }
        let maxBits = self.max.bitPattern.littleEndian
        withUnsafeBytes(of: maxBits) { bytes.append(contentsOf: $0) }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4 + self.name.utf8.count
        size += 4
        size += 4
        size += 4
        return size
    }
}

extension Plugin {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.id.littleEndian) { bytes.append(contentsOf: $0) }
        let nameBytes = Array(self.name.utf8)
        let nameLen = UInt32(nameBytes.count).littleEndian
        withUnsafeBytes(of: nameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: nameBytes)
        let manufacturerBytes = Array(self.manufacturer.utf8)
        let manufacturerLen = UInt32(manufacturerBytes.count).littleEndian
        withUnsafeBytes(of: manufacturerLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: manufacturerBytes)
        withUnsafeBytes(of: self.version.littleEndian) { bytes.append(contentsOf: $0) }
        bytes.append(self.enabled ? 1 : 0)
        let parametersLen = UInt32(self.parameters.count).littleEndian
        withUnsafeBytes(of: parametersLen) { bytes.append(contentsOf: $0) }
        for elem in self.parameters {
            elem.encode(to: &bytes)
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4 + self.name.utf8.count
        size += 4 + self.manufacturer.utf8.count
        size += 4
        size += 1
        size += 4 // array length
        for elem in self.parameters {
            size += elem.encodedSize()
        }
        return size
    }
}

extension AudioDevice {
    /// Encode to byte array
    public func encodeToBytes() -> [UInt8] {
        var bytes = [UInt8]()
        bytes.reserveCapacity(encodedSize())
        encode(to: &bytes)
        return bytes
    }

    /// Encode to a byte array buffer
    public func encode(to bytes: inout [UInt8]) {
        withUnsafeBytes(of: self.deviceId.littleEndian) { bytes.append(contentsOf: $0) }
        let deviceNameBytes = Array(self.deviceName.utf8)
        let deviceNameLen = UInt32(deviceNameBytes.count).littleEndian
        withUnsafeBytes(of: deviceNameLen) { bytes.append(contentsOf: $0) }
        bytes.append(contentsOf: deviceNameBytes)
        withUnsafeBytes(of: self.sampleRate.littleEndian) { bytes.append(contentsOf: $0) }
        withUnsafeBytes(of: self.bufferSize.littleEndian) { bytes.append(contentsOf: $0) }
        withUnsafeBytes(of: self.inputChannels.littleEndian) { bytes.append(contentsOf: $0) }
        withUnsafeBytes(of: self.outputChannels.littleEndian) { bytes.append(contentsOf: $0) }
        bytes.append(self.isDefault ? 1 : 0)
        let activePluginsLen = UInt32(self.activePlugins.count).littleEndian
        withUnsafeBytes(of: activePluginsLen) { bytes.append(contentsOf: $0) }
        for elem in self.activePlugins {
            elem.encode(to: &bytes)
        }
    }

    /// Calculate the encoded size in bytes
    public func encodedSize() -> Int {
        var size = 0
        size += 4
        size += 4 + self.deviceName.utf8.count
        size += 4
        size += 4
        size += 2
        size += 2
        size += 1
        size += 4 // array length
        for elem in self.activePlugins {
            size += elem.encodedSize()
        }
        return size
    }
}

